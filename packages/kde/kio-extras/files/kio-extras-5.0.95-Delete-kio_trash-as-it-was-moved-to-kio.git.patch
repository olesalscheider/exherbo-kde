Upstream: yes

From c09ff9615b9df6e1e412228ee4cec75a0fa2de47 Mon Sep 17 00:00:00 2001
From: Jonathan Riddell <jr@jriddell.org>
Date: Thu, 2 Oct 2014 13:56:51 +0200
Subject: [PATCH 1/2] set minimum kf5 version to 5.3

seems this module also requires 5.3 to set it explicitly
---
 CMakeLists.txt | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b582741..53381c0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -7,6 +7,7 @@ cmake_minimum_required(VERSION 2.8.12 FATAL_ERROR)
 include(FeatureSummary)
 
 set(QT_MIN_VERSION "5.3.0")
+set(KF5_MIN_VERSION "5.3.0")
 find_package(Qt5 ${QT_MIN_VERSION} CONFIG REQUIRED COMPONENTS DBus Network Widgets Svg)
 
 find_package(Qt5Test ${QT_MIN_VERSION} CONFIG QUIET)
@@ -22,7 +23,7 @@ endif()
 find_package(ECM 0.0.11 REQUIRED NO_MODULE)
 set(CMAKE_MODULE_PATH ${ECM_MODULE_PATH} ${ECM_KDE_MODULE_DIR} "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
 
-find_package(KF5 REQUIRED COMPONENTS
+find_package(KF5 ${KF5_MIN_VERSION} REQUIRED COMPONENTS
     Archive
     Config
     ConfigWidgets
-- 
2.1.2


From f23c311a4869b920f77465b4458ba4c7efd3a4f3 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Nicol=C3=A1s=20Alvarez?= <nicolas.alvarez@gmail.com>
Date: Fri, 3 Oct 2014 08:20:21 -0300
Subject: [PATCH 2/2] Delete kio_trash as it was moved to kio.git.

---
 CMakeLists.txt              |    1 -
 trash/CMakeLists.txt        |   69 ---
 trash/DESIGN                |   55 --
 trash/Messages.sh           |    2 -
 trash/discspaceutil.cpp     |   93 ----
 trash/discspaceutil.h       |   73 ---
 trash/kcmtrash.cpp          |  311 -----------
 trash/kcmtrash.desktop      |  395 --------------
 trash/kcmtrash.h            |   82 ---
 trash/kinterprocesslock.cpp |   92 ----
 trash/kinterprocesslock.h   |  118 -----
 trash/kio_trash.cpp         |  597 ----------------------
 trash/kio_trash.h           |   75 ---
 trash/kio_trash_win.cpp     |  437 ----------------
 trash/kio_trash_win.h       |   71 ---
 trash/ktrash.cpp            |   79 ---
 trash/tests/CMakeLists.txt  |   24 -
 trash/tests/lockingtest.cpp |   51 --
 trash/tests/testtrash.cpp   | 1188 -------------------------------------------
 trash/tests/testtrash.h     |  126 -----
 trash/trash.protocol        |  111 ----
 trash/trashimpl.cpp         | 1167 ------------------------------------------
 trash/trashimpl.h           |  185 -------
 trash/trashsizecache.cpp    |  158 ------
 trash/trashsizecache.h      |   74 ---
 25 files changed, 5634 deletions(-)
 delete mode 100644 trash/CMakeLists.txt
 delete mode 100644 trash/DESIGN
 delete mode 100644 trash/Messages.sh
 delete mode 100644 trash/discspaceutil.cpp
 delete mode 100644 trash/discspaceutil.h
 delete mode 100644 trash/kcmtrash.cpp
 delete mode 100644 trash/kcmtrash.desktop
 delete mode 100644 trash/kcmtrash.h
 delete mode 100644 trash/kinterprocesslock.cpp
 delete mode 100644 trash/kinterprocesslock.h
 delete mode 100644 trash/kio_trash.cpp
 delete mode 100644 trash/kio_trash.h
 delete mode 100644 trash/kio_trash_win.cpp
 delete mode 100644 trash/kio_trash_win.h
 delete mode 100644 trash/ktrash.cpp
 delete mode 100644 trash/tests/CMakeLists.txt
 delete mode 100644 trash/tests/lockingtest.cpp
 delete mode 100644 trash/tests/testtrash.cpp
 delete mode 100644 trash/tests/testtrash.h
 delete mode 100644 trash/trash.protocol
 delete mode 100644 trash/trashimpl.cpp
 delete mode 100644 trash/trashimpl.h
 delete mode 100644 trash/trashsizecache.cpp
 delete mode 100644 trash/trashsizecache.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 53381c0..3631f8a 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -115,7 +115,6 @@ if(Phonon4Qt5_FOUND)
 endif()
 add_subdirectory( info )
 add_subdirectory( archive )
-add_subdirectory( trash )
 if(NOT WIN32)
     add_subdirectory( network )
 endif()
diff --git a/trash/CMakeLists.txt b/trash/CMakeLists.txt
deleted file mode 100644
index e48019b..0000000
--- a/trash/CMakeLists.txt
+++ /dev/null
@@ -1,69 +0,0 @@
-# find_package(Strigi)
-# set_package_properties(Strigi PROPERTIES DESCRIPTION "Desktop indexing and search support"
-#                        URL "http://strigi.sourceforge.net"
-#                        TYPE ${STRIGI_TYPE}
-#                       )
-# if (WIN32)
-#     set (STRIGI_TYPE "OPTIONAL")
-# else ()
-#     set (STRIGI_TYPE "REQUIRED")
-# endif ()
-
-add_definitions(-DTRANSLATION_DOMAIN=\"kio_trash\")
-add_definitions(-DQT_DISABLE_DEPRECATED_BEFORE=0)
-
-add_subdirectory(tests)
-
-set (trashcommon_PART_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/trashimpl.cpp
-                           ${CMAKE_CURRENT_SOURCE_DIR}/discspaceutil.cpp
-                           ${CMAKE_CURRENT_SOURCE_DIR}/trashsizecache.cpp
-                           ${CMAKE_CURRENT_SOURCE_DIR}/kinterprocesslock.cpp
-    )
-
-########### next target ###############
-if(WIN32)
-  set(kio_trash_PART_SRCS kio_trash_win.cpp kio_trash_win.h)
-else()
-  set(kio_trash_PART_SRCS kio_trash.cpp ${trashcommon_PART_SRCS})
-endif()
-add_library(kio_trash MODULE ${kio_trash_PART_SRCS})
-
-target_link_libraries(kio_trash
-	KF5::Solid
-        KF5::KDE4Support
-	KF5::KIOCore
-        Qt5::DBus
-        KF5::I18n KF5::ConfigCore KF5::ConfigGui 
-        )
-install(TARGETS kio_trash  DESTINATION ${PLUGIN_INSTALL_DIR} )
-
-set(ktrash_SRCS ktrash.cpp )
-
-add_executable(ktrash5 ${ktrash_SRCS})
-target_compile_definitions(ktrash5 PRIVATE -DPROJECT_VERSION="${PROJECT_VERSION}")
-ecm_mark_nongui_executable(ktrash5)
-
-target_link_libraries(ktrash5
-        KF5::KDE4Support
-	KF5::KIOCore
-        KF5::I18n KF5::ConfigCore KF5::ConfigGui
-        )
-
-install(TARGETS ktrash5 ${INSTALL_TARGETS_DEFAULT_ARGS})
-
-########### next target ###############
-
-# currently not on win32, TODO!
-if(NOT WIN32)
-    set(kcm_trash_PART_SRCS kcmtrash.cpp ${trashcommon_PART_SRCS})
-    add_library(kcm_trash MODULE ${kcm_trash_PART_SRCS})
-    target_link_libraries(kcm_trash  Qt5::DBus  KF5::KDE4Support
-        ${KDECLARATIVE_LIBRARIES} KF5::I18n KF5::ConfigWidgets KF5::KIOCore KF5::Solid)
-
-    install(TARGETS kcm_trash DESTINATION ${PLUGIN_INSTALL_DIR})
-endif()
-
-########### install files ###############
-
-install( FILES trash.protocol  DESTINATION  ${SERVICES_INSTALL_DIR} )
-install( FILES kcmtrash.desktop DESTINATION ${SERVICES_INSTALL_DIR} )
diff --git a/trash/DESIGN b/trash/DESIGN
deleted file mode 100644
index 2950ca4..0000000
--- a/trash/DESIGN
+++ /dev/null
@@ -1,55 +0,0 @@
-DESIGN
-======
-kio_trash implements the XDG trash standard currently at http://www.ramendik.ru/docs/trashspec.html
-
-The concurrency that comes from having multiple kioslaves running at the same time
-on top of the same set of files, is solved by the KInterProcessLock class, which
-synchronizes access to shared resources (like the file storing the size of the
-trash directory).
-
-BUGS
-====
-* Undo of "restore" isn't available. Need to get origPath by metadata I guess.
-
-TODO
-====
-* Clean up konq_popupmenu.cc for Type=Link URL=trash:/   :(
-* Also, provide metainfo for trash contents for that desktop link.
-=> maybe we need a new mimetype?
- Like application/x-trash-desktop, inheriting application/x-desktop. 
- And a "trash.trashdesktop" filename or so (ouch, migration issues...)
-
-* Detect removeable media to avoid .Trash-foo on it. How?
-
-* Trashcan properties (properties for trash:/? hmm. Easier with separate dialog)
-     -  Maximum size for trash can (#18109 suggests a %, but a MB size is easier).
-     This means to delete the oldest files from the trash automatically. #79553
-
-* Err, should we support renaming? :) Difficult to disable...
-  In fact it's already not disabled in readonly directories (e.g. "/") -> todo
-   (for F2 and kpropertiesdialog)
-
-Bugs closed by kio_trash
-========================
-#79826 (3.3 only)
-#62848 (configurable trash location)
-#78116 (.directory)
-#18109 (general one)
-#17744 (restore)
-#76380 #56821 (trashing on same partition)
-
-New features implemented
-=======================
-#79553 (Deleting oldest files when size is bigger than a certain configurable amount)
-
-Choice of URL scheme
-====================
-We use trash:/trashid-fileid[/relativepath]    
-This gave problems with CopyJob::startRenameJob which exposed trashid-fileid
-to the user as a filename when dropping a file out of the trash.
-But this was fixed with the fileNameUsedForCopying=Name setting.
-
-A previous experiment was trash:/filename[/relativepath]?t=trashid&id=fileid
-but this gives problems with going Up (it first removes the query),
-with KDirLister (it wouldn't know when to remove the query, to find the URL
-of the parent directory).
diff --git a/trash/Messages.sh b/trash/Messages.sh
deleted file mode 100644
index 3f33433..0000000
--- a/trash/Messages.sh
+++ /dev/null
@@ -1,2 +0,0 @@
-#! /usr/bin/env bash
-$XGETTEXT `find -name "*.cpp" -o -name "*.h"` -o $podir/kio_trash.pot
diff --git a/trash/discspaceutil.cpp b/trash/discspaceutil.cpp
deleted file mode 100644
index 75e46fc..0000000
--- a/trash/discspaceutil.cpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
-   This file is part of the KDE project
-
-   Copyright (C) 2008 Tobias Koenig <tokoe@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#include "discspaceutil.h"
-
-#include <QtCore/QDirIterator>
-#include <QtCore/QFileInfo>
-
-#include <kdiskfreespaceinfo.h>
-#include <QDebug>
-#include <qplatformdefs.h> // QT_LSTAT, QT_STAT, QT_STATBUF
-
-DiscSpaceUtil::DiscSpaceUtil( const QString &directory )
-    : mDirectory( directory ),
-      mFullSize( 0 )
-{
-    calculateFullSize();
-}
-
-qulonglong DiscSpaceUtil::sizeOfPath( const QString &path )
-{
-    QFileInfo info( path );
-    if ( !info.exists() ) {
-        return 0;
-    }
-
-    if ( info.isSymLink() ) {
-        // QFileInfo::size does not return the actual size of a symlink. #253776
-        QT_STATBUF buff;
-        return static_cast<qulonglong>(QT_LSTAT(QFile::encodeName(path), &buff) == 0 ? buff.st_size : 0);
-    } else if ( info.isFile() ) {
-        return info.size();
-    } else if ( info.isDir() ) {
-        QDirIterator it( path, QDirIterator::NoIteratorFlags );
-
-        qulonglong sum = 0;
-        while ( it.hasNext() ) {
-            const QFileInfo info = it.next();
-
-            if (info.fileName() != QLatin1String(".") && info.fileName() != QLatin1String(".."))
-                sum += sizeOfPath( info.absoluteFilePath() );
-        }
-
-        return sum;
-    } else {
-        return 0;
-    }
-}
-
-double DiscSpaceUtil::usage( qulonglong size ) const
-{
-    if ( mFullSize == 0 )
-        return 0;
-
-    return (((double)size*100)/(double)mFullSize);
-}
-
-qulonglong DiscSpaceUtil::size() const
-{
-    return mFullSize;
-}
-
-QString DiscSpaceUtil::mountPoint() const
-{
-    return mMountPoint;
-}
-
-void DiscSpaceUtil::calculateFullSize()
-{
-    KDiskFreeSpaceInfo info = KDiskFreeSpaceInfo::freeSpaceInfo( mDirectory );
-    if ( info.isValid() ) {
-        mFullSize = info.size();
-        mMountPoint = info.mountPoint();
-    }
-}
diff --git a/trash/discspaceutil.h b/trash/discspaceutil.h
deleted file mode 100644
index 515c741..0000000
--- a/trash/discspaceutil.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
-   This file is part of the KDE project
-
-   Copyright (C) 2008 Tobias Koenig <tokoe@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef DISCSPACEUTIL_H
-#define DISCSPACEUTIL_H
-
-#include <QtCore/QString>
-
-/**
- * A small utility class to access and calculate
- * size and usage of mount points.
- */
-class DiscSpaceUtil
-{
-  public:
-    /**
-     * Creates a new disc space util.
-     *
-     * @param directory A directory the util shall work on.
-     * @param parent The parent object.
-     */
-    explicit DiscSpaceUtil( const QString &directory );
-
-    /**
-     * Returns the usage of the directory pass in the constructor on this
-     * mount point in percent.
-     *
-     * @param size The current size of the directory.
-     */
-    double usage( qulonglong size ) const;
-
-    /**
-     * Returns the size of the partition in bytes.
-     */
-    qulonglong size() const;
-
-    /**
-     * Returns the mount point of the directory.
-     */
-    QString mountPoint() const;
-
-    /**
-     * Returns the size of the given path in bytes.
-     */
-    static qulonglong sizeOfPath( const QString &path );
-
-  private:
-    void calculateFullSize();
-
-    QString mDirectory;
-    qulonglong mFullSize;
-    QString mMountPoint;
-};
-
-#endif
diff --git a/trash/kcmtrash.cpp b/trash/kcmtrash.cpp
deleted file mode 100644
index fbd64de..0000000
--- a/trash/kcmtrash.cpp
+++ /dev/null
@@ -1,311 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2008 by Tobias Koenig <tokoe@kde.org>                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA            *
- ***************************************************************************/
-
-#include "kcmtrash.h"
-#include "discspaceutil.h"
-#include "trashimpl.h"
-
-#include <QCheckBox>
-#include <QComboBox>
-#include <QDoubleSpinBox>
-#include <QFormLayout>
-#include <QLabel>
-#include <QLayout>
-#include <QListWidget>
-#include <QListWidgetItem>
-
-#include <kconfig.h>
-#include <kconfiggroup.h>
- #include <KLocalizedString>
-#include <qdialog.h>
-#include <kglobal.h>
-#include <qicon.h>
-#include <klocale.h>
-#include <kpluginfactory.h>
-#include <kpluginloader.h>
-#include <KIntSpinBox>
-#include <QDebug>
-
-K_PLUGIN_FACTORY( KCMTrashConfigFactory, registerPlugin<TrashConfigModule>( "trash" ); )
-K_EXPORT_PLUGIN( KCMTrashConfigFactory( "kcmtrash" ) )
-
-TrashConfigModule::TrashConfigModule( QWidget* parent, const QVariantList& )
-    : KCModule( //KCMTrashConfigFactory::componentData(),
-                parent ), trashInitialize( false )
-{
-    mTrashImpl = new TrashImpl();
-    mTrashImpl->init();
-
-    readConfig();
-
-    setupGui();
-
-    useTypeChanged();
-
-    connect( mUseTimeLimit, SIGNAL( toggled( bool ) ),
-             this, SLOT( changed() ) );
-    connect( mUseTimeLimit, SIGNAL( toggled( bool ) ),
-             this, SLOT( useTypeChanged() ) );
-    connect( mDays, SIGNAL( valueChanged( int ) ),
-             this, SLOT( changed() ) );
-    connect( mUseSizeLimit, SIGNAL( toggled( bool ) ),
-             this, SLOT( changed() ) );
-    connect( mUseSizeLimit, SIGNAL( toggled( bool ) ),
-             this, SLOT( useTypeChanged() ) );
-    connect( mPercent, SIGNAL( valueChanged( double ) ),
-             this, SLOT( percentChanged( double ) ) );
-    connect( mPercent, SIGNAL( valueChanged( double ) ),
-             this, SLOT( changed() ) );
-    connect( mLimitReachedAction, SIGNAL( currentIndexChanged( int ) ),
-             this, SLOT( changed() ) );
-
-    trashChanged( 0 );
-    trashInitialize = true;
-}
-
-TrashConfigModule::~TrashConfigModule()
-{
-}
-
-void TrashConfigModule::save()
-{
-    if ( !mCurrentTrash.isEmpty() ) {
-        ConfigEntry entry;
-        entry.useTimeLimit = mUseTimeLimit->isChecked();
-        entry.days = mDays->value();
-        entry.useSizeLimit = mUseSizeLimit->isChecked();
-        entry.percent = mPercent->value(),
-        entry.actionType = mLimitReachedAction->currentIndex();
-        mConfigMap.insert( mCurrentTrash, entry );
-    }
-
-    writeConfig();
-}
-
-void TrashConfigModule::defaults()
-{
-    ConfigEntry entry;
-    entry.useTimeLimit = false;
-    entry.days = 7;
-    entry.useSizeLimit = true;
-    entry.percent = 10.0;
-    entry.actionType = 0;
-    mConfigMap.insert( mCurrentTrash, entry );
-    trashInitialize = false;
-    trashChanged( 0 );
-}
-
-void TrashConfigModule::percentChanged( double percent )
-{
-    DiscSpaceUtil util( mCurrentTrash );
-
-    qulonglong partitionSize = util.size();
-    double size = ((double)(partitionSize/100))*percent;
-
-    mSizeLabel->setText("(" + KGlobal::locale()->formatByteSize(size, 2) + ")");
-}
-
-void TrashConfigModule::trashChanged( QListWidgetItem *item )
-{
-    trashChanged( item->data( Qt::UserRole ).toInt() );
-}
-
-void TrashConfigModule::trashChanged( int value )
-{
-    const TrashImpl::TrashDirMap map = mTrashImpl->trashDirectories();
-
-    if ( !mCurrentTrash.isEmpty() && trashInitialize ) {
-        ConfigEntry entry;
-        entry.useTimeLimit = mUseTimeLimit->isChecked();
-        entry.days = mDays->value();
-        entry.useSizeLimit = mUseSizeLimit->isChecked();
-        entry.percent = mPercent->value(),
-        entry.actionType = mLimitReachedAction->currentIndex();
-        mConfigMap.insert( mCurrentTrash, entry );
-    }
-
-    mCurrentTrash = map[ value ];
-    if ( mConfigMap.contains( mCurrentTrash ) ) {
-        const ConfigEntry entry = mConfigMap[ mCurrentTrash ];
-        mUseTimeLimit->setChecked( entry.useTimeLimit );
-        mDays->setValue( entry.days );
-        mUseSizeLimit->setChecked( entry.useSizeLimit );
-        mPercent->setValue( entry.percent );
-        mLimitReachedAction->setCurrentIndex( entry.actionType );
-    } else {
-        mUseTimeLimit->setChecked( false );
-        mDays->setValue( 7 );
-        mUseSizeLimit->setChecked( true );
-        mPercent->setValue( 10.0 );
-        mLimitReachedAction->setCurrentIndex( 0 );
-    }
-    mDays->setSuffix( ki18np( " day", " days" ) );
-
-    percentChanged( mPercent->value() );
-
-}
-
-void TrashConfigModule::useTypeChanged()
-{
-    mDays->setEnabled( mUseTimeLimit->isChecked() );
-    mSizeWidget->setEnabled( mUseSizeLimit->isChecked() );
-}
-
-void TrashConfigModule::readConfig()
-{
-    KConfig config( "ktrashrc" );
-    mConfigMap.clear();
-
-    const QStringList groups = config.groupList();
-    for ( int i = 0; i < groups.count(); ++i ) {
-        if ( groups[ i ].startsWith( '/' ) ) {
-            const KConfigGroup group = config.group( groups[ i ] );
-
-            ConfigEntry entry;
-            entry.useTimeLimit = group.readEntry( "UseTimeLimit", false );
-            entry.days = group.readEntry( "Days", 7 );
-            entry.useSizeLimit = group.readEntry( "UseSizeLimit", true );
-            entry.percent = group.readEntry( "Percent", 10.0 );
-            entry.actionType = group.readEntry( "LimitReachedAction", 0 );
-            mConfigMap.insert( groups[ i ], entry );
-        }
-    }
-}
-
-void TrashConfigModule::writeConfig()
-{
-    KConfig config( "ktrashrc" );
-
-    // first delete all existing groups
-    const QStringList groups = config.groupList();
-    for ( int i = 0; i < groups.count(); ++i )
-        if ( groups[ i ].startsWith( '/' ) )
-            config.deleteGroup( groups[ i ] );
-
-    QMapIterator<QString, ConfigEntry> it( mConfigMap );
-    while ( it.hasNext() ) {
-        it.next();
-        KConfigGroup group = config.group( it.key() );
-
-        group.writeEntry( "UseTimeLimit", it.value().useTimeLimit );
-        group.writeEntry( "Days", it.value().days );
-        group.writeEntry( "UseSizeLimit", it.value().useSizeLimit );
-        group.writeEntry( "Percent", it.value().percent );
-        group.writeEntry( "LimitReachedAction", it.value().actionType );
-    }
-    config.sync();
-}
-
-void TrashConfigModule::setupGui()
-{
-    QVBoxLayout *layout = new QVBoxLayout( this );
-
-    TrashImpl::TrashDirMap map = mTrashImpl->trashDirectories();
-    if ( map.count() != 1 ) {
-        // If we have multiple trashes, we setup a widget to choose
-        // which trash to configure
-        QListWidget *mountPoints = new QListWidget( this );
-        layout->addWidget( mountPoints );
-
-        QMapIterator<int, QString> it( map );
-        while ( it.hasNext() ) {
-            it.next();
-            DiscSpaceUtil util( it.value() );
-            QListWidgetItem *item = new QListWidgetItem( QIcon( "folder" ), util.mountPoint() );
-            item->setData( Qt::UserRole, it.key() );
-
-            mountPoints->addItem( item );
-        }
-
-        mountPoints->setCurrentRow( 0 );
-
-        connect( mountPoints, SIGNAL( currentItemChanged( QListWidgetItem*, QListWidgetItem* ) ),
-                 this, SLOT( trashChanged( QListWidgetItem* ) ) );
-    } else {
-        mCurrentTrash = map.value( 0 );
-    }
-
-    QHBoxLayout *daysLayout = new QHBoxLayout();
-    layout->addLayout( daysLayout );
-
-    mUseTimeLimit = new QCheckBox( i18n( "Delete files older than:" ), this );
-    mUseTimeLimit->setWhatsThis( xi18nc( "@info:whatsthis",
-                                     "<para>Check this box to allow <b>automatic deletion</b> of files that are older than the value specified. "
-                                     "Leave this disabled to <b>not</b> automatically delete any items after a certain timespan</para>" ) );
-    daysLayout->addWidget( mUseTimeLimit );
-    mDays = new KIntSpinBox( this );
-    
-    mDays->setRange( 1, 365 );
-    mDays->setSingleStep( 1 );
-    mDays->setSuffix( i18np(" day", " days", mDays->value()) );
-    mDays->setWhatsThis( xi18nc( "@info:whatsthis",
-                                     "<para>Set the number of days that files can remain in the trash. "
-                                     "Any files older than this will be automatically deleted.</para>" ) );
-    daysLayout->addWidget( mDays );
-    daysLayout->addStretch();
-
-    QFormLayout *sizeLayout = new QFormLayout();
-    layout->addLayout( sizeLayout );
-
-    mUseSizeLimit = new QCheckBox( i18n( "Limit to maximum size" ), this );
-    mUseSizeLimit->setWhatsThis( xi18nc( "@info:whatsthis",
-                                     "<para>Check this box to limit the trash to the maximum amount of disk space that you specify below. "
-                                     "Otherwise, it will be unlimited.</para>" ) );
-    sizeLayout->addRow( mUseSizeLimit );
-
-    mSizeWidget = new QWidget( this );
-    sizeLayout->addRow( mSizeWidget );
-
-    QFormLayout *sizeWidgetLayout = new QFormLayout( mSizeWidget );
-    sizeWidgetLayout->setMargin( 0 );
-
-    QHBoxLayout *maximumSizeLayout = new QHBoxLayout( );
-
-    mPercent = new QDoubleSpinBox( mSizeWidget );
-    mPercent->setRange( 0.001, 100 );
-    mPercent->setDecimals( 3 );
-    mPercent->setSingleStep( 1 );
-    mPercent->setSuffix( " %" );
-    mPercent->setWhatsThis( xi18nc( "@info:whatsthis",
-                                     "<para>This is the maximum percent of disk space that will be used for the trash.</para>" ) );
-    maximumSizeLayout->addWidget( mPercent );
-
-    mSizeLabel = new QLabel( mSizeWidget );
-    mSizeLabel->setWhatsThis( xi18nc( "@info:whatsthis",
-                                     "<para>This is the calculated amount of disk space that will be allowed for the trash, the maximum.</para>" ) );
-    maximumSizeLayout->addWidget( mSizeLabel );
-
-    sizeWidgetLayout->addRow( i18n( "Maximum size:" ), maximumSizeLayout );
-
-    QLabel *label = new QLabel( i18n( "When limit reached:" ) );
-    sizeWidgetLayout->addRow( label );
-
-    mLimitReachedAction = new QComboBox( mSizeWidget );
-    mLimitReachedAction->addItem( i18n( "Warn Me" ) );
-    mLimitReachedAction->addItem( i18n( "Delete Oldest Files From Trash" ) );
-    mLimitReachedAction->addItem( i18n( "Delete Biggest Files From Trash" ) );
-    mLimitReachedAction->setWhatsThis( xi18nc( "@info:whatsthis",
-                                              "<para>When the size limit is reached, it will prefer to delete the type of files that you specify, first. "
-                                              "If this is set to warn you, it will do so instead of automatically deleting files.</para>" ) );
-    sizeWidgetLayout->addRow( 0, mLimitReachedAction );
-
-    layout->addStretch();
-}
-
-#include "kcmtrash.moc"
diff --git a/trash/kcmtrash.desktop b/trash/kcmtrash.desktop
deleted file mode 100644
index 50186f6..0000000
--- a/trash/kcmtrash.desktop
+++ /dev/null
@@ -1,395 +0,0 @@
-Name=Trash
-Name[ar]=سلة المهملات
-Name[ast]=Papelera
-Name[be@latin]=Śmietnica
-Name[bg]=Кошче
-Name[bn]=আবর্জনা
-Name[bn_IN]=আবর্জনা
-Name[bs]=Smeće
-Name[ca]=Paperera
-Name[ca@valencia]=Paperera
-Name[cs]=Koš
-Name[csb]=Kòsz
-Name[da]=Affald
-Name[de]=Papierkorb
-Name[el]=Κάδος απορριμάτων
-Name[en_GB]=Wastebin
-Name[eo]=Rubujo
-Name[es]=Papelera
-Name[et]=Prügikast
-Name[eu]=Zakarrontzia
-Name[fa]=زباله
-Name[fi]=Roskakori
-Name[fr]=Corbeille
-Name[fy]=Jiskefet
-Name[ga]=Bruscar
-Name[gl]=Lixo
-Name[gu]=કચરાપેટી
-Name[he]=אשפה
-Name[hi]=रद्दी
-Name[hne]=घुरुवा
-Name[hr]=Otpad
-Name[hsb]=Papjernik
-Name[hu]=Kuka
-Name[ia]=Corbe
-Name[id]=Tempat Sampah
-Name[is]=Rusl
-Name[it]=Cestino
-Name[ja]=ごみ箱
-Name[kk]=Өшірілгендер
-Name[km]=ធុង​សំរាម
-Name[kn]=ಕಸಬುಟ್ಟಿ
-Name[ko]=휴지통
-Name[ku]=Çop
-Name[lt]=Šiukšliadėžė
-Name[lv]=Miskaste
-Name[mai]=रद्दी
-Name[mk]=Корпа
-Name[ml]=ചവറ്റുകുട്ട
-Name[mr]=कचरापेटी
-Name[ms]=Sampah
-Name[nb]=Søppelbøtte
-Name[nds]=Affalltünn
-Name[nl]=Prullenbak
-Name[nn]=Papirkorg
-Name[or]=ଆବର୍ଜନା ପାତ୍ର
-Name[pa]=ਰੱਦੀ
-Name[pl]=Kosz
-Name[pt]=Lixo
-Name[pt_BR]=Lixeira
-Name[ro]=Gunoi
-Name[ru]=Корзина
-Name[se]=Ruskalihtti
-Name[si]=ඉවතලන බහලුම
-Name[sk]=Kôš
-Name[sl]=Smeti
-Name[sr]=Смеће
-Name[sr@ijekavian]=Смеће
-Name[sr@ijekavianlatin]=Smeće
-Name[sr@latin]=Smeće
-Name[sv]=Papperskorg
-Name[ta]=அகற்றிடம்
-Name[tg]=Сабад
-Name[th]=ถังขยะ
-Name[tr]=Çöp
-Name[ug]=ئەخلەتخانا
-Name[uk]=Смітник
-Name[vi]=Thùng rác
-Name[wa]=Batch
-Name[x-test]=xxTrashxx
-Name[zh_CN]=回收站
-Name[zh_TW]=資源回收筒
-Comment=This service allows configuration of the trash.
-Comment[ar]=هذه الخدمة تتيح ضبط سلة المهملات
-Comment[ast]=Esti serviciu permite configurar la papelera.
-Comment[be@latin]=Hetaja słužba dazvalaje naładzić śmietnicu.
-Comment[bg]=Това ви позволява да праите настройка на кошчето.
-Comment[bn]=এই পরিসেবাটি আবর্জনা কনফিগার করতে দেয়।
-Comment[bn_IN]=এই পরিসেবা দ্বারা আবর্জনার বাক্স কনফিগার করা যাবে।
-Comment[bs]=Ovaj servis omogućava podešavanje smeća.
-Comment[ca]=Aquest servei permet la configuració de la paperera.
-Comment[ca@valencia]=Este servei permet la configuració de la paperera.
-Comment[cs]=Tato služba umožňuje nastavení koše.
-Comment[csb]=Na ùsłëżnota zezwôlô na kònfigùracëjã kòsza.
-Comment[da]=Denne tjeneste muliggør konfiguration af affald.
-Comment[de]=Mit diesem Dienst können Sie den Papierkorb einrichten.
-Comment[el]=Αυτή η υπηρεσία επιτρέπει τη διαμόρφωση του κάδου απορριμάτων.
-Comment[en_GB]=This service allows configuration of the wastebin.
-Comment[eo]=Ĉi tiu servo permesas agordi la rubujon.
-Comment[es]=Este servicio permite la configuración de la papelera.
-Comment[et]=See teenus võimaldab seadistada prügikasti.
-Comment[eu]=Zerbitzu honen bidez, zakarrontzia konfigura dezakezu.
-Comment[fa]=این خدمت اجازه میدها تا زباله‌دان را پیکربندی کنید.
-Comment[fi]=Tämä palvelu sallii roskakorin asetusten muokkaamisen.
-Comment[fr]=Ce service permet de configurer la corbeille.
-Comment[fy]=Mei dizze tsjint kinne jo it jiskefet ynstelle.
-Comment[ga]=Leis an tseirbhís seo is féidir an bruscar a chumrú.
-Comment[gl]=Este servizo permite configurar o lixo.
-Comment[gu]=આ સેવા કચરાપેટીનું રૂપરેખાંકન કરવા દેશે.
-Comment[he]=שירות זה מאפשר להגדיר את האשפה.
-Comment[hi]=यह सेवा आपको रद्दी की टोकरी को कॉन्फ़िगर करने देता है.
-Comment[hne]=ए सेवा घुरवा ल कानफिगर करे बर देथे.
-Comment[hr]=Ovaj servis dozvoljava konfiguraciju smeća.
-Comment[hsb]=Tuta słužba dowoli připrawjenje papjernika.
-Comment[hu]=A törölt fájlok kezelését lehet itt beállítani.
-Comment[ia]=Iste servicio permitte le configuration de corbe.
-Comment[id]=Layanan ini memungkinkan konfigurasi tempat sampah.
-Comment[is]=Þessi þjónusta leyfir stillingar á ruslafötu.
-Comment[it]=Questo servizio permette di configurare il cestino.
-Comment[ja]=このサービスでごみ箱の設定を変更できます。
-Comment[kk]=Бұл Өшірілгендер қапшығын баптауға мүмкіндік беретін қызмет.
-Comment[km]=សេវា​នេះ​អនុញ្ញាត​ឲ្យ​កំណត់​រចនាសម្ព័ន្ធ​ធុង​សំរាម ។
-Comment[kn]=ಈ ಸೇವೆಯು ಕಸಬುಟ್ಟಿಯ ಸಂರಚನೆಗೆ ಅನುವುಮಾಡಿಕೊಡುತ್ತದೆ.
-Comment[ko]=이 서비스는 휴지통을 설정합니다.
-Comment[ku]=Ev servîs destûrê dide veavakirina xuyakirina Çopê.
-Comment[lt]=Ši tarnyba leidžia konfigūruoti šiukšliadėžę.
-Comment[lv]=Šis serviss ļauj konfigurēt Miskasti.
-Comment[mai]=ई सेवा अहाँकेँ रद्दीक टोकरी केँ विन्यस्त करै देत अछि.
-Comment[mk]=Овој сервис овозможува конфигурација на корпата.
-Comment[ml]=ട്രാഷ് ക്രമീകരിയ്ക്കാന്‍ ഈ സേവനം അനുവദിയ്ക്കുന്നു.
-Comment[mr]=ही सेवा कचरापेटीची संयोजन करण्यास मदत करते.
-Comment[nb]=Med denne tjenesten kan søppelbøtta settes opp.
-Comment[nds]=Mit dissen Deenst laat sik de Affalltünn instellen.
-Comment[nl]=Met deze dienst kunt u de prullenbak instellen.
-Comment[nn]=Denne tenesta lèt deg setja opp papirkorga.
-Comment[or]=ଏହି ସର୍ଭିସ ଆବର୍ଜନା ପାତ୍ରର ବିନ୍ୟାସ ପାଇଁ ଅନୁମତି ଦେଇଥାଏ।
-Comment[pa]=ਇਹ ਸਰਵਿਸ ਰੱਦੀ ਦੀ ਸੰਰਚਨਾ ਵਾਸਤੇ ਹੈ।
-Comment[pl]=Ta usługa umożliwia konfigurację Kosza.
-Comment[pt]=Este serviço permite-lhe configurar o lixo.
-Comment[pt_BR]=Este serviço permite configurar a Lixeira.
-Comment[ro]=Acest serviciu permite configurarea gunoiului.
-Comment[ru]=Здесь вы можете настроить корзину для удаляемых файлов
-Comment[si]=මෙම සේවාව ඉවතලන බඳුන සැකසීමට ඉඩදේ.
-Comment[sk]=Táto služba umožňuje nastavenie koša.
-Comment[sl]=Ta storitev omogoča nastavitev Smeti.
-Comment[sr]=Овај сервис омогућава подешавање смећа.
-Comment[sr@ijekavian]=Овај сервис омогућава подешавање смећа.
-Comment[sr@ijekavianlatin]=Ovaj servis omogućava podešavanje smeća.
-Comment[sr@latin]=Ovaj servis omogućava podešavanje smeća.
-Comment[sv]=Den här tjänsten låter dig anpassa papperskorgen.
-Comment[ta]=அகற்றிடத்தை வடிவமைக்க அச்சேவை பயன்படுகிறது.
-Comment[tg]=Ин хидмат барои танзимоти сабад иҷозат медиҳад
-Comment[th]=บริการนี้ใช้ในการปรับแต่งค่าถังขยะ
-Comment[tr]=Bu servis çöpü yapılandırmanızı sağlar.
-Comment[ug]=بۇ مۇلازىمەت ئەخلەتخانا سەپلىشىڭىزگە يول قويىدۇ.
-Comment[uk]=Ця служба надає змогу налаштувати смітник.
-Comment[vi]=Dịch vụ này cung cấp cấu hình cho thùng rác.
-Comment[wa]=Ci siervice permet l' apontiaedje do batch.
-Comment[x-test]=xxThis service allows configuration of the trash.xx
-Comment[zh_CN]=此服务允许您配置回收站。
-Comment[zh_TW]=此服務允許設定資源回收筒的檢視。
-
-[Desktop Entry]
-Icon=user-trash
-Type=Service
-X-KDE-ServiceTypes=KCModule
-Exec=kcmshell5 kcmtrash
-
-X-KDE-Library=kcm_trash
-X-KDE-PluginKeyword=trash
-X-KDE-ParentApp=kcontrol
-
-Name=Trash
-Name[ar]=سلة المهملات
-Name[ast]=Papelera
-Name[be@latin]=Śmietnica
-Name[bg]=Кошче
-Name[bn]=আবর্জনা
-Name[bn_IN]=আবর্জনা
-Name[bs]=Smeće
-Name[ca]=Paperera
-Name[ca@valencia]=Paperera
-Name[cs]=Koš
-Name[csb]=Kòsz
-Name[da]=Affald
-Name[de]=Papierkorb
-Name[el]=Κάδος απορριμάτων
-Name[en_GB]=Wastebin
-Name[eo]=Rubujo
-Name[es]=Papelera
-Name[et]=Prügikast
-Name[eu]=Zakarrontzia
-Name[fa]=زباله
-Name[fi]=Roskakori
-Name[fr]=Corbeille
-Name[fy]=Jiskefet
-Name[ga]=Bruscar
-Name[gl]=Lixo
-Name[gu]=કચરાપેટી
-Name[he]=אשפה
-Name[hi]=रद्दी
-Name[hne]=घुरुवा
-Name[hr]=Otpad
-Name[hsb]=Papjernik
-Name[hu]=Kuka
-Name[ia]=Corbe
-Name[id]=Tempat Sampah
-Name[is]=Rusl
-Name[it]=Cestino
-Name[ja]=ごみ箱
-Name[kk]=Өшірілгендер
-Name[km]=ធុង​សំរាម
-Name[kn]=ಕಸಬುಟ್ಟಿ
-Name[ko]=휴지통
-Name[ku]=Çop
-Name[lt]=Šiukšliadėžė
-Name[lv]=Miskaste
-Name[mai]=रद्दी
-Name[mk]=Корпа
-Name[ml]=ചവറ്റുകുട്ട
-Name[mr]=कचरापेटी
-Name[ms]=Sampah
-Name[nb]=Søppelbøtte
-Name[nds]=Affalltünn
-Name[nl]=Prullenbak
-Name[nn]=Papirkorg
-Name[or]=ଆବର୍ଜନା ପାତ୍ର
-Name[pa]=ਰੱਦੀ
-Name[pl]=Kosz
-Name[pt]=Lixo
-Name[pt_BR]=Lixeira
-Name[ro]=Gunoi
-Name[ru]=Корзина
-Name[se]=Ruskalihtti
-Name[si]=ඉවතලන බහලුම
-Name[sk]=Kôš
-Name[sl]=Smeti
-Name[sr]=Смеће
-Name[sr@ijekavian]=Смеће
-Name[sr@ijekavianlatin]=Smeće
-Name[sr@latin]=Smeće
-Name[sv]=Papperskorg
-Name[ta]=அகற்றிடம்
-Name[tg]=Сабад
-Name[th]=ถังขยะ
-Name[tr]=Çöp
-Name[ug]=ئەخلەتخانا
-Name[uk]=Смітник
-Name[vi]=Thùng rác
-Name[wa]=Batch
-Name[x-test]=xxTrashxx
-Name[zh_CN]=回收站
-Name[zh_TW]=資源回收筒
-Comment=Configure trash settings
-Comment[ar]=اضبط إعدادات سلة المهملات
-Comment[ast]=Configuración de les preferencies de la papelera
-Comment[be@latin]=Naładź śmietnicu
-Comment[bg]=Настройване на кошчето
-Comment[bn]=আবর্জনা সেটিংস কনফিগার করুন
-Comment[bn_IN]=আবর্জনার বাক্স সংক্রান্ত বৈশিষ্ট্য কনফিগার করুন
-Comment[bs]=Podešavanje postavki smeća
-Comment[ca]=Configura l'arranjament de la paperera
-Comment[ca@valencia]=Configura l'arranjament de la paperera
-Comment[cs]=Nastavení koše
-Comment[csb]=Kònfigùracëjô nastôwów kòsza
-Comment[da]=Indstillinger for affald
-Comment[de]=Papierkorb-Einstellungen festlegen
-Comment[el]=Διαμόρφωση ρυθμίσεων κάδου απορριμάτων
-Comment[en_GB]=Configure wastebin settings
-Comment[eo]=Agordi rubujon
-Comment[es]=Configurar las preferencias de la papelera
-Comment[et]=Prügikasti seadistamine
-Comment[eu]=Zakarrontzi-ezarpenak konfiguratzea
-Comment[fa]=پیکربندی تنظیمات زباله‌دان
-Comment[fi]=Roskakorin asetukset
-Comment[fr]=Configurer les réglages de la corbeille
-Comment[fy]=Jiskefetkofiguraasje ynstelle
-Comment[ga]=Cumraigh socruithe an bhruscair
-Comment[gl]=Configurar as opcións do lixo
-Comment[gu]=કચરાપેટી ગોઠવણીઓ રૂપરેખાંકિત કરો
-Comment[he]=הגדרת הגדרות האשפה
-Comment[hi]=रद्दी की टोकरी का विन्यास कॉन्फ़िगर करें
-Comment[hne]=कचरापेटी सेटिंग कान्फिगर करव 
-Comment[hr]=Konfiguriranje postavki otpada
-Comment[hsb]=Nastajenja papjernika připrawić
-Comment[hu]=A törölt fájlok beállításai
-Comment[ia]=Configura preferentias de corbe
-Comment[id]=Atur pengaturan tempat sampah
-Comment[is]=Stillingar ruslafötu
-Comment[it]=Configura le impostazioni del cestino
-Comment[ja]=ごみ箱のオプション設定
-Comment[kk]=Өшірілгендердің параметрлерін баптау
-Comment[km]=កំណត់​រចនាសម្ព័ន្ធ​ការ​កំណត់ធុង​សំរាម
-Comment[kn]=ಕಸಬುಟ್ಟಿ ಸಂಯೋಜನೆಗಳನ್ನು ಸಂರಚಿಸು
-Comment[ko]=휴지통 설정
-Comment[ku]=Mîhengên çopê ava bike
-Comment[lt]=Konfigūruoti šiukšliadėžės nustatymus
-Comment[lv]=Konfigurēt miskastes iestatījumus
-Comment[mai]=ट्रैशक सेटिंग विन्यस्त करू
-Comment[mk]=Конфигурирајте ги поставувањата за корпата
-Comment[ml]=ട്രാഷ് സജ്ജീകരണങ്ങള്‍ ക്രമീകരിക്കുക
-Comment[mr]=कचरापेटी संयोजना संयोजीत करा
-Comment[nb]=Tilpass søppelinnstillinger
-Comment[nds]=De Affalltünn instellen
-Comment[nl]=Prullenbakconfiguratie instellen
-Comment[nn]=Set opp innstillingar for papirkorga
-Comment[or]=ଆବର୍ଜନା ପାତ୍ର ସଂରଚନାକୁ ବିନ୍ୟାସ କରନ୍ତୁ 
-Comment[pa]=ਰੱਦੀ ਸੈਟਿੰਗ ਸੰਰਚਨਾ
-Comment[pl]=Konfiguracja Kosza
-Comment[pt]=Configurar as opções do lixo
-Comment[pt_BR]=Configurações da Lixeira
-Comment[ro]=Configurează setările gunoiului
-Comment[ru]=Настройка корзины
-Comment[se]=Heivet ruskalihtteheivehusat
-Comment[si]=ඉවතලන බඳුන සකසන්න
-Comment[sk]=Nastavenie koša
-Comment[sl]=Nastavi Smeti
-Comment[sr]=Подешавање поставки смећа
-Comment[sr@ijekavian]=Подешавање поставки смећа
-Comment[sr@ijekavianlatin]=Podešavanje postavki smeća
-Comment[sr@latin]=Podešavanje postavki smeća
-Comment[sv]=Anpassa papperskorgens inställningar
-Comment[ta]=அகற்றிட அமைப்பை வடிவமைக்க
-Comment[tg]=Танзимоти сабад
-Comment[th]=ปรับแต่งการตั้งค่าถังขยะ
-Comment[tr]=Çöp ayarlarını yapılandır
-Comment[ug]=ئەخلەتخانا تەڭشەك سەپلىمىسى
-Comment[uk]=Налаштування параметрів смітника
-Comment[vi]=Cấu hình thiết lập thùng rác
-Comment[wa]=Apontyî les tchuzes do batch
-Comment[x-test]=xxConfigure trash settingsxx
-Comment[zh_CN]=配置回收站设置
-Comment[zh_TW]=設定資源回收筒
-X-KDE-Keywords=trash
-X-KDE-Keywords[ast]=Papelera
-X-KDE-Keywords[bg]=trash,кошче
-X-KDE-Keywords[bn]=আবর্জনা
-X-KDE-Keywords[bs]=smeće
-X-KDE-Keywords[ca]=paperera
-X-KDE-Keywords[ca@valencia]=paperera
-X-KDE-Keywords[cs]=koš
-X-KDE-Keywords[da]=affald
-X-KDE-Keywords[de]=Papierkorb
-X-KDE-Keywords[el]=Κάδος απορριμάτων
-X-KDE-Keywords[en_GB]=Wastebin
-X-KDE-Keywords[eo]=rubujo
-X-KDE-Keywords[es]=papelera
-X-KDE-Keywords[et]=prügikast
-X-KDE-Keywords[eu]=zakarrontzia
-X-KDE-Keywords[fa]=زباله‌دان
-X-KDE-Keywords[fi]=roskakori
-X-KDE-Keywords[fr]=corbeille
-X-KDE-Keywords[ga]=bruscar
-X-KDE-Keywords[gl]=lixo
-X-KDE-Keywords[gu]=કચરાપેટી
-X-KDE-Keywords[he]=אשפה
-X-KDE-Keywords[hi]=रद्दी
-X-KDE-Keywords[hu]=kuka
-X-KDE-Keywords[ia]=corbe
-X-KDE-Keywords[id]=tempat sampah
-X-KDE-Keywords[is]=rusl
-X-KDE-Keywords[it]=cestino
-X-KDE-Keywords[ja]=ごみ箱
-X-KDE-Keywords[kk]=trash
-X-KDE-Keywords[km]=ធុង​សំរាម
-X-KDE-Keywords[ko]=휴지통
-X-KDE-Keywords[lt]=šiukšlės
-X-KDE-Keywords[lv]=miskaste
-X-KDE-Keywords[mr]=कचरापेटी
-X-KDE-Keywords[nb]=papirkurv
-X-KDE-Keywords[nds]=Affalltünn
-X-KDE-Keywords[nl]=prullenbak
-X-KDE-Keywords[nn]=papirkorg
-X-KDE-Keywords[pa]=ਰੱਦੀ
-X-KDE-Keywords[pl]=kosz
-X-KDE-Keywords[pt]=lixo
-X-KDE-Keywords[pt_BR]=lixeira
-X-KDE-Keywords[ro]=gunoi
-X-KDE-Keywords[ru]=корзина,trash
-X-KDE-Keywords[sk]=kôš
-X-KDE-Keywords[sl]=smeti
-X-KDE-Keywords[sr]=trash,смеће
-X-KDE-Keywords[sr@ijekavian]=trash,смеће
-X-KDE-Keywords[sr@ijekavianlatin]=trash,smeće
-X-KDE-Keywords[sr@latin]=trash,smeće
-X-KDE-Keywords[sv]=papperskorg
-X-KDE-Keywords[tg]=сабад
-X-KDE-Keywords[tr]=çöp
-X-KDE-Keywords[ug]=ئەخلەتخانا
-X-KDE-Keywords[uk]=trash,смітник
-X-KDE-Keywords[vi]=thùng rác
-X-KDE-Keywords[wa]=batch
-X-KDE-Keywords[x-test]=xxtrashxx
-X-KDE-Keywords[zh_CN]=trash,回收站
-X-KDE-Keywords[zh_TW]=trash
-X-DocPath=kcontrol/trash/index.html
diff --git a/trash/kcmtrash.h b/trash/kcmtrash.h
deleted file mode 100644
index 34954d5..0000000
--- a/trash/kcmtrash.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2008 by Tobias Koenig <tokoe@kde.org>                   *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA            *
- ***************************************************************************/
-
-#ifndef KCMTRASH_H
-#define KCMTRASH_H
-
-#include <kcmodule.h>
-
-class QCheckBox;
-class QComboBox;
-class QDoubleSpinBox;
-class QFrame;
-class QLabel;
-class QListWidgetItem;
-class KIntSpinBox;
-class TrashImpl;
-
-/**
- * @brief Allow to configure the trash.
- */
-class TrashConfigModule : public KCModule
-{
-    Q_OBJECT
-
-    public:
-        TrashConfigModule( QWidget* parent, const QVariantList& args );
-        virtual ~TrashConfigModule();
-
-        virtual void save();
-        virtual void defaults();
-
-    private Q_SLOTS:
-        void percentChanged( double );
-        void trashChanged( QListWidgetItem* );
-        void trashChanged( int );
-        void useTypeChanged();
-
-    private:
-        void readConfig();
-        void writeConfig();
-        void setupGui();
-
-        QCheckBox *mUseTimeLimit;
-        KIntSpinBox *mDays;
-        QCheckBox *mUseSizeLimit;
-        QWidget *mSizeWidget;
-        QDoubleSpinBox *mPercent;
-        QLabel *mSizeLabel;
-        QComboBox *mLimitReachedAction;
-
-        TrashImpl *mTrashImpl;
-        QString mCurrentTrash;
-    bool trashInitialize;
-        typedef struct {
-            bool useTimeLimit;
-            int days;
-            bool useSizeLimit;
-            double percent;
-            int actionType;
-        } ConfigEntry;
-
-        typedef QMap<QString, ConfigEntry> ConfigMap;
-        ConfigMap mConfigMap;
-};
-
-#endif // KCMTRASH_H
diff --git a/trash/kinterprocesslock.cpp b/trash/kinterprocesslock.cpp
deleted file mode 100644
index bc68fe6..0000000
--- a/trash/kinterprocesslock.cpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
-    This file is part of the KDE
-
-    Copyright (C) 2009 Tobias Koenig (tokoe@kde.org)
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU General Public License
-    version 2 as published by the Free Software Foundation.
-
-    This software is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this library; see the file COPYING. If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#include "kinterprocesslock.h"
-
-#include <QtCore/QEventLoop>
-#include <QtDBus/QDBusConnectionInterface>
-
-#include <QtCore/QDebug>
-
-class KInterProcessLockPrivate
-{
-    Q_DECLARE_PUBLIC(KInterProcessLock)
-     KInterProcessLock *q_ptr;
-    public:
-        KInterProcessLockPrivate(const QString &resource, KInterProcessLock *parent)
-            : m_resource(resource), m_parent(parent)
-        {
-            m_serviceName = QString::fromLatin1("org.kde.private.lock-%1").arg(m_resource);
-
-            m_parent->connect(QDBusConnection::sessionBus().interface(), SIGNAL(serviceRegistered(const QString&)),
-                              m_parent, SLOT(_k_serviceRegistered(const QString&)));
-        }
-
-        ~KInterProcessLockPrivate()
-        {
-        }
-
-        void _k_serviceRegistered(const QString &service)
-        {
-            if (service == m_serviceName)
-                emit m_parent->lockGranted(m_parent);
-        }
-
-        QString m_resource;
-        QString m_serviceName;
-        KInterProcessLock *m_parent;
-};
-
-KInterProcessLock::KInterProcessLock(const QString &resource)
-    : d_ptr(new KInterProcessLockPrivate(resource, this))
-{
-    d_ptr->q_ptr = this;
-}
-
-KInterProcessLock::~KInterProcessLock()
-{
-    delete d_ptr;
-}
-
-QString KInterProcessLock::resource() const
-{
-    return d_ptr->m_resource;
-}
-
-void KInterProcessLock::lock()
-{
-    QDBusConnection::sessionBus().interface()->registerService(d_ptr->m_serviceName,
-                                                               QDBusConnectionInterface::QueueService,
-                                                               QDBusConnectionInterface::DontAllowReplacement);
-}
-
-void KInterProcessLock::unlock()
-{
-    QDBusConnection::sessionBus().interface()->unregisterService(d_ptr->m_serviceName);
-}
-
-void KInterProcessLock::waitForLockGranted()
-{
-    QEventLoop loop;
-    connect(this, SIGNAL(lockGranted(KInterProcessLock*)), &loop, SLOT(quit()));
-    loop.exec();
-}
-
-#include "moc_kinterprocesslock.cpp"
diff --git a/trash/kinterprocesslock.h b/trash/kinterprocesslock.h
deleted file mode 100644
index ee34657..0000000
--- a/trash/kinterprocesslock.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
-    This file is part of the KDE
-
-    Copyright (C) 2009 Tobias Koenig (tokoe@kde.org)
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU General Public License
-    version 2 as published by the Free Software Foundation.
-
-    This software is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this library; see the file COPYING. If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KINTERPROCESSLOCK_H
-#define KINTERPROCESSLOCK_H
-
-#include <QtCore/QObject>
-
-class KInterProcessLockPrivate;
-
-/**
- * @short A class for serializing access to a resource that is shared between multiple processes.
- *
- * This class can be used to serialize access to a resource between
- * multiple processes. Instead of using lock files, which could
- * become stale easily, the registration of dummy dbus services is used
- * to allow only one process at a time to access the resource.
- *
- * Example:
- *
- * @code
- *
- * KInterProcessLock *lock = new KInterProcessLock("myresource");
- * connect(lock, SIGNAL(lockGranted(KInterProcessLock *)),
- *               this, SLOT(doCriticalTask(KInterProcessLock *)));
- * lock->lock();
- *
- * ...
- *
- * ... ::doCriticalTask(KInterProcessLock *lock)
- * {
- *    // change common resource
- *
- *    lock->unlock();
- * }
- *
- * @endcode
- *
- * @author Tobias Koenig <tokoe@kde.org>
- */
-class KInterProcessLock : public QObject
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(KInterProcessLock)
-
-    public:
-        /**
-         * Creates a new inter process lock object.
-         *
-         * @param resource The identifier of the resource that shall be locked.
-         *                 This identifier can be any string, however it must be unique for
-         *                 the resource and every client that wants to access the resource must
-         *                 know it.
-         */
-        KInterProcessLock(const QString &resource);
-
-        /**
-         * Destroys the inter process lock object.
-         */
-        ~KInterProcessLock();
-
-        /**
-         * Returns the identifier of the resource the lock is set on.
-         */
-        QString resource() const;
-
-        /**
-         * Requests the lock.
-         *
-         * The lock is granted as soon as the lockGranted() signal is emitted.
-         */
-        void lock();
-
-        /**
-         * Releases the lock.
-         *
-         * @note This method should be called as soon as the critical area is left
-         *       in your code path and the lock is no longer needed.
-         */
-        void unlock();
-
-        /**
-         * Waits for the granting of a lock by starting an internal event loop.
-         */
-        void waitForLockGranted();
-
-    Q_SIGNALS:
-        /**
-         * This signal is emitted when the requested lock has been granted.
-         *
-         * @param lock The lock that has been granted.
-         */
-        void lockGranted(KInterProcessLock *lock);
-
-    private:
-        KInterProcessLockPrivate * const d_ptr;
-
-        Q_PRIVATE_SLOT(d_func(), void _k_serviceRegistered(const QString&))
-};
-
-#endif
diff --git a/trash/kio_trash.cpp b/trash/kio_trash.cpp
deleted file mode 100644
index 967a583..0000000
--- a/trash/kio_trash.cpp
+++ /dev/null
@@ -1,597 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#define QT_NO_CAST_FROM_ASCII
-
-#include "kio_trash.h"
-#include <kio/job.h>
-#include <kio/jobuidelegateextension.h>
-
-#include <qdebug.h>
-#include <klocale.h>
-#include <kde_file.h>
-#include <kcomponentdata.h>
-#include <kmimetype.h>
-
-#include <QCoreApplication>
-#include <QDataStream>
-#include <QFile>
-#include <QEventLoop>
-
-#include <time.h>
-#include <pwd.h>
-#include <grp.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stdlib.h>
-extern "C" {
-    int Q_DECL_EXPORT kdemain( int argc, char **argv )
-    {
-        // necessary to use other kio slaves
-        KComponentData componentData("kio_trash" );
-        QCoreApplication app(argc, argv);
-
-        KIO::setDefaultJobUiDelegateExtension(0);
-        // start the slave
-        TrashProtocol slave( argv[1], argv[2], argv[3] );
-        slave.dispatchLoop();
-        return 0;
-    }
-}
-
-#define INIT_IMPL \
-    if ( !impl.init() ) { \
-        error( impl.lastErrorCode(), impl.lastErrorMessage() ); \
-        return; \
-    }
-
-TrashProtocol::TrashProtocol( const QByteArray& protocol, const QByteArray &pool, const QByteArray &app)
-    : SlaveBase(protocol, pool, app )
-{
-    struct passwd *user = getpwuid( getuid() );
-    if ( user )
-        m_userName = QString::fromLatin1(user->pw_name);
-    struct group *grp = getgrgid( getgid() );
-    if ( grp )
-        m_groupName = QString::fromLatin1(grp->gr_name);
-}
-
-TrashProtocol::~TrashProtocol()
-{
-}
-
-void TrashProtocol::enterLoop()
-{
-    QEventLoop eventLoop;
-    connect(this, SIGNAL(leaveModality()),
-        &eventLoop, SLOT(quit()));
-    eventLoop.exec(QEventLoop::ExcludeUserInputEvents);
-}
-
-void TrashProtocol::restore( const QUrl& trashURL )
-{
-    int trashId;
-    QString fileId, relativePath;
-    bool ok = TrashImpl::parseURL( trashURL, trashId, fileId, relativePath );
-    if ( !ok ) {
-        error( KIO::ERR_SLAVE_DEFINED, i18n( "Malformed URL %1", trashURL.toString() ) );
-        return;
-    }
-    TrashedFileInfo info;
-    ok = impl.infoForFile( trashId, fileId, info );
-    if ( !ok ) {
-        error( impl.lastErrorCode(), impl.lastErrorMessage() );
-        return;
-    }
-    QUrl dest = QUrl::fromLocalFile( info.origPath );
-    if ( !relativePath.isEmpty() ) {
-        dest = dest.adjusted(QUrl::StripTrailingSlash);
-    // (u.path() + '/' + txt) '/' is unable to concate ?
-        dest.setPath(dest.path()+QString::fromLatin1("/")+relativePath);
-    }
-    
-    // Check that the destination directory exists, to improve the error code in case it doesn't.
-    const QString destDir = dest.adjusted(QUrl::RemoveFilename).path();
-    KDE_struct_stat buff;
-
-    if ( KDE_lstat( QFile::encodeName( destDir ), &buff ) == -1 ) {
-        error( KIO::ERR_SLAVE_DEFINED,
-               i18n( "The directory %1 does not exist anymore, so it is not possible to restore this item to its original location. "
-                     "You can either recreate that directory and use the restore operation again, or drag the item anywhere else to restore it.", destDir ) );
-        return;
-    }
-
-    copyOrMove( trashURL, dest, false /*overwrite*/, Move );
-}
-
-void TrashProtocol::rename( const QUrl &oldURL, const QUrl &newURL, KIO::JobFlags flags )
-{
-    INIT_IMPL;
-
-    qDebug()<<"TrashProtocol::rename(): old="<<oldURL<<" new="<<newURL<<" overwrite=" << (flags & KIO::Overwrite);
-
-    if (oldURL.scheme() == QLatin1String("trash") && newURL.scheme() == QLatin1String("trash")) {
-        error( KIO::ERR_CANNOT_RENAME, oldURL.toString() );
-        return;
-    }
-
-    copyOrMove( oldURL, newURL, (flags & KIO::Overwrite), Move );
-}
-
-void TrashProtocol::copy( const QUrl &src, const QUrl &dest, int /*permissions*/, KIO::JobFlags flags )
-{
-    INIT_IMPL;
-
-    qDebug()<<"TrashProtocol::copy(): " << src << " " << dest;
-
-    if (src.scheme() == QLatin1String("trash") && dest.scheme() == QLatin1String("trash")) {
-        error( KIO::ERR_UNSUPPORTED_ACTION, i18n( "This file is already in the trash bin." ) );
-        return;
-    }
-
-    copyOrMove( src, dest, (flags & KIO::Overwrite), Copy );
-}
-
-void TrashProtocol::copyOrMove( const QUrl &src, const QUrl &dest, bool overwrite, CopyOrMove action )
-{
-    if (src.scheme() == QLatin1String("trash") && dest.isLocalFile()) {
-        // Extracting (e.g. via dnd). Ignore original location stored in info file.
-        int trashId;
-        QString fileId, relativePath;
-        bool ok = TrashImpl::parseURL( src, trashId, fileId, relativePath );
-        if ( !ok ) {
-            error( KIO::ERR_SLAVE_DEFINED, i18n( "Malformed URL %1", src.toString() ) );
-            return;
-        }
-        const QString destPath = dest.path();
-        if ( QFile::exists( destPath ) ) {
-            if ( overwrite ) {
-                ok = QFile::remove( destPath );
-                Q_ASSERT( ok ); // ### TODO
-            } else {
-                error( KIO::ERR_FILE_ALREADY_EXIST, destPath );
-                return;
-            }
-        }
-
-        if ( action == Move ) {
-            qDebug() << "calling moveFromTrash(" << destPath << " " << trashId << " " << fileId << ")";
-            ok = impl.moveFromTrash( destPath, trashId, fileId, relativePath );
-        } else { // Copy
-            qDebug() << "calling copyFromTrash(" << destPath << " " << trashId << " " << fileId << ")";
-            ok = impl.copyFromTrash( destPath, trashId, fileId, relativePath );
-        }
-        if ( !ok ) {
-            error( impl.lastErrorCode(), impl.lastErrorMessage() );
-        } else {
-            if ( action == Move && relativePath.isEmpty() )
-                (void)impl.deleteInfo( trashId, fileId );
-            finished();
-        }
-        return;
-    } else if (src.isLocalFile() && dest.scheme() == QLatin1String("trash")) {
-        QString dir = dest.adjusted(QUrl::RemoveFilename).path();
-        qDebug() << "trashing a file to " << dir << src << dest;
- 
-        // Trashing a file
-        // We detect the case where this isn't normal trashing, but
-        // e.g. if kwrite tries to save (moving tempfile over destination)
-        if ( dir.length() <= 1 && src.fileName() == dest.fileName() ) // new toplevel entry
-        {
-            const QString srcPath = src.path();
-            // In theory we should use TrashImpl::parseURL to give the right filename to createInfo,
-            // in case the trash URL didn't contain the same filename as srcPath.
-            // But this can only happen with copyAs/moveAs, not available in the GUI
-            // for the trash (New/... or Rename from iconview/listview).
-            int trashId;
-            QString fileId;
-            if ( !impl.createInfo( srcPath, trashId, fileId ) ) {
-                error( impl.lastErrorCode(), impl.lastErrorMessage() );
-            } else {
-                bool ok;
-                if ( action == Move ) {
-                    qDebug() << "calling moveToTrash(" << srcPath << " " << trashId << " " << fileId << ")";
-                    ok = impl.moveToTrash( srcPath, trashId, fileId );
-                } else { // Copy
-                    qDebug() << "calling copyToTrash(" << srcPath << " " << trashId << " " << fileId << ")";
-                    ok = impl.copyToTrash( srcPath, trashId, fileId );
-                }
-                if ( !ok ) {
-                    (void)impl.deleteInfo( trashId, fileId );
-                    error( impl.lastErrorCode(), impl.lastErrorMessage() );
-                } else {
-                    // Inform caller of the final URL. Used by konq_undo.
-                    const QUrl url = impl.makeURL( trashId, fileId, QString() );
-                    setMetaData(QString::fromLatin1("trashURL-") + srcPath, url.url());
-                    finished();
-                }
-            }
-            return;
-        } else {
-            qDebug() << "returning KIO::ERR_ACCESS_DENIED, it's not allowed to add a file to an existing trash directory";
-            // It's not allowed to add a file to an existing trash directory.
-            error( KIO::ERR_ACCESS_DENIED, dest.toString() );
-            return;
-        }
-    } else {
-        error(KIO::ERR_UNSUPPORTED_ACTION, i18n("Internal error in copyOrMove, should never happen"));
-    }
-}
-
-void TrashProtocol::createTopLevelDirEntry(KIO::UDSEntry& entry)
-{
-    entry.clear();
-    entry.insert( KIO::UDSEntry::UDS_NAME, QString::fromLatin1("."));
-    entry.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR);
-    entry.insert( KIO::UDSEntry::UDS_ACCESS, 0700);
-    entry.insert( KIO::UDSEntry::UDS_MIME_TYPE, QString::fromLatin1("inode/directory"));
-    entry.insert( KIO::UDSEntry::UDS_USER, m_userName);
-    entry.insert( KIO::UDSEntry::UDS_GROUP, m_groupName);
-}
-
-void TrashProtocol::stat(const QUrl& url)
-{
-    INIT_IMPL;
-    const QString path = url.path();
-    if (path.isEmpty() || path == QLatin1String("/")) {
-        // The root is "virtual" - it's not a single physical directory
-        KIO::UDSEntry entry;
-        createTopLevelDirEntry( entry );
-        statEntry( entry );
-        finished();
-    } else {
-        int trashId;
-        QString fileId, relativePath;
-
-        bool ok = TrashImpl::parseURL( url, trashId, fileId, relativePath );
-
-        if ( !ok ) {
-            // ######## do we still need this?
-            qDebug() << url << " looks fishy, returning does-not-exist";
-            // A URL like trash:/file simply means that CopyJob is trying to see if
-            // the destination exists already (it made up the URL by itself).
-            error( KIO::ERR_DOES_NOT_EXIST, url.toString() );
-            //error( KIO::ERR_SLAVE_DEFINED, i18n( "Malformed URL %1" ).arg( url.toString() ) );
-            return;
-        }
-
-        qDebug() << "parsed" << url << "got" << trashId << fileId << relativePath;
-
-        const QString filePath = impl.physicalPath( trashId, fileId, relativePath );
-        if ( filePath.isEmpty() ) {
-            error( impl.lastErrorCode(), impl.lastErrorMessage() );
-            return;
-        }
-
-        // For a toplevel file, use the fileId as display name (to hide the trashId)
-        // For a file in a subdir, use the fileName as is.
-        QString fileDisplayName = relativePath.isEmpty() ? fileId : url.fileName();
-
-        QUrl fileURL;
-        if ( url.path().length() > 1 ) {
-            fileURL = url;
-        }
-
-        KIO::UDSEntry entry;
-        TrashedFileInfo info;
-        ok = impl.infoForFile( trashId, fileId, info );
-        if ( ok )
-            ok = createUDSEntry( filePath, fileDisplayName, fileURL.fileName(), entry, info );
-
-        if ( !ok ) {
-            error( KIO::ERR_COULD_NOT_STAT, url.toString() );
-            return;
-        }
-
-        statEntry( entry );
-        finished();
-    }
-}
-
-void TrashProtocol::del( const QUrl &url, bool /*isfile*/ )
-{
-    INIT_IMPL;
-    int trashId;
-    QString fileId, relativePath;
-
-    bool ok = TrashImpl::parseURL( url, trashId, fileId, relativePath );
-    if ( !ok ) {
-        error( KIO::ERR_SLAVE_DEFINED, i18n( "Malformed URL %1", url.toString() ) );
-        return;
-    }
-
-    ok = relativePath.isEmpty();
-    if ( !ok ) {
-        error( KIO::ERR_ACCESS_DENIED, url.toString() );
-        return;
-    }
-
-    ok = impl.del(trashId, fileId);
-    if ( !ok ) {
-        error( impl.lastErrorCode(), impl.lastErrorMessage() );
-        return;
-    }
-
-    finished();
-}
-
-void TrashProtocol::listDir(const QUrl& url)
-{
-    INIT_IMPL;
-    qDebug() << "listdir: " << url;
-    if ( url.path() == QLatin1String("/") ) {
-        listRoot();
-        return;
-    }
-    int trashId;
-    QString fileId;
-    QString relativePath;
-    bool ok = TrashImpl::parseURL( url, trashId, fileId, relativePath );
-    if ( !ok ) {
-        error( KIO::ERR_SLAVE_DEFINED, i18n( "Malformed URL %1", url.toString() ) );
-        return;
-    }
-    //was: const QString physicalPath = impl.physicalPath( trashId, fileId, relativePath );
-
-    // Get info for deleted directory - the date of deletion and orig path will be used
-    // for all the items in it, and we need the physicalPath.
-    TrashedFileInfo info;
-    ok = impl.infoForFile( trashId, fileId, info );
-    if ( !ok || info.physicalPath.isEmpty() ) {
-        error( impl.lastErrorCode(), impl.lastErrorMessage() );
-        return;
-    }
-    if ( !relativePath.isEmpty() ) {
-        info.physicalPath += QLatin1Char('/');
-        info.physicalPath += relativePath;
-    }
-
-    // List subdir. Can't use kio_file here since we provide our own info...
-    qDebug() << "listing " << info.physicalPath;
-    const QStringList entryNames = impl.listDir( info.physicalPath );
-    totalSize( entryNames.count() );
-    KIO::UDSEntry entry;
-    for ( QStringList::const_iterator entryIt = entryNames.begin(), entryEnd = entryNames.end();
-          entryIt != entryEnd ; ++entryIt )
-    {
-        const QString fileName = *entryIt;
-        if (fileName == QLatin1String(".."))
-            continue;
-        const QString filePath = info.physicalPath + QLatin1Char('/') + fileName;
-        // shouldn't be necessary
-        //const QString url = TrashImpl::makeURL( trashId, fileId, relativePath + '/' + fileName );
-        entry.clear();
-        TrashedFileInfo infoForItem( info );
-        infoForItem.origPath += QLatin1Char('/');
-        infoForItem.origPath += fileName;
-        if (createUDSEntry(filePath, fileName, fileName, entry, infoForItem)) {
-            listEntry( entry );
-        }
-    }
-    entry.clear();
-    finished();
-}
-
-bool TrashProtocol::createUDSEntry( const QString& physicalPath, const QString& displayFileName, const QString& internalFileName, KIO::UDSEntry& entry, const TrashedFileInfo& info )
-{
-    QByteArray physicalPath_c = QFile::encodeName( physicalPath );
-    KDE_struct_stat buff;
-    if ( KDE_lstat( physicalPath_c, &buff ) == -1 ) {
-        qWarning() << "couldn't stat " << physicalPath ;
-        return false;
-    }
-    if (S_ISLNK(buff.st_mode)) {
-        char buffer2[ 1000 ];
-        int n = readlink( physicalPath_c, buffer2, 999 );
-        if ( n != -1 ) {
-            buffer2[ n ] = 0;
-        }
-
-        entry.insert( KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName( buffer2 ) );
-        // Follow symlink
-        // That makes sense in kio_file, but not in the trash, especially for the size
-        // #136876
-#if 0
-        if ( KDE_stat( physicalPath_c, &buff ) == -1 ) {
-            // It is a link pointing to nowhere
-            buff.st_mode = S_IFLNK | S_IRWXU | S_IRWXG | S_IRWXO;
-            buff.st_mtime = 0;
-            buff.st_atime = 0;
-            buff.st_size = 0;
-        }
-#endif
-    }
-
-    mode_t type = buff.st_mode & S_IFMT; // extract file type
-    mode_t access = buff.st_mode & 07777; // extract permissions
-    access &= 07555; // make it readonly, since it's in the trashcan
-    Q_ASSERT(!internalFileName.isEmpty());
-    entry.insert( KIO::UDSEntry::UDS_NAME, internalFileName ); // internal filename, like "0-foo"
-    entry.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, displayFileName ); // user-visible filename, like "foo"
-    entry.insert( KIO::UDSEntry::UDS_FILE_TYPE, type );
-    //if ( !url.isEmpty() )
-    //    entry.insert( KIO::UDSEntry::UDS_URL, url );
-
-    KMimeType::Ptr mt = KMimeType::findByPath( physicalPath, buff.st_mode );
-    if ( mt )
-        entry.insert( KIO::UDSEntry::UDS_MIME_TYPE, mt->name() );
-    entry.insert( KIO::UDSEntry::UDS_ACCESS, access );
-    entry.insert( KIO::UDSEntry::UDS_SIZE, buff.st_size );
-    entry.insert( KIO::UDSEntry::UDS_USER, m_userName ); // assumption
-    entry.insert( KIO::UDSEntry::UDS_GROUP, m_groupName ); // assumption
-    entry.insert( KIO::UDSEntry::UDS_MODIFICATION_TIME, buff.st_mtime );
-    entry.insert( KIO::UDSEntry::UDS_ACCESS_TIME, buff.st_atime ); // ## or use it for deletion time?
-    entry.insert( KIO::UDSEntry::UDS_EXTRA, info.origPath );
-    entry.insert( KIO::UDSEntry::UDS_EXTRA + 1, info.deletionDate.toString( Qt::ISODate ) );
-    return true;
-}
-
-void TrashProtocol::listRoot()
-{
-    INIT_IMPL;
-    const TrashedFileInfoList lst = impl.list();
-    totalSize( lst.count() );
-    KIO::UDSEntry entry;
-    createTopLevelDirEntry( entry );
-    listEntry( entry );
-    for ( TrashedFileInfoList::ConstIterator it = lst.begin(); it != lst.end(); ++it ) {
-        const QUrl url = TrashImpl::makeURL( (*it).trashId, (*it).fileId, QString() );
-        QUrl origURL = QUrl::fromLocalFile( (*it).origPath );
-        entry.clear();
-        const QString fileDisplayName = (*it).fileId;
-
-        if ( createUDSEntry( (*it).physicalPath, fileDisplayName, url.fileName(), entry, *it ) )
-            listEntry( entry );
-    }
-    entry.clear();
-    finished();
-}
-
-void TrashProtocol::special( const QByteArray & data )
-{
-    INIT_IMPL;
-    QDataStream stream( data );
-    int cmd;
-    stream >> cmd;
-
-    switch (cmd) {
-    case 1:
-        if ( impl.emptyTrash() )
-            finished();
-        else
-            error( impl.lastErrorCode(), impl.lastErrorMessage() );
-        break;
-    case 2:
-        impl.migrateOldTrash();
-        finished();
-        break;
-    case 3:
-    {
-        QUrl url;
-        stream >> url;
-        restore( url );
-        break;
-    }
-    default:
-        qWarning() << "Unknown command in special(): " << cmd ;
-        error( KIO::ERR_UNSUPPORTED_ACTION, QString::number(cmd) );
-        break;
-    }
-}
-
-void TrashProtocol::put( const QUrl& url, int /*permissions*/, KIO::JobFlags )
-{
-    INIT_IMPL;
-    qDebug() << "put: " << url;
-    // create deleted file. We need to get the mtime and original location from metadata...
-    // Maybe we can find the info file for url.fileName(), in case ::rename() was called first, and failed...
-    error( KIO::ERR_ACCESS_DENIED, url.toString() );
-}
-
-void TrashProtocol::get( const QUrl& url )
-{
-    INIT_IMPL;
-    qDebug() << "get() : " << url;
-    if ( !url.isValid() ) {
-        //qDebug() << kBacktrace();
-        error( KIO::ERR_SLAVE_DEFINED, i18n( "Malformed URL %1", url.url() ) );
-        return;
-    }
-    if ( url.path().length() <= 1 ) {
-        error( KIO::ERR_IS_DIRECTORY, url.toString());
-        return;
-    }
-    int trashId;
-    QString fileId;
-    QString relativePath;
-    bool ok = TrashImpl::parseURL( url, trashId, fileId, relativePath );
-    if ( !ok ) {
-        error( KIO::ERR_SLAVE_DEFINED, i18n( "Malformed URL %1", url.toString() ) );
-        return;
-    }
-    const QString physicalPath = impl.physicalPath( trashId, fileId, relativePath );
-    if ( physicalPath.isEmpty() ) {
-        error( impl.lastErrorCode(), impl.lastErrorMessage() );
-        return;
-    }
-
-    // Usually we run jobs in TrashImpl (for e.g. future kdedmodule)
-    // But for this one we wouldn't use DCOP for every bit of data...
-    QUrl fileURL = QUrl::fromLocalFile( physicalPath );
-    KIO::Job* job = KIO::get( fileURL, KIO::NoReload, KIO::HideProgressInfo );
-    connect( job, SIGNAL( data( KIO::Job*, const QByteArray& ) ),
-             this, SLOT( slotData( KIO::Job*, const QByteArray& ) ) );
-    connect( job, SIGNAL( mimetype( KIO::Job*, const QString& ) ),
-             this, SLOT( slotMimetype( KIO::Job*, const QString& ) ) );
-    connect( job, SIGNAL( result(KJob*) ),
-             this, SLOT( jobFinished(KJob*) ) );
-    enterLoop();
-}
-
-void TrashProtocol::slotData( KIO::Job*, const QByteArray&arr )
-{
-    data( arr );
-}
-
-void TrashProtocol::slotMimetype( KIO::Job*, const QString& mt )
-{
-    mimeType( mt );
-}
-
-void TrashProtocol::jobFinished( KJob* job )
-{
-    if ( job->error() )
-        error( job->error(), job->errorText() );
-    else
-        finished();
-    emit leaveModality();
-}
-
-#if 0
-void TrashProtocol::mkdir( const QUrl& url, int /*permissions*/ )
-{
-    INIT_IMPL;
-    // create info about deleted dir
-    // ############ Problem: we don't know the original path.
-    // Let's try to avoid this case (we should get to copy() instead, for local files)
-    qDebug() << "mkdir: " << url;
-    QString dir = url.adjusted(QUrl::RemoveFilename).path();
-
-    if ( dir.length() <= 1 ) // new toplevel entry
-    {
-        // ## we should use TrashImpl::parseURL to give the right filename to createInfo
-        int trashId;
-        QString fileId;
-        if ( !impl.createInfo( url.path(), trashId, fileId ) ) {
-            error( impl.lastErrorCode(), impl.lastErrorMessage() );
-        } else {
-            if ( !impl.mkdir( trashId, fileId, permissions ) ) {
-                (void)impl.deleteInfo( trashId, fileId );
-                error( impl.lastErrorCode(), impl.lastErrorMessage() );
-            } else
-                finished();
-        }
-    } else {
-        // Well it's not allowed to add a directory to an existing deleted directory.
-        error( KIO::ERR_ACCESS_DENIED, url.toString() );
-    }
-}
-#endif
-
-#include "moc_kio_trash.cpp"
diff --git a/trash/kio_trash.h b/trash/kio_trash.h
deleted file mode 100644
index 37f529c..0000000
--- a/trash/kio_trash.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KIO_TRASH_H
-#define KIO_TRASH_H
-
-#include <kio/slavebase.h>
-#include "trashimpl.h"
-namespace KIO { class Job; }
-
-typedef TrashImpl::TrashedFileInfo TrashedFileInfo;
-typedef TrashImpl::TrashedFileInfoList TrashedFileInfoList;
-
-class TrashProtocol : public QObject, public KIO::SlaveBase
-{
-    Q_OBJECT
-public:
-    TrashProtocol( const QByteArray& protocol, const QByteArray &pool, const QByteArray &app);
-    virtual ~TrashProtocol();
-    virtual void stat(const QUrl& url);
-    virtual void listDir(const QUrl& url);
-    virtual void get( const QUrl& url );
-    virtual void put( const QUrl& url, int , KIO::JobFlags flags );
-    virtual void rename( const QUrl &src, const QUrl &dest, KIO::JobFlags );
-    virtual void copy( const QUrl &src, const QUrl &dest, int permissions, KIO::JobFlags flags );
-    // TODO (maybe) chmod( const QUrl& url, int permissions );
-    virtual void del( const QUrl &url, bool isfile );
-    /**
-     * Special actions: (first int in the byte array)
-     * 1 : empty trash
-     * 2 : migrate old (pre-kde-3.4) trash contents
-     * 3 : restore a file to its original location. Args: QUrl trashURL.
-     */
-    virtual void special( const QByteArray & data );
-
-Q_SIGNALS:
-    void leaveModality();
-
-private Q_SLOTS:
-    void slotData( KIO::Job*, const QByteArray& );
-    void slotMimetype( KIO::Job*, const QString& );
-    void jobFinished( KJob* job );
-
-private:
-    typedef enum { Copy, Move } CopyOrMove;
-    void copyOrMove( const QUrl& src, const QUrl& dest, bool overwrite, CopyOrMove action );
-    void createTopLevelDirEntry(KIO::UDSEntry& entry);
-    bool createUDSEntry( const QString& physicalPath, const QString& displayFileName, const QString& internalFileName,
-                         KIO::UDSEntry& entry, const TrashedFileInfo& info );
-    void listRoot();
-    void restore( const QUrl& trashURL );
-    void enterLoop();
-
-    TrashImpl impl;
-    QString m_userName;
-    QString m_groupName;
-};
-
-#endif
diff --git a/trash/kio_trash_win.cpp b/trash/kio_trash_win.cpp
deleted file mode 100644
index 624318b..0000000
--- a/trash/kio_trash_win.cpp
+++ /dev/null
@@ -1,437 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-   Copyright (C) 2009 Christian Ehrlicher <ch.ehrlicher@gmx.de>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#define QT_NO_CAST_FROM_ASCII
-
-#include "kio_trash_win.h"
-#include <kio/job.h>
-
-#include <QDebug>
-#include <kcomponentdata.h>
-#include <kconfiggroup.h>
-
-#include <QCoreApplication>
-#include <QDateTime>
-#include <objbase.h>
-
-extern "C" {
-    int Q_DECL_EXPORT kdemain( int argc, char **argv )
-    {
-        bool bNeedsUninit = ( CoInitializeEx( NULL, COINIT_MULTITHREADED ) == S_OK );
-        // necessary to use other kio slaves
-        KComponentData componentData( "kio_trash" );
-        QCoreApplication app(argc, argv);
-
-        // start the slave
-        TrashProtocol slave( argv[1], argv[2], argv[3] );
-        slave.dispatchLoop();
-        
-        if( bNeedsUninit )
-            CoUninitialize();
-        return 0;
-    }
-}
-
-static const qint64 KDE_SECONDS_SINCE_1601 =  11644473600LL;
-static const qint64 KDE_USEC_IN_SEC        =      1000000LL;
-static const int WM_SHELLNOTIFY            = (WM_USER + 42);
-#ifndef SHCNRF_InterruptLevel
-  static const int SHCNRF_InterruptLevel     =         0x0001;
-  static const int SHCNRF_ShellLevel         =         0x0002;
-  static const int SHCNRF_RecursiveInterrupt =         0x1000;
-#endif
-
-static inline time_t filetimeToTime_t(const FILETIME *time)
-{
-    ULARGE_INTEGER i64;
-    i64.LowPart   = time->dwLowDateTime;
-    i64.HighPart  = time->dwHighDateTime;
-    i64.QuadPart /= KDE_USEC_IN_SEC * 10;
-    i64.QuadPart -= KDE_SECONDS_SINCE_1601;
-    return i64.QuadPart;
-}
-
-LRESULT CALLBACK trash_internal_proc( HWND hwnd, UINT message, WPARAM wp, LPARAM lp )
-{
-    if ( message == WM_SHELLNOTIFY ) {
-        TrashProtocol *that = (TrashProtocol *)GetWindowLongPtr( hwnd, GWLP_USERDATA );
-        that->updateRecycleBin();
-    }
-    return DefWindowProc( hwnd, message, wp, lp );
-}
-
-TrashProtocol::TrashProtocol( const QByteArray& protocol, const QByteArray &pool, const QByteArray &app )
-    : SlaveBase( protocol, pool, app )
-    , m_config(QString::fromLatin1("trashrc"), KConfig::SimpleConfig)
-{
-    // create a hidden window to receive notifications thorugh window messages
-    const QString className = QLatin1String("TrashProtocol_Widget") + QString::number(quintptr(trash_internal_proc));
-    HINSTANCE hi = qWinAppInst();
-    WNDCLASS wc;
-    memset( &wc, 0, sizeof(WNDCLASS) );
-    wc.lpfnWndProc = trash_internal_proc;
-    wc.hInstance = hi;
-    wc.lpszClassName = (LPCWSTR)className.utf16();
-    RegisterClass(&wc);
-    m_notificationWindow = CreateWindow( wc.lpszClassName,  // classname
-                             wc.lpszClassName,  // window name
-                             0,                 // style
-                             0, 0, 0, 0,        // geometry
-                             0,                 // parent
-                             0,                 // menu handle
-                             hi,                // application
-                             0 );               // windows creation data.
-    SetWindowLongPtr( m_notificationWindow, GWLP_USERDATA, (LONG_PTR)this );
-
-    // get trash IShellFolder object
-    LPITEMIDLIST  iilTrash;
-    IShellFolder *isfDesktop;
-    // we assume that this will always work - if not we've a bigger problem than a kio_trash crash...
-    SHGetFolderLocation( NULL, CSIDL_BITBUCKET, 0, 0, &iilTrash );
-    SHGetDesktopFolder( &isfDesktop );
-    isfDesktop->BindToObject( iilTrash, NULL, IID_IShellFolder2, (void**)&m_isfTrashFolder );
-    isfDesktop->Release();
-    SHGetMalloc( &m_pMalloc );
-
-#if 0
-    // register for recycle bin notifications, have to do it for *every* single recycle bin
-    // TODO: this does not work for devices attached after this loop here...
-    DWORD dwSize = GetLogicalDriveStrings(0, NULL);
-    LPWSTR pszDrives = (LPWSTR)malloc((dwSize + 2) * sizeof (WCHAR));
-#endif
-
-    SHChangeNotifyEntry stPIDL;
-    stPIDL.pidl = iilTrash;
-    stPIDL.fRecursive = TRUE;
-    m_hNotifyRBin = SHChangeNotifyRegister( m_notificationWindow,
-                                            SHCNRF_InterruptLevel | SHCNRF_ShellLevel | SHCNRF_RecursiveInterrupt,
-                                            SHCNE_ALLEVENTS,
-                                            WM_SHELLNOTIFY,
-                                            1,
-                                            &stPIDL );
-
-    ILFree( iilTrash );
-    
-    updateRecycleBin();
-}
-
-TrashProtocol::~TrashProtocol()
-{
-    SHChangeNotifyDeregister( m_hNotifyRBin );
-    const QString className = QLatin1String( "TrashProtocol_Widget" ) + QString::number( quintptr( trash_internal_proc ) );
-    UnregisterClass( (LPCWSTR)className.utf16(), qWinAppInst() );
-    DestroyWindow( m_notificationWindow );
-
-    if( m_pMalloc )
-        m_pMalloc->Release();
-    if( m_isfTrashFolder )
-        m_isfTrashFolder->Release();
-}
-
-void TrashProtocol::restore( const QUrl& trashURL, const QUrl &destURL )
-{
-    LPITEMIDLIST  pidl = NULL;
-    LPCONTEXTMENU pCtxMenu = NULL;
-
-    const QString path = trashURL.path().mid( 1 ).replace( QLatin1Char( '/' ), QLatin1Char( '\\' ) );
-    LPWSTR lpFile = (LPWSTR)path.utf16();
-    HRESULT res = m_isfTrashFolder->ParseDisplayName( 0, 0, lpFile, 0, &pidl, 0 );
-    bool bOk = translateError( res );
-    if( !bOk )
-        return;
-
-    res = m_isfTrashFolder->GetUIObjectOf( 0, 1, (LPCITEMIDLIST *)&pidl, IID_IContextMenu, NULL, (LPVOID *)&pCtxMenu );
-    bOk = translateError( res );
-    if( !bOk )
-        return;
-
-    // this looks hacky but it's the only solution I found so far...
-    HMENU hmenuCtx = CreatePopupMenu();
-    res = pCtxMenu->QueryContextMenu( hmenuCtx, 0, 1, 0x00007FFF, CMF_NORMAL );
-    bOk = translateError( res );
-    if( !bOk )
-        return;
-
-    UINT uiCommand = ~0U;
-    char verb[MAX_PATH] ;
-    const int iMenuMax = GetMenuItemCount( hmenuCtx );
-    for( int i = 0 ; i < iMenuMax; i++ ) {
-        UINT uiID = GetMenuItemID(hmenuCtx, i) - 1;
-        if ((uiID == -1) || (uiID == 0))
-            continue;
-        res = pCtxMenu->GetCommandString( uiID, GCS_VERBA, NULL, verb, sizeof( verb ) );
-        if( FAILED( res ) )
-            continue;
-        if( stricmp( verb, "undelete" ) == 0 ) {
-            uiCommand = uiID;
-            break;
-        }
-    }
-    if( uiCommand != ~0U ) {
-        CMINVOKECOMMANDINFO cmi;
-			
-        memset( &cmi, 0, sizeof( CMINVOKECOMMANDINFO ) );
-        cmi.cbSize       = sizeof( CMINVOKECOMMANDINFO );
-        cmi.lpVerb       = MAKEINTRESOURCEA( uiCommand );
-        cmi.fMask        = CMIC_MASK_FLAG_NO_UI;
-        res = pCtxMenu->InvokeCommand( (CMINVOKECOMMANDINFO*)&cmi );
-
-        bOk = translateError( res );
-        if( bOk )
-            finished();
-    }
-    DestroyMenu(hmenuCtx);
-    pCtxMenu->Release();
-    ILFree( pidl );
-}
-
-void TrashProtocol::clearTrash()
-{
-    translateError( SHEmptyRecycleBin( 0, 0, 0 ) );
-    finished();
-}
-
-void TrashProtocol::rename( const QUrl &oldURL, const QUrl &newURL, KIO::JobFlags flags )
-{
-    qDebug()<<"TrashProtocol::rename(): old="<<oldURL<<" new="<<newURL<<" overwrite=" << (flags & KIO::Overwrite);
-
-    if( oldURL.protocol() == QLatin1String( "trash" ) && newURL.protocol() == QLatin1String( "trash" ) ) {
-        error( KIO::ERR_CANNOT_RENAME, oldURL.prettyUrl() );
-        return;
-    }
-
-    copyOrMove( oldURL, newURL, (flags & KIO::Overwrite), Move );
-}
-
-void TrashProtocol::copy( const QUrl &src, const QUrl &dest, int /*permissions*/, KIO::JobFlags flags )
-{
-    qDebug()<<"TrashProtocol::copy(): " << src << " " << dest;
-
-    if( src.protocol() == QLatin1String( "trash" ) && dest.protocol() == QLatin1String( "trash" ) ) {
-        error( KIO::ERR_UNSUPPORTED_ACTION, i18n( "This file is already in the trash bin." ) );
-        return;
-    }
-
-    copyOrMove( src, dest, (flags & KIO::Overwrite), Copy );
-}
-
-void TrashProtocol::copyOrMove( const QUrl &src, const QUrl &dest, bool overwrite, CopyOrMove action )
-{
-    if( src.protocol() == QLatin1String( "trash" ) && dest.isLocalFile() ) {
-        if ( action == Move ) {
-            restore( src, dest );
-        } else {
-            error( KIO::ERR_UNSUPPORTED_ACTION, i18n( "not supported" ) );
-        }
-        // Extracting (e.g. via dnd). Ignore original location stored in info file.
-        return;
-    } else if( src.isLocalFile() && dest.protocol() == QLatin1String( "trash" ) ) {
-        UINT op = ( action == Move ) ? FO_DELETE : FO_COPY;
-        if( !doFileOp( src, FO_DELETE, FOF_ALLOWUNDO ) )
-          return;
-        finished();
-        return;
-    } else {
-        error( KIO::ERR_UNSUPPORTED_ACTION, i18n( "Internal error in copyOrMove, should never happen" ) );
-    }
-}
-
-void TrashProtocol::stat(const QUrl& url)
-{
-    KIO::UDSEntry entry;
-    if( url.path() == QLatin1String( "/" ) ) {
-        STRRET strret;
-        IShellFolder *isfDesktop;
-        LPITEMIDLIST  iilTrash;
-
-        SHGetFolderLocation( NULL, CSIDL_BITBUCKET, 0, 0, &iilTrash );
-        SHGetDesktopFolder( &isfDesktop );
-        isfDesktop->BindToObject( iilTrash, NULL, IID_IShellFolder2, (void**)&m_isfTrashFolder );
-        isfDesktop->GetDisplayNameOf( iilTrash, SHGDN_NORMAL, &strret );
-        isfDesktop->Release();
-        ILFree( iilTrash );
-
-        entry.insert( KIO::UDSEntry::UDS_NAME,
-                      QString::fromUtf16( (const unsigned short*) strret.pOleStr ) );
-        entry.insert( KIO::UDSEntry::UDS_FILE_TYPE, S_IFDIR );
-        entry.insert( KIO::UDSEntry::UDS_ACCESS, 0700 );
-        entry.insert( KIO::UDSEntry::UDS_MIME_TYPE, QString::fromLatin1("inode/directory") );
-        m_pMalloc->Free( strret.pOleStr );
-    } else {
-        // TODO: when does this happen?
-    }
-    statEntry( entry );
-    finished();
-}
-
-void TrashProtocol::del( const QUrl &url, bool /*isfile*/ )
-{
-    if( !doFileOp( url, FO_DELETE, 0 ) )
-      return;
-    finished();
-}
-
-void TrashProtocol::listDir(const QUrl& url)
-{
-    qDebug()<<"TrashProtocol::listDir(): " << url;
-    // There are no subfolders in Windows Trash
-    listRoot();
-}
-
-void TrashProtocol::listRoot()
-{
-    IEnumIDList *l;
-    HRESULT res = m_isfTrashFolder->EnumObjects( 0, SHCONTF_FOLDERS|SHCONTF_NONFOLDERS|SHCONTF_INCLUDEHIDDEN, &l );
-    if( res != S_OK )
-      return;
-
-    STRRET strret;
-    SFGAOF attribs;
-    KIO::UDSEntry entry;
-    LPITEMIDLIST i;
-    WIN32_FIND_DATAW findData;
-    while( l->Next( 1, &i, NULL ) == S_OK ) {
-      m_isfTrashFolder->GetDisplayNameOf( i, SHGDN_NORMAL, &strret );
-      entry.insert( KIO::UDSEntry::UDS_DISPLAY_NAME, 
-                    QString::fromUtf16( (const unsigned short*)strret.pOleStr ) );
-      m_pMalloc->Free( strret.pOleStr );
-      m_isfTrashFolder->GetDisplayNameOf( i, SHGDN_FORPARSING|SHGDN_INFOLDER, &strret );
-      entry.insert( KIO::UDSEntry::UDS_NAME, 
-                    QString::fromUtf16( (const unsigned short*)strret.pOleStr ) );
-      m_pMalloc->Free( strret.pOleStr );
-      m_isfTrashFolder->GetAttributesOf( 1, (LPCITEMIDLIST *)&i, &attribs );
-      SHGetDataFromIDList( m_isfTrashFolder, i, SHGDFIL_FINDDATA, &findData, sizeof( findData ) );
-      entry.insert( KIO::UDSEntry::UDS_SIZE,
-                    ((quint64)findData.nFileSizeLow) + (((quint64)findData.nFileSizeHigh) << 32) );
-      entry.insert( KIO::UDSEntry::UDS_MODIFICATION_TIME,
-                    filetimeToTime_t( &findData.ftLastWriteTime ) );
-      entry.insert( KIO::UDSEntry::UDS_ACCESS_TIME,
-                    filetimeToTime_t( &findData.ftLastAccessTime ) );
-      entry.insert( KIO::UDSEntry::UDS_CREATION_TIME,
-                    filetimeToTime_t( &findData.ftCreationTime ) );
-      entry.insert( KIO::UDSEntry::UDS_EXTRA,
-                    QString::fromUtf16( (const unsigned short*)strret.pOleStr ) );
-      entry.insert( KIO::UDSEntry::UDS_EXTRA + 1, QDateTime().toString( Qt::ISODate ) );
-      mode_t type = S_IFREG;
-      if ( ( attribs & SFGAO_FOLDER ) == SFGAO_FOLDER )
-          type = S_IFDIR;
-      if ( ( attribs & SFGAO_LINK ) == SFGAO_LINK )
-          type = S_IFLNK;
-      entry.insert( KIO::UDSEntry::UDS_FILE_TYPE, type );
-      mode_t access = 0700;
-      if ( ( findData.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) == FILE_ATTRIBUTE_READONLY )
-          type = 0300;
-      listEntry( entry, false );
-
-      ILFree( i );
-    }
-    l->Release();
-    entry.clear();
-    listEntry( entry, true );
-    finished();
-}
-
-void TrashProtocol::special( const QByteArray & data )
-{
-    QDataStream stream( data );
-    int cmd;
-    stream >> cmd;
-
-    switch (cmd) {
-    case 1:
-        // empty trash folder
-        clearTrash();
-        break;
-    case 2:
-        // convert old trash folder (non-windows only)
-        finished();
-        break;
-    case 3:
-    {
-        QUrl url;
-        stream >> url;
-        restore( url, QUrl() );
-        break;
-    }
-    default:
-        kWarning(7116) << "Unknown command in special(): " << cmd ;
-        error( KIO::ERR_UNSUPPORTED_ACTION, QString::number(cmd) );
-        break;
-    }
-}
-
-void TrashProtocol::updateRecycleBin()
-{
-    IEnumIDList *l;
-    HRESULT res = m_isfTrashFolder->EnumObjects( 0, SHCONTF_FOLDERS|SHCONTF_NONFOLDERS|SHCONTF_INCLUDEHIDDEN, &l );
-    if( res != S_OK )
-        return;
-
-    bool bEmpty = true;
-    LPITEMIDLIST i;
-    if( l->Next( 1, &i, NULL ) == S_OK ) {
-        bEmpty = false;
-        ILFree( i );
-    }
-    KConfigGroup group = m_config.group( "Status" );
-    group.writeEntry( "Empty", bEmpty );
-    m_config.sync();
-    l->Release();
-}
-
-void TrashProtocol::put( const QUrl& url, int /*permissions*/, KIO::JobFlags )
-{
-    qDebug() << "put: " << url;
-    // create deleted file. We need to get the mtime and original location from metadata...
-    // Maybe we can find the info file for url.fileName(), in case ::rename() was called first, and failed...
-    error( KIO::ERR_ACCESS_DENIED, url.prettyUrl() );
-}
-
-void TrashProtocol::get( const QUrl& url )
-{
-    // TODO
-}
-
-bool TrashProtocol::doFileOp(const QUrl &url, UINT wFunc, FILEOP_FLAGS fFlags)
-{
-    const QString path = url.path().replace(QLatin1Char('/'),QLatin1Char('\\'));
-    // must be double-null terminated.
-    QByteArray delBuf( ( path.length() + 2 ) * 2, 0 );
-    memcpy( delBuf.data(), path.utf16(), path.length() * 2 );
-
-    SHFILEOPSTRUCTW op;
-    memset( &op, 0, sizeof( SHFILEOPSTRUCTW ) );
-    op.wFunc = wFunc;
-    op.pFrom = (LPCWSTR)delBuf.constData();
-    op.fFlags = fFlags|FOF_NOCONFIRMATION|FOF_NOERRORUI;
-    return translateError( SHFileOperationW( &op ) );
-}
-
-bool TrashProtocol::translateError(HRESULT hRes)
-{
-    // TODO!
-    if( FAILED( hRes ) ) {
-        error( KIO::ERR_DOES_NOT_EXIST, QLatin1String("fixme!") );
-        return false;
-    }
-    return true;
-}
-
-#include "moc_kio_trash_win.cpp"
diff --git a/trash/kio_trash_win.h b/trash/kio_trash_win.h
deleted file mode 100644
index 5a08427..0000000
--- a/trash/kio_trash_win.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-   Copyright (C) 2009 Christian Ehrlicher <ch.ehrlicher@gmx.de>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KIO_TRASH_H
-#define KIO_TRASH_H
-
-#include <kio/slavebase.h>
-#include <windows.h>
-#include <shellapi.h>
-#include <shlobj.h>
-
-namespace KIO { class Job; }
-
-class TrashProtocol : public QObject, public KIO::SlaveBase
-{
-    Q_OBJECT
-public:
-    TrashProtocol( const QByteArray& protocol, const QByteArray &pool, const QByteArray &app );
-    virtual ~TrashProtocol();
-    virtual void stat( const QUrl& url );
-    virtual void listDir( const QUrl& url );
-    virtual void get( const QUrl& url );
-    virtual void put( const QUrl& url, int , KIO::JobFlags flags );
-    virtual void rename( const QUrl &, const QUrl &, KIO::JobFlags );
-    virtual void copy( const QUrl &src, const QUrl &dest, int permissions, KIO::JobFlags flags );
-    // TODO (maybe) chmod( const QUrl& url, int permissions );
-    virtual void del( const QUrl &url, bool isfile );
-    /**
-     * Special actions: (first int in the byte array)
-     * 1 : empty trash
-     * 2 : migrate old (pre-kde-3.4) trash contents
-     * 3 : restore a file to its original location. Args: QUrl trashURL.
-     */
-    virtual void special( const QByteArray & data );
-
-    void updateRecycleBin();
-private:
-    typedef enum { Copy, Move } CopyOrMove;
-    void copyOrMove( const QUrl& src, const QUrl& dest, bool overwrite, CopyOrMove action );
-    void listRoot();
-    void restore( const QUrl& trashURL, const QUrl &destURL );
-    void clearTrash();
-
-    bool doFileOp(const QUrl &url, UINT wFunc, FILEOP_FLAGS fFlags);
-    bool translateError(HRESULT retValue);
-
-    KConfig m_config;
-    HWND m_notificationWindow;
-    IShellFolder2 *m_isfTrashFolder;
-    LPMALLOC m_pMalloc;
-    ULONG m_hNotifyRBin;
-};
-
-#endif
diff --git a/trash/ktrash.cpp b/trash/ktrash.cpp
deleted file mode 100644
index f3bd1f6..0000000
--- a/trash/ktrash.cpp
+++ /dev/null
@@ -1,79 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#include <QCoreApplication>
-#include <QDebug>
-#include <QUrl>
-#include <QCommandLineParser>
-#include <QCommandLineOption>
-#include <KLocalizedString>
-#include <KIO/EmptyTrashJob>
-
-int main(int argc, char *argv[])
-{
-    QCoreApplication app(argc, argv);
-    app.setApplicationName("ktrash");
-    app.setApplicationVersion(PROJECT_VERSION);
-    app.setOrganizationDomain("kde.org");
-
-    QCommandLineParser parser;
-    parser.addVersionOption();
-    parser.addHelpOption();
-    parser.setApplicationDescription(i18n( "Helper program to handle the KDE trash can\n"
-                "Note: to move files to the trash, do not use ktrash, but \"kioclient move 'url' trash:/\""));
-
-    parser.addOption(QCommandLineOption(QStringList() << QLatin1String("empty"), i18n("Empty the contents of the trash")));
-    parser.addOption(QCommandLineOption(QStringList() << QLatin1String("restore"), i18n("Restore a trashed file to its original location"), "file"));
-
-    parser.process(app);
-
-    if (parser.isSet("empty")) {
-        // We use a kio job instead of linking to TrashImpl, for a smaller binary
-        // (and the possibility of a central service at some point)
-        KIO::Job* job = KIO::emptyTrash();
-        job->exec();
-        return 0;
-    }
-
-    QString restoreArg = parser.value("restore");
-    if ( !restoreArg.isEmpty() ) {
-
-        if (restoreArg.indexOf(QLatin1String("system:/trash"))==0) {
-            restoreArg.remove(0, 13);
-            restoreArg.prepend(QString::fromLatin1("trash:"));
-        }
-
-        QUrl trashURL( restoreArg );
-        if ( !trashURL.isValid() || trashURL.scheme() != QLatin1String("trash") ) {
-            qCritical() << "Invalid URL for restoring a trashed file, trash:// URL expected:" << trashURL;
-            return 1;
-        }
-
-        QByteArray packedArgs;
-        QDataStream stream( &packedArgs, QIODevice::WriteOnly );
-        stream << (int)3 << trashURL;
-        KIO::Job* job = KIO::special( trashURL, packedArgs );
-        bool ok = job->exec() ? true : false;
-        if ( !ok )
-            qCritical() << job->errorString();
-        return 0;
-    }
-
-    return 0;
-}
diff --git a/trash/tests/CMakeLists.txt b/trash/tests/CMakeLists.txt
deleted file mode 100644
index 17855d6..0000000
--- a/trash/tests/CMakeLists.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/.. )
-
-########### next target ###############
-
-set(testtrash_SRCS 
-    testtrash.cpp 
-    ${CMAKE_CURRENT_SOURCE_DIR}/../trashimpl.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/../trashsizecache.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/../discspaceutil.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/../kinterprocesslock.cpp
-)
-
-add_executable(testtrash ${testtrash_SRCS})
-ecm_mark_as_test(testtrash)
-add_test(testtrash testtrash)
-
-target_link_libraries(testtrash KF5::I18n Qt5::DBus KF5::KIOCore KF5::Solid Qt5::Test KF5::KDE4Support)
-
-### next target ###
-
-add_executable(lockingtest lockingtest.cpp ../kinterprocesslock.cpp)
-ecm_mark_nongui_executable(lockingtest)
-
-target_link_libraries(lockingtest Qt5::Core Qt5::DBus)
diff --git a/trash/tests/lockingtest.cpp b/trash/tests/lockingtest.cpp
deleted file mode 100644
index 81ccbc9..0000000
--- a/trash/tests/lockingtest.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
-    This file is part of the KDE
-
-    Copyright (C) 2009 Tobias Koenig (tokoe@kde.org)
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU General Public License
-    version 2 as published by the Free Software Foundation.
-
-    This software is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this library; see the file COPYING. If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#include <QtCore/QCoreApplication>
-#include <QtCore/QThread>
-
-#include "kinterprocesslock.h"
-
-#include <unistd.h>
-
-int main(int argc, char **argv)
-{
-    QCoreApplication app(argc, argv);
-
-    KInterProcessLock lock("mytrash");
-    qDebug("retrieve lock...");
-    lock.lock();
-    qDebug("waiting...");
-    lock.waitForLockGranted();
-    qDebug("retrieved lock");
-    qDebug("sleeping...");
-#ifdef Q_OS_WIN
-    Sleep(10*1000);
-#else
-    sleep(10);
-#endif
-
-    if (argc != 2) {
-        lock.unlock();
-        qDebug("release lock");
-    }
-
-    return 0;
-}
diff --git a/trash/tests/testtrash.cpp b/trash/tests/testtrash.cpp
deleted file mode 100644
index 799b933..0000000
--- a/trash/tests/testtrash.cpp
+++ /dev/null
@@ -1,1188 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#include <qtest.h>
-
-#include "kio_trash.h"
-#include "testtrash.h"
-#include <kprotocolinfo.h>
-#include <ktemporaryfile.h>
-
-#include <klocale.h>
-#include <kio/netaccess.h>
-#include <kio/job.h>
-#include <kio/copyjob.h>
-#include <kio/deletejob.h>
-#include <QDebug>
-#include <kcmdlineargs.h>
-#include <kconfiggroup.h>
-
-#include <QDir>
-#include <QUrl>
-#include <QFileInfo>
-#include <QVector>
-#include <kjobuidelegate.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <kmimetype.h>
-#include <kfileitem.h>
-#include <kstandarddirs.h>
-#include <kio/chmodjob.h>
-#include <kio/directorysizejob.h>
-#include <QStandardPaths>
-
-// There are two ways to test encoding things:
-// * with utf8 filenames
-// * with latin1 filenames -- not sure this still works.
-//
-#define UTF8TEST 1
-
-int initLocale()
-{
-#ifdef UTF8TEST
-    // Assume utf8 system
-    setenv( "LC_ALL", "en_US.utf-8", 1 );
-    setenv( "KDE_UTF8_FILENAMES", "true", 1 );
-#else
-    // Ensure a known QFile::encodeName behavior for trashUtf8FileFromHome
-    // However this assume your $HOME doesn't use characters from other locales...
-    setenv( "LC_ALL", "en_US.ISO-8859-1", 1 );
-    unsetenv( "KDE_UTF8_FILENAMES" );
-#endif
-    setenv("KDEHOME", QFile::encodeName( QDir::homePath() + QString::fromLatin1("/.kde-unit-test") ), 1);
-    setenv("XDG_DATA_HOME", QFile::encodeName( QDir::homePath() + QString::fromLatin1("/.kde-unit-test/xdg/local") ), 1);
-    setenv("XDG_CONFIG_HOME", QFile::encodeName( QDir::homePath() + QString::fromLatin1("/.kde-unit-test/xdg/config") ), 1);
-    setenv("KDE_SKIP_KDERC", "1", 1);
-    unsetenv("KDE_COLOR_DEBUG");
-    return 0;
-}
-Q_CONSTRUCTOR_FUNCTION(initLocale)
-
-
-QString TestTrash::homeTmpDir() const
-{
-    return QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QString::fromLatin1("/testtrash/");
-}
-
-QString TestTrash::readOnlyDirPath() const
-{
-    return homeTmpDir() + QString::fromLatin1("readonly");
-}
-
-QString TestTrash::otherTmpDir() const
-{
-    // This one needs to be on another partition
-    return QString::fromLatin1("/tmp/testtrash/");
-}
-
-QString TestTrash::utf8FileName() const
-{
-    return QString::fromLatin1( "test" ) + QChar( 0x2153 ); // "1/3" character, not part of latin1
-}
-
-QString TestTrash::umlautFileName() const
-{
-    return QString::fromLatin1( "umlaut" ) + QChar( 0xEB );
-}
-
-static void removeFile( const QString& trashDir, const QString& fileName )
-{
-    QDir dir;
-    dir.remove( trashDir + fileName );
-    QVERIFY( !QDir( trashDir + fileName ).exists() );
-}
-
-static void removeDir( const QString& trashDir, const QString& dirName )
-{
-    QDir dir;
-    dir.rmdir( trashDir + dirName );
-    QVERIFY( !QDir( trashDir + dirName ).exists() );
-}
-
-static void removeDirRecursive( const QString& dir )
-{
-    if ( QFile::exists( dir ) ) {
-
-        // Make it work even with readonly dirs, like trashReadOnlyDirFromHome() creates
-        QUrl u = QUrl::fromLocalFile( dir );
-        //qDebug() << "chmod +0200 on" << u;
-        KFileItem fileItem(u, QString::fromLatin1("inode/directory"), KFileItem::Unknown);
-        KFileItemList fileItemList;
-        fileItemList.append( fileItem );
-        KIO::ChmodJob* chmodJob = KIO::chmod( fileItemList, 0200, 0200, QString(), QString(), true /*recursive*/, KIO::HideProgressInfo );
-        KIO::NetAccess::synchronousRun( chmodJob, 0 );
-
-        KIO::Job* delJob = KIO::del(u, KIO::HideProgressInfo);
-        if (!KIO::NetAccess::synchronousRun(delJob, 0))
-            qFatal("Couldn't delete %s", qPrintable(dir));
-    }
-}
-
-void TestTrash::initTestCase()
-{
-    qDebug() << qgetenv("LC_ALL");
-    setenv( "KDE_FORK_SLAVES", "yes", true );
-
-
-    m_trashDir = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QString::fromLatin1("/Trash");
-    qDebug() << "setup: using trash directory " << m_trashDir;
-
-    // Look for another writable partition than $HOME (not mandatory)
-    TrashImpl impl;
-    impl.init();
-
-    TrashImpl::TrashDirMap trashDirs = impl.trashDirectories();
-    TrashImpl::TrashDirMap topDirs = impl.topDirectories();
-    bool foundTrashDir = false;
-    m_otherPartitionId = 0;
-    m_tmpIsWritablePartition = false;
-    m_tmpTrashId = -1;
-    QVector<int> writableTopDirs;
-    for ( TrashImpl::TrashDirMap::ConstIterator it = trashDirs.constBegin(); it != trashDirs.constEnd() ; ++it ) {
-        if ( it.key() == 0 ) {
-            QVERIFY( it.value() == m_trashDir );
-            QVERIFY( topDirs.find( 0 ) == topDirs.end() );
-            foundTrashDir = true;
-        } else {
-            QVERIFY( topDirs.find( it.key() ) != topDirs.end() );
-            const QString topdir = topDirs[it.key()];
-            if ( QFileInfo( topdir ).isWritable() ) {
-                writableTopDirs.append( it.key() );
-                if (topdir == QLatin1String("/tmp/")) {
-                    m_tmpIsWritablePartition = true;
-                    m_tmpTrashId = it.key();
-                    qDebug() << "/tmp is on its own partition (trashid=" << m_tmpTrashId << "), some tests will be skipped";
-                    removeFile( it.value(), QString::fromLatin1("/info/fileFromOther.trashinfo") );
-                    removeFile( it.value(), QString::fromLatin1("/files/fileFromOther") );
-                    removeFile( it.value(), QString::fromLatin1("/info/symlinkFromOther.trashinfo") );
-                    removeFile( it.value(), QString::fromLatin1("/files/symlinkFromOther") );
-                    removeFile( it.value(), QString::fromLatin1("/info/trashDirFromOther.trashinfo") );
-                    removeFile( it.value(), QString::fromLatin1("/files/trashDirFromOther/testfile") );
-                    removeDir( it.value(), QString::fromLatin1("/files/trashDirFromOther") );
-                }
-            }
-        }
-    }
-    for ( QVector<int>::const_iterator it = writableTopDirs.constBegin(); it != writableTopDirs.constEnd(); ++it ) {
-        const QString topdir = topDirs[ *it ];
-        const QString trashdir = trashDirs[ *it ];
-        QVERIFY( !topdir.isEmpty() );
-        QVERIFY( !trashDirs.isEmpty() );
-        if (topdir != QLatin1String("/tmp/") ||         // we'd prefer not to use /tmp here, to separate the tests
-            (writableTopDirs.count() > 1)) // but well, if we have no choice, take it
-        {
-            m_otherPartitionTopDir = topdir;
-            m_otherPartitionTrashDir = trashdir;
-            m_otherPartitionId = *it;
-            qDebug() << "OK, found another writable partition: topDir=" << m_otherPartitionTopDir
-                      << " trashDir=" << m_otherPartitionTrashDir << " id=" << m_otherPartitionId << endl;
-            break;
-        }
-    }
-    // Check that m_trashDir got listed
-    QVERIFY( foundTrashDir );
-    if ( m_otherPartitionTrashDir.isEmpty() )
-        qWarning() << "No writable partition other than $HOME found, some tests will be skipped" ;
-
-    // Start with a clean base dir
-    qDebug() << "initial cleanup";
-    removeDirRecursive( homeTmpDir() );
-    removeDirRecursive( otherTmpDir() );
-
-    QDir dir; // TT: why not a static method?
-    bool ok = dir.mkdir( homeTmpDir() );
-    if ( !ok )
-        qFatal("Couldn't create directory: %s", qPrintable(homeTmpDir()));
-    ok = dir.mkdir( otherTmpDir() );
-    if ( !ok )
-        qFatal("Couldn't create directory: %s", qPrintable(otherTmpDir()));
-
-    // Start with a clean trash too
-    qDebug() << "removing trash dir";
-    removeDirRecursive( m_trashDir );
-}
-
-void TestTrash::cleanupTestCase()
-{
-    // Clean up
-    removeDirRecursive( homeTmpDir() );
-    removeDirRecursive( otherTmpDir() );
-    removeDirRecursive( m_trashDir );
-}
-
-void TestTrash::urlTestFile()
-{
-    const QUrl url = TrashImpl::makeURL(1, QString::fromLatin1("fileId"), QString());
-    QCOMPARE( url.url(), QString::fromLatin1("trash:/1-fileId"));
-
-    int trashId;
-    QString fileId;
-    QString relativePath;
-    bool ok = TrashImpl::parseURL( url, trashId, fileId, relativePath );
-    QVERIFY( ok );
-    QCOMPARE( QString::number( trashId ), QString::fromLatin1( "1" ) );
-    QCOMPARE( fileId, QString::fromLatin1( "fileId" ) );
-    QCOMPARE( relativePath, QString() );
-}
-
-void TestTrash::urlTestDirectory()
-{
-    const QUrl url = TrashImpl::makeURL( 1, QString::fromLatin1("fileId"), QString::fromLatin1("subfile") );
-    QCOMPARE( url.url(), QString::fromLatin1( "trash:/1-fileId/subfile" ) );
-
-    int trashId;
-    QString fileId;
-    QString relativePath;
-    bool ok = TrashImpl::parseURL( url, trashId, fileId, relativePath );
-    QVERIFY( ok );
-    QCOMPARE( trashId, 1 );
-    QCOMPARE( fileId, QString::fromLatin1( "fileId" ) );
-    QCOMPARE( relativePath, QString::fromLatin1( "subfile" ) );
-}
-
-void TestTrash::urlTestSubDirectory()
-{
-    const QUrl url = TrashImpl::makeURL(1, QString::fromLatin1("fileId"), QString::fromLatin1("subfile/foobar"));
-    QCOMPARE(url.url(), QString::fromLatin1("trash:/1-fileId/subfile/foobar"));
-
-    int trashId;
-    QString fileId;
-    QString relativePath;
-    bool ok = TrashImpl::parseURL( url, trashId, fileId, relativePath );
-    QVERIFY( ok );
-    QCOMPARE( trashId, 1 );
-    QCOMPARE( fileId, QString::fromLatin1( "fileId" ) );
-    QCOMPARE( relativePath, QString::fromLatin1( "subfile/foobar" ) );
-}
-
-static void checkInfoFile( const QString& infoPath, const QString& origFilePath )
-{
-    qDebug() << infoPath;
-    QFileInfo info( infoPath );
-    QVERIFY( info.exists() );
-    QVERIFY( info.isFile() );
-    KConfig infoFile( info.absoluteFilePath() );
-    KConfigGroup group = infoFile.group( "Trash Info" );
-    if ( !group.exists() )
-        qFatal("no Trash Info group in %s", qPrintable(info.absoluteFilePath()));
-    const QString origPath = group.readEntry( "Path" );
-    QVERIFY(!origPath.isEmpty());
-    QVERIFY(origPath == QString::fromLatin1(QUrl::toPercentEncoding(origFilePath, "/")));
-    if (origFilePath.contains(QChar(0x2153)) || origFilePath.contains(QLatin1Char('%')) || origFilePath.contains(QString::fromLatin1("umlaut"))) {
-        QVERIFY(origPath.contains(QLatin1Char('%')));
-    } else {
-        QVERIFY(!origPath.contains(QLatin1Char('%')));
-    }
-    const QString date = group.readEntry( "DeletionDate" );
-    QVERIFY(!date.isEmpty());
-    QVERIFY(date.contains(QString::fromLatin1("T")));
-}
-
-static void createTestFile( const QString& path )
-{
-    QFile f( path );
-    if ( !f.open( QIODevice::WriteOnly ) )
-        qFatal("Can't create %s", qPrintable(path));
-    f.write( "Hello world\n", 12 );
-    f.close();
-    QVERIFY( QFile::exists( path ) );
-}
-
-void TestTrash::trashFile( const QString& origFilePath, const QString& fileId )
-{
-    // setup
-    if ( !QFile::exists( origFilePath ) )
-        createTestFile( origFilePath );
-    QUrl u = QUrl::fromLocalFile( origFilePath );
-
-    // test
-    KIO::Job* job = KIO::move( u, QUrl("trash:/"), KIO::HideProgressInfo );
-    QMap<QString, QString> metaData;
-    bool ok = KIO::NetAccess::synchronousRun( job, 0, 0, 0, &metaData );
-    if ( !ok )
-        qCritical() << "moving " << u << " to trash failed with error " << KIO::NetAccess::lastError() << " " << KIO::NetAccess::lastErrorString() << endl;
-    QVERIFY( ok );
-    if (origFilePath.startsWith(QLatin1String("/tmp")) && m_tmpIsWritablePartition) {
-        qDebug() << " TESTS SKIPPED";
-    } else {
-        checkInfoFile(m_trashDir + QString::fromLatin1("/info/") + fileId + QString::fromLatin1(".trashinfo"), origFilePath);
-
-        QFileInfo files(m_trashDir + QString::fromLatin1("/files/") + fileId);
-        QVERIFY( files.isFile() );
-        QVERIFY( files.size() == 12 );
-    }
-
-    // coolo suggests testing that the original file is actually gone, too :)
-    QVERIFY( !QFile::exists( origFilePath ) );
-
-    QVERIFY( !metaData.isEmpty() );
-    bool found = false;
-    QMap<QString, QString>::ConstIterator it = metaData.constBegin();
-    for ( ; it != metaData.constEnd() ; ++it ) {
-        if (it.key().startsWith(QLatin1String("trashURL"))) {
-            const QString origPath = it.key().mid( 9 );
-            QUrl trashURL( it.value() );
-            qDebug() << trashURL;
-            QVERIFY(!trashURL.isEmpty());
-            QVERIFY(trashURL.scheme() == QLatin1String("trash"));
-            int trashId = 0;
-            if (origFilePath.startsWith(QLatin1String("/tmp")) && m_tmpIsWritablePartition)
-                trashId = m_tmpTrashId;
-            QCOMPARE(trashURL.path(), QString(QString::fromLatin1("/") + QString::number(trashId) + QLatin1Char('-') + fileId));
-            found = true;
-        }
-    }
-    QVERIFY( found );
-}
-
-void TestTrash::trashFileFromHome()
-{
-    const QString fileName = QString::fromLatin1("fileFromHome");
-    trashFile( homeTmpDir() + fileName, fileName );
-
-    // Do it again, check that we got a different id
-    trashFile(homeTmpDir() + fileName, fileName + QString::fromLatin1(" 1"));
-}
-
-void TestTrash::trashPercentFileFromHome()
-{
-    const QString fileName = QString::fromLatin1("file%2f");
-    trashFile( homeTmpDir() + fileName, fileName );
-}
-
-void TestTrash::trashUtf8FileFromHome()
-{
-#ifdef UTF8TEST
-    const QString fileName = utf8FileName();
-    trashFile( homeTmpDir() + fileName, fileName );
-#endif
-}
-
-void TestTrash::trashUmlautFileFromHome()
-{
-    const QString fileName = umlautFileName();
-    trashFile( homeTmpDir() + fileName, fileName );
-}
-
-void TestTrash::testTrashNotEmpty()
-{
-    KConfig cfg(QString::fromLatin1("trashrc"), KConfig::SimpleConfig);
-    const KConfigGroup group = cfg.group( "Status" );
-    QVERIFY( group.exists() );
-    QVERIFY( group.readEntry( "Empty", true ) == false );
-}
-
-void TestTrash::trashFileFromOther()
-{
-    const QString fileName = QString::fromLatin1("fileFromOther");
-    trashFile( otherTmpDir() + fileName, fileName );
-}
-
-void TestTrash::trashFileIntoOtherPartition()
-{
-    if ( m_otherPartitionTrashDir.isEmpty() ) {
-        qDebug() << " - SKIPPED";
-        return;
-    }
-    const QString fileName = QString::fromLatin1("testtrash-file");
-    const QString origFilePath = m_otherPartitionTopDir + fileName;
-    const QString fileId = fileName;
-    // cleanup
-    QFile::remove(m_otherPartitionTrashDir + QString::fromLatin1("/info/") + fileId + QString::fromLatin1(".trashinfo"));
-    QFile::remove(m_otherPartitionTrashDir + QString::fromLatin1("/files/") + fileId);
-
-    // setup
-    if ( !QFile::exists( origFilePath ) )
-        createTestFile( origFilePath );
-    QUrl u = QUrl::fromLocalFile( origFilePath );
-
-    // test
-    KIO::Job* job = KIO::move( u, QUrl("trash:/"), KIO::HideProgressInfo );
-    QMap<QString, QString> metaData;
-    bool ok = KIO::NetAccess::synchronousRun( job, 0, 0, 0, &metaData );
-    QVERIFY( ok );
-    // Note that the Path stored in the info file is relative, on other partitions (#95652)
-    checkInfoFile(m_otherPartitionTrashDir + QString::fromLatin1("/info/") + fileId + QString::fromLatin1(".trashinfo"), fileName);
-
-    QFileInfo files(m_otherPartitionTrashDir + QString::fromLatin1("/files/") + fileId);
-    QVERIFY( files.isFile() );
-    QVERIFY( files.size() == 12 );
-
-    // coolo suggests testing that the original file is actually gone, too :)
-    QVERIFY( !QFile::exists( origFilePath ) );
-
-    QVERIFY( !metaData.isEmpty() );
-    bool found = false;
-    QMap<QString, QString>::ConstIterator it = metaData.constBegin();
-    for ( ; it != metaData.constEnd() ; ++it ) {
-        if (it.key().startsWith( QLatin1String("trashURL"))) {
-            const QString origPath = it.key().mid( 9 );
-            QUrl trashURL( it.value() );
-            qDebug() << trashURL;
-            QVERIFY( !trashURL.isEmpty() );
-            QVERIFY(trashURL.scheme() == QLatin1String("trash"));
-            QVERIFY(trashURL.path() == QString::fromLatin1("/%1-%2").arg( m_otherPartitionId ).arg(fileId));
-            found = true;
-        }
-    }
-    QVERIFY( found );
-}
-
-void TestTrash::trashFileOwnedByRoot()
-{
-    QUrl u( "file:///etc/passwd" );
-    const QString fileId = QString::fromLatin1("passwd");
-
-    KIO::CopyJob* job = KIO::move( u, QUrl("trash:/"), KIO::HideProgressInfo );
-    job->setUiDelegate(0); // no skip dialog, thanks
-    QMap<QString, QString> metaData;
-    bool ok = KIO::NetAccess::synchronousRun( job, 0, 0, 0, &metaData );
-    QVERIFY( !ok );
-
-    QVERIFY( KIO::NetAccess::lastError() == KIO::ERR_ACCESS_DENIED );
-    const QString infoPath(m_trashDir + QString::fromLatin1("/info/") + fileId + QString::fromLatin1(".trashinfo"));
-    QVERIFY( !QFile::exists( infoPath ) );
-
-    QFileInfo files(m_trashDir + QString::fromLatin1("/files/") + fileId);
-    QVERIFY( !files.exists() );
-
-    QVERIFY( QFile::exists( u.path() ) );
-}
-
-void TestTrash::trashSymlink( const QString& origFilePath, const QString& fileId, bool broken )
-{
-    // setup
-    const char* target = broken ? "/nonexistent" : "/tmp";
-    bool ok = ::symlink( target, QFile::encodeName( origFilePath ) ) == 0;
-    QVERIFY( ok );
-    QUrl u = QUrl::fromLocalFile( origFilePath );
-
-    // test
-    KIO::Job* job = KIO::move( u, QUrl("trash:/"), KIO::HideProgressInfo );
-    ok = job->exec();
-    QVERIFY( ok );
-    if (origFilePath.startsWith(QLatin1String("/tmp")) && m_tmpIsWritablePartition) {
-        qDebug() << " TESTS SKIPPED";
-        return;
-    }
-    checkInfoFile(m_trashDir + QString::fromLatin1("/info/") + fileId + QString::fromLatin1(".trashinfo"), origFilePath);
-
-    QFileInfo files(m_trashDir + QString::fromLatin1("/files/") + fileId);
-    QVERIFY( files.isSymLink() );
-    QVERIFY( files.readLink() == QFile::decodeName( target ) );
-    QVERIFY( !QFile::exists( origFilePath ) );
-}
-
-void TestTrash::trashSymlinkFromHome()
-{
-    const QString fileName = QString::fromLatin1("symlinkFromHome");
-    trashSymlink( homeTmpDir() + fileName, fileName, false );
-}
-
-void TestTrash::trashSymlinkFromOther()
-{
-    const QString fileName = QString::fromLatin1("symlinkFromOther");
-    trashSymlink( otherTmpDir() + fileName, fileName, false );
-}
-
-void TestTrash::trashBrokenSymlinkFromHome()
-{
-    const QString fileName = QString::fromLatin1("brokenSymlinkFromHome");
-    trashSymlink( homeTmpDir() + fileName, fileName, true );
-}
-
-void TestTrash::trashDirectory( const QString& origPath, const QString& fileId )
-{
-    qDebug() << fileId;
-    // setup
-    if ( !QFileInfo( origPath ).exists() ) {
-        QDir dir;
-        bool ok = dir.mkdir( origPath );
-        QVERIFY( ok );
-    }
-    createTestFile(origPath + QString::fromLatin1("/testfile"));
-    QVERIFY(QDir().mkdir(origPath + QString::fromLatin1("/subdir")));
-    createTestFile(origPath + QString::fromLatin1("/subdir/subfile"));
-    QUrl u = QUrl::fromLocalFile( origPath );
-
-    // test
-    KIO::Job* job = KIO::move( u, QUrl("trash:/"), KIO::HideProgressInfo );
-    QVERIFY( job->exec() );
-    if (origPath.startsWith(QLatin1String("/tmp")) && m_tmpIsWritablePartition) {
-        qDebug() << " TESTS SKIPPED";
-        return;
-    }
-    checkInfoFile(m_trashDir + QString::fromLatin1("/info/") + fileId + QString::fromLatin1(".trashinfo"), origPath);
-
-    QFileInfo filesDir(m_trashDir + QString::fromLatin1("/files/") + fileId);
-    QVERIFY( filesDir.isDir() );
-    QFileInfo files(m_trashDir + QString::fromLatin1("/files/") + fileId + QString::fromLatin1("/testfile"));
-    QVERIFY( files.exists() );
-    QVERIFY( files.isFile() );
-    QVERIFY( files.size() == 12 );
-    QVERIFY( !QFile::exists( origPath ) );
-    QVERIFY(QFile::exists(m_trashDir + QString::fromLatin1("/files/") + fileId + QString::fromLatin1("/subdir/subfile")));
-
-    QFile dirCache(m_trashDir + QString::fromLatin1("/directorysizes"));
-    QVERIFY2(dirCache.open(QIODevice::ReadOnly), qPrintable(dirCache.fileName()));
-    QByteArray lines;
-    bool found = false;
-    while (!dirCache.atEnd()) {
-        const QByteArray line = dirCache.readLine();
-        if (line.endsWith(' ' + QFile::encodeName(fileId).toPercentEncoding() + '\n')) {
-            QVERIFY(!found); // should be there only once!
-            found = true;
-        }
-        lines += line;
-    }
-    QVERIFY2(found, lines.constData());
-    //qDebug() << lines;
-
-    checkDirCacheValidity();
-}
-
-void TestTrash::checkDirCacheValidity()
-{
-    QFile dirCache(m_trashDir + QString::fromLatin1("/directorysizes"));
-    QVERIFY2(dirCache.open(QIODevice::ReadOnly), qPrintable(dirCache.fileName()));
-    QSet<QByteArray> seenDirs;
-    while (!dirCache.atEnd()) {
-        QByteArray line = dirCache.readLine();
-        QVERIFY(line.endsWith('\n'));
-        line.chop(1);
-        qDebug() << "LINE" << line;
-        const int lastSpace = line.lastIndexOf(' ');
-        const QByteArray dir = QByteArray::fromPercentEncoding(line.mid(lastSpace + 1));
-        QVERIFY2(!seenDirs.contains(dir), dir.constData());
-        seenDirs.insert(dir);
-        const QString localDir =m_trashDir + QString::fromLatin1("/files/") + QFile::decodeName(dir);
-        QVERIFY2(QFile::exists(localDir), qPrintable(localDir));
-        QVERIFY(QFileInfo(localDir).isDir());
-    }
-}
-
-void TestTrash::trashDirectoryFromHome()
-{
-    QString dirName = QString::fromLatin1("trashDirFromHome");
-    trashDirectory( homeTmpDir() + dirName, dirName );
-    // Do it again, check that we got a different id
-    trashDirectory(homeTmpDir() + dirName, dirName + QString::fromLatin1(" 1"));
-}
-
-void TestTrash::trashDotDirectory()
-{
-    QString dirName = QString::fromLatin1(".dotTrashDirFromHome");
-    trashDirectory( homeTmpDir() + dirName, dirName );
-    // Do it again, check that we got a different id
-    // TODO trashDirectory(homeTmpDir() + dirName, dirName + QString::fromLatin1(" 1"));
-}
-
-void TestTrash::trashReadOnlyDirFromHome()
-{
-    const QString dirName = readOnlyDirPath();
-    QDir dir;
-    bool ok = dir.mkdir( dirName );
-    QVERIFY( ok );
-    // #130780
-    const QString subDirPath = dirName + QString::fromLatin1("/readonly_subdir");
-    ok = dir.mkdir( subDirPath );
-    QVERIFY( ok );
-    createTestFile(subDirPath + QString::fromLatin1("/testfile_in_subdir"));
-    ::chmod( QFile::encodeName( subDirPath ), 0500 );
-
-    trashDirectory(dirName, QString::fromLatin1("readonly"));
-}
-
-void TestTrash::trashDirectoryFromOther()
-{
-    QString dirName = QString::fromLatin1("trashDirFromOther");
-    trashDirectory( otherTmpDir() + dirName, dirName );
-}
-
-void TestTrash::trashDirectoryWithTrailingSlash()
-{
-    QString dirName = QString::fromLatin1("dirwithslash/");
-    trashDirectory(homeTmpDir() + dirName, "dirwithslash");
-}
-
-void TestTrash::tryRenameInsideTrash()
-{
-    qDebug() << " with file_move";
-    KIO::Job* job = KIO::file_move( QUrl("trash:/0-tryRenameInsideTrash"), QUrl("trash:/foobar"), -1, KIO::HideProgressInfo );
-    bool worked = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( !worked );
-    QVERIFY( KIO::NetAccess::lastError() == KIO::ERR_CANNOT_RENAME );
-
-    qDebug() << " with move";
-    job = KIO::move( QUrl("trash:/0-tryRenameInsideTrash"), QUrl("trash:/foobar"), KIO::HideProgressInfo );
-    worked = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( !worked );
-    QVERIFY( KIO::NetAccess::lastError() == KIO::ERR_CANNOT_RENAME );
-}
-
-void TestTrash::delRootFile()
-{
-    // test deleting a trashed file
-    KIO::Job* delJob = KIO::del(QUrl("trash:/0-fileFromHome"), KIO::HideProgressInfo);
-    bool ok = KIO::NetAccess::synchronousRun(delJob, 0);
-    QVERIFY( ok );
-
-    QFileInfo file( m_trashDir + QString::fromLatin1("/files/fileFromHome") );
-    QVERIFY( !file.exists() );
-    QFileInfo info( m_trashDir + QString::fromLatin1("/info/fileFromHome.trashinfo") );
-    QVERIFY( !info.exists() );
-
-    // trash it again, we might need it later
-    const QString fileName = QString::fromLatin1("fileFromHome");
-    trashFile( homeTmpDir() + fileName, fileName );
-}
-
-void TestTrash::delFileInDirectory()
-{
-    // test deleting a file inside a trashed directory -> not allowed
-    KIO::Job* delJob = KIO::del(QUrl("trash:/0-trashDirFromHome/testfile"), KIO::HideProgressInfo);
-    bool ok = KIO::NetAccess::synchronousRun(delJob, 0);
-    QVERIFY( !ok );
-    QVERIFY( KIO::NetAccess::lastError() == KIO::ERR_ACCESS_DENIED );
-
-    QFileInfo dir( m_trashDir + QString::fromLatin1("/files/trashDirFromHome") );
-    QVERIFY( dir.exists() );
-    QFileInfo file( m_trashDir + QString::fromLatin1("/files/trashDirFromHome/testfile") );
-    QVERIFY( file.exists() );
-    QFileInfo info( m_trashDir + QString::fromLatin1("/info/trashDirFromHome.trashinfo") );
-    QVERIFY( info.exists() );
-}
-
-void TestTrash::delDirectory()
-{
-    // test deleting a trashed directory
-    KIO::Job* delJob = KIO::del(QUrl("trash:/0-trashDirFromHome"), KIO::HideProgressInfo);
-    bool ok = KIO::NetAccess::synchronousRun(delJob, 0);
-    QVERIFY( ok );
-
-    QFileInfo dir( m_trashDir + QString::fromLatin1("/files/trashDirFromHome") );
-    QVERIFY( !dir.exists() );
-    QFileInfo file( m_trashDir + QString::fromLatin1("/files/trashDirFromHome/testfile") );
-    QVERIFY( !file.exists() );
-    QFileInfo info( m_trashDir + QString::fromLatin1("/info/trashDirFromHome.trashinfo") );
-    QVERIFY( !info.exists() );
-
-    // trash it again, we'll need it later
-    QString dirName = QString::fromLatin1("trashDirFromHome");
-    trashDirectory( homeTmpDir() + dirName, dirName );
-}
-
-// KIO::NetAccess::stat() doesn't set HideProgressInfo - but it's not much work to do it ourselves:
-static bool MyNetAccess_stat(const QUrl& url, KIO::UDSEntry& entry)
-{
-    KIO::StatJob * statJob = KIO::stat( url, KIO::HideProgressInfo );
-    bool ok = KIO::NetAccess::synchronousRun(statJob, 0);
-    if (ok)
-        entry = statJob->statResult();
-    return ok;
-}
-static bool MyNetAccess_exists(const QUrl& url)
-{
-    KIO::UDSEntry dummy;
-    return MyNetAccess_stat(url, dummy);
-}
-
-void TestTrash::statRoot()
-{
-    QUrl url( "trash:/" );
-    KIO::UDSEntry entry;
-    bool ok = MyNetAccess_stat( url, entry );
-    QVERIFY( ok );
-    KFileItem item( entry, url );
-    QVERIFY( item.isDir() );
-    QVERIFY( !item.isLink() );
-    QVERIFY( item.isReadable() );
-    QVERIFY( item.isWritable() );
-    QVERIFY( !item.isHidden() );
-    QCOMPARE(item.name(), QString::fromLatin1("."));
-}
-
-void TestTrash::statFileInRoot()
-{
-    QUrl url( "trash:/0-fileFromHome" );
-    KIO::UDSEntry entry;
-    bool ok = MyNetAccess_stat( url, entry );
-    QVERIFY( ok );
-    KFileItem item( entry, url );
-    QVERIFY( item.isFile() );
-    QVERIFY( !item.isDir() );
-    QVERIFY( !item.isLink() );
-    QVERIFY( item.isReadable() );
-    QVERIFY( !item.isWritable() );
-    QVERIFY( !item.isHidden() );
-    QCOMPARE(item.text(), QString::fromLatin1("fileFromHome"));
-}
-
-void TestTrash::statDirectoryInRoot()
-{
-    QUrl url( "trash:/0-trashDirFromHome" );
-    KIO::UDSEntry entry;
-    bool ok = MyNetAccess_stat( url, entry );
-    QVERIFY( ok );
-    KFileItem item( entry, url );
-    QVERIFY( item.isDir() );
-    QVERIFY( !item.isLink() );
-    QVERIFY( item.isReadable() );
-    QVERIFY( !item.isWritable() );
-    QVERIFY( !item.isHidden() );
-    QCOMPARE(item.text(), QString::fromLatin1("trashDirFromHome"));
-}
-
-void TestTrash::statSymlinkInRoot()
-{
-    QUrl url( "trash:/0-symlinkFromHome" );
-    KIO::UDSEntry entry;
-    bool ok = MyNetAccess_stat( url, entry );
-    QVERIFY( ok );
-    KFileItem item( entry, url );
-    QVERIFY( item.isLink() );
-    QCOMPARE(item.linkDest(), QString::fromLatin1("/tmp"));
-    QVERIFY( item.isReadable() );
-    QVERIFY( !item.isWritable() );
-    QVERIFY( !item.isHidden() );
-    QCOMPARE(item.text(), QString::fromLatin1("symlinkFromHome"));
-}
-
-void TestTrash::statFileInDirectory()
-{
-    QUrl url( "trash:/0-trashDirFromHome/testfile" );
-    KIO::UDSEntry entry;
-    bool ok = MyNetAccess_stat( url, entry );
-    QVERIFY( ok );
-    KFileItem item( entry, url );
-    QVERIFY( item.isFile() );
-    QVERIFY( !item.isLink() );
-    QVERIFY( item.isReadable() );
-    QVERIFY( !item.isWritable() );
-    QVERIFY( !item.isHidden() );
-    QCOMPARE(item.text(), QString::fromLatin1("testfile"));
-}
-
-void TestTrash::copyFromTrash( const QString& fileId, const QString& destPath, const QString& relativePath )
-{
-    QUrl src(QString::fromLatin1("trash:/0-") + fileId);
-    if ( !relativePath.isEmpty() )
-        src.setPath(src.path() + '/' + relativePath);
-    QUrl dest = QUrl::fromLocalFile( destPath );
-
-    QVERIFY(MyNetAccess_exists(src));
-
-    // A dnd would use copy(), but we use copyAs to ensure the final filename
-    //qDebug() << "copyAs:" << src << " -> " << dest;
-    KIO::Job* job = KIO::copyAs( src, dest, KIO::HideProgressInfo );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( ok );
-    QString infoFile( m_trashDir + QString::fromLatin1("/info/") + fileId + QString::fromLatin1(".trashinfo") );
-    QVERIFY( QFile::exists(infoFile) );
-
-    QFileInfo filesItem( m_trashDir + QString::fromLatin1("/files/") + fileId );
-    QVERIFY( filesItem.exists() );
-
-    QVERIFY( QFile::exists(destPath) );
-}
-
-void TestTrash::copyFileFromTrash()
-{
-// To test case of already-existing destination, uncomment this.
-// This brings up the "rename" dialog though, so it can't be fully automated
-#if 0
-    const QString destPath = otherTmpDir() + QString::fromLatin1("fileFromHome_copied");
-    copyFromTrash( "fileFromHome", destPath );
-    QVERIFY( QFileInfo( destPath ).isFile() );
-    QVERIFY( QFileInfo( destPath ).size() == 12 );
-#endif
-}
-
-void TestTrash::copyFileInDirectoryFromTrash()
-{
-    const QString destPath = otherTmpDir() + QString::fromLatin1("testfile_copied");
-    copyFromTrash(QString::fromLatin1("trashDirFromHome"), destPath, QString::fromLatin1("testfile"));
-    QVERIFY( QFileInfo( destPath ).isFile() );
-    QVERIFY( QFileInfo( destPath ).size() == 12 );
-}
-
-void TestTrash::copyDirectoryFromTrash()
-{
-    const QString destPath = otherTmpDir() + QString::fromLatin1("trashDirFromHome_copied");
-    copyFromTrash(QString::fromLatin1("trashDirFromHome"), destPath);
-    QVERIFY( QFileInfo( destPath ).isDir() );
-    QVERIFY(QFile::exists(destPath + "/testfile"));
-    QVERIFY(QFile::exists(destPath + "/subdir/subfile"));
-}
-
-void TestTrash::copySymlinkFromTrash()
-{
-    const QString destPath = otherTmpDir() + QString::fromLatin1("symlinkFromHome_copied");
-    copyFromTrash(QString::fromLatin1("symlinkFromHome"), destPath);
-    QVERIFY( QFileInfo( destPath ).isSymLink() );
-}
-
-void TestTrash::moveFromTrash( const QString& fileId, const QString& destPath, const QString& relativePath )
-{
-    QUrl src( QString::fromLatin1("trash:/0-") + fileId );
-    if ( !relativePath.isEmpty() )
-        src.setPath(src.path() + '/' + relativePath);
-    QUrl dest = QUrl::fromLocalFile( destPath );
-
-    QVERIFY(MyNetAccess_exists(src));
-
-    // A dnd would use move(), but we use moveAs to ensure the final filename
-    KIO::Job* job = KIO::moveAs( src, dest, KIO::HideProgressInfo );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( ok );
-    QString infoFile( m_trashDir + "/info/" + fileId + ".trashinfo" );
-    QVERIFY( !QFile::exists( infoFile ) );
-
-    QFileInfo filesItem( m_trashDir + "/files/" + fileId );
-    QVERIFY( !filesItem.exists() );
-
-    QVERIFY( QFile::exists( destPath ) );
-}
-
-void TestTrash::moveFileFromTrash()
-{
-    const QString destPath = otherTmpDir() + "fileFromHome_restored";
-    moveFromTrash( "fileFromHome", destPath );
-    QVERIFY( QFileInfo( destPath ).isFile() );
-    QVERIFY( QFileInfo( destPath ).size() == 12 );
-
-    // trash it again for later
-    const QString fileName = "fileFromHome";
-    trashFile( homeTmpDir() + fileName, fileName );
-}
-
-void TestTrash::moveFileInDirectoryFromTrash()
-{
-    const QString destPath = otherTmpDir() + "testfile_restored";
-    copyFromTrash( "trashDirFromHome", destPath, "testfile" );
-    QVERIFY( QFileInfo( destPath ).isFile() );
-    QVERIFY( QFileInfo( destPath ).size() == 12 );
-}
-
-void TestTrash::moveDirectoryFromTrash()
-{
-    const QString destPath = otherTmpDir() + "trashDirFromHome_restored";
-    moveFromTrash( "trashDirFromHome", destPath );
-    QVERIFY( QFileInfo( destPath ).isDir() );
-    checkDirCacheValidity();
-
-    // trash it again, we'll need it later
-    QString dirName = "trashDirFromHome";
-    trashDirectory( homeTmpDir() + dirName, dirName );
-}
-
-void TestTrash::trashDirectoryOwnedByRoot()
-{
-    QUrl u("file:///");;
-    if ( QFile::exists( "/etc/cups" ) )
-        u.setPath( "/etc/cups" );
-    else if ( QFile::exists( "/boot" ) )
-        u.setPath( "/boot" );
-    else
-        u.setPath( "/etc" );
-    const QString fileId = u.path();
-    qDebug() << "fileId=" << fileId;
-
-    KIO::CopyJob* job = KIO::move( u, QUrl("trash:/"), KIO::HideProgressInfo );
-    job->setUiDelegate(0); // no skip dialog, thanks
-    QMap<QString, QString> metaData;
-    bool ok = KIO::NetAccess::synchronousRun( job, 0, 0, 0, &metaData );
-    QVERIFY( !ok );
-    const int err = KIO::NetAccess::lastError();
-    QVERIFY( err == KIO::ERR_ACCESS_DENIED
-            || err == KIO::ERR_CANNOT_OPEN_FOR_READING );
-
-    const QString infoPath( m_trashDir + "/info/" + fileId + ".trashinfo" );
-    QVERIFY( !QFile::exists( infoPath ) );
-
-    QFileInfo files( m_trashDir + "/files/" + fileId );
-    QVERIFY( !files.exists() );
-
-    QVERIFY( QFile::exists( u.path() ) );
-}
-
-void TestTrash::moveSymlinkFromTrash()
-{
-    const QString destPath = otherTmpDir() + "symlinkFromHome_restored";
-    moveFromTrash( "symlinkFromHome", destPath );
-    QVERIFY( QFileInfo( destPath ).isSymLink() );
-}
-
-void TestTrash::getFile()
-{
-    const QString fileId = "fileFromHome 1";
-    const QUrl url = TrashImpl::makeURL( 0, fileId, QString() );
-
-    KTemporaryFile tmpFile;
-    QVERIFY(tmpFile.open());
-    const QString tmpFilePath = tmpFile.fileName();
-
-    KIO::Job* getJob = KIO::file_copy(url, QUrl::fromLocalFile(tmpFilePath), -1, KIO::Overwrite | KIO::HideProgressInfo);
-    bool ok = KIO::NetAccess::synchronousRun(getJob, 0);
-    if (!ok) {
-        qDebug() << getJob->errorString();
-    }
-    QVERIFY( ok );
-    // Don't use tmpFile.close()+tmpFile.open() here, the size would still be 0 in the QTemporaryFile object
-    // (due to the use of fstat on the old fd). Arguably a bug (I even have a testcase), but probably
-    // not fixable without breaking the security of QTemporaryFile...
-    QFile reader(tmpFilePath);
-    QVERIFY(reader.open(QIODevice::ReadOnly));
-    QByteArray str = reader.readAll();
-    QCOMPARE(str, QByteArray("Hello world\n"));
-}
-
-void TestTrash::restoreFile()
-{
-    const QString fileId = "fileFromHome 1";
-    const QUrl url = TrashImpl::makeURL( 0, fileId, QString() );
-    const QString infoFile( m_trashDir + "/info/" + fileId + ".trashinfo" );
-    const QString filesItem( m_trashDir + "/files/" + fileId );
-
-    QVERIFY( QFile::exists( infoFile ) );
-    QVERIFY( QFile::exists( filesItem ) );
-
-    QByteArray packedArgs;
-    QDataStream stream( &packedArgs, QIODevice::WriteOnly );
-    stream << (int)3 << url;
-    KIO::Job* job = KIO::special( url, packedArgs, KIO::HideProgressInfo );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( ok );
-
-    QVERIFY( !QFile::exists( infoFile ) );
-    QVERIFY( !QFile::exists( filesItem ) );
-
-    const QString destPath = homeTmpDir() + "fileFromHome";
-    QVERIFY( QFile::exists( destPath ) );
-}
-
-void TestTrash::restoreFileFromSubDir()
-{
-    const QString fileId = "trashDirFromHome 1/testfile";
-    QVERIFY( !QFile::exists( homeTmpDir() + "trashDirFromHome 1" ) );
-
-    const QUrl url = TrashImpl::makeURL( 0, fileId, QString() );
-    const QString infoFile( m_trashDir + "/info/trashDirFromHome 1.trashinfo" );
-    const QString filesItem( m_trashDir + "/files/trashDirFromHome 1/testfile" );
-
-    QVERIFY( QFile::exists( infoFile ) );
-    QVERIFY( QFile::exists( filesItem ) );
-
-    QByteArray packedArgs;
-    QDataStream stream( &packedArgs, QIODevice::WriteOnly );
-    stream << (int)3 << url;
-    KIO::Job* job = KIO::special( url, packedArgs, KIO::HideProgressInfo );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( !ok );
-    // dest dir doesn't exist -> error message
-    QVERIFY( KIO::NetAccess::lastError() == KIO::ERR_SLAVE_DEFINED );
-
-    // check that nothing happened
-    QVERIFY( QFile::exists( infoFile ) );
-    QVERIFY( QFile::exists( filesItem ) );
-    QVERIFY( !QFile::exists( homeTmpDir() + "trashDirFromHome 1" ) );
-}
-
-void TestTrash::restoreFileToDeletedDirectory()
-{
-    // Ensure we'll get "fileFromHome" as fileId
-    removeFile( m_trashDir, "/info/fileFromHome.trashinfo" );
-    removeFile( m_trashDir, "/files/fileFromHome" );
-    trashFileFromHome();
-    // Delete orig dir
-    KIO::Job* delJob = KIO::del(QUrl::fromLocalFile(homeTmpDir()), KIO::HideProgressInfo);
-    bool delOK = KIO::NetAccess::synchronousRun(delJob, 0);
-    QVERIFY( delOK );
-
-    const QString fileId = "fileFromHome";
-    const QUrl url = TrashImpl::makeURL( 0, fileId, QString() );
-    const QString infoFile( m_trashDir + "/info/" + fileId + ".trashinfo" );
-    const QString filesItem( m_trashDir + "/files/" + fileId );
-
-    QVERIFY( QFile::exists( infoFile ) );
-    QVERIFY( QFile::exists( filesItem ) );
-
-    QByteArray packedArgs;
-    QDataStream stream( &packedArgs, QIODevice::WriteOnly );
-    stream << (int)3 << url;
-    KIO::Job* job = KIO::special( url, packedArgs, KIO::HideProgressInfo );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( !ok );
-    // dest dir doesn't exist -> error message
-    QVERIFY( KIO::NetAccess::lastError() == KIO::ERR_SLAVE_DEFINED );
-
-    // check that nothing happened
-    QVERIFY( QFile::exists( infoFile ) );
-    QVERIFY( QFile::exists( filesItem ) );
-
-    const QString destPath = homeTmpDir() + "fileFromHome";
-    QVERIFY( !QFile::exists( destPath ) );
-}
-
-void TestTrash::listRootDir()
-{
-    m_entryCount = 0;
-    m_listResult.clear();
-    m_displayNameListResult.clear();
-    KIO::ListJob* job = KIO::listDir( QUrl("trash:/"), KIO::HideProgressInfo );
-    connect( job, SIGNAL( entries( KIO::Job*, const KIO::UDSEntryList& ) ),
-             SLOT( slotEntries( KIO::Job*, const KIO::UDSEntryList& ) ) );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( ok );
-    qDebug() << "listDir done - m_entryCount=" << m_entryCount;
-    QVERIFY( m_entryCount > 1 );
-
-    //qDebug() << m_listResult;
-    //qDebug() << m_displayNameListResult;
-    QCOMPARE(m_listResult.count( "." ), 1); // found it, and only once
-    QCOMPARE(m_displayNameListResult.count( "fileFromHome" ), 1);
-    QCOMPARE(m_displayNameListResult.count( "fileFromHome 1" ), 1);
-}
-
-void TestTrash::listRecursiveRootDir()
-{
-    m_entryCount = 0;
-    m_listResult.clear();
-    m_displayNameListResult.clear();
-    KIO::ListJob* job = KIO::listRecursive( QUrl("trash:/"), KIO::HideProgressInfo );
-    connect( job, SIGNAL( entries( KIO::Job*, const KIO::UDSEntryList& ) ),
-             SLOT( slotEntries( KIO::Job*, const KIO::UDSEntryList& ) ) );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( ok );
-    qDebug() << "listDir done - m_entryCount=" << m_entryCount;
-    QVERIFY( m_entryCount > 1 );
-
-    qDebug() << m_listResult;
-    qDebug() << m_displayNameListResult;
-    QCOMPARE(m_listResult.count( "." ), 1); // found it, and only once
-    QCOMPARE(m_listResult.count("0-fileFromHome"), 1);
-    QCOMPARE(m_listResult.count("0-fileFromHome 1"), 1);
-    QCOMPARE(m_listResult.count("0-trashDirFromHome/testfile"), 1);
-    QCOMPARE(m_listResult.count("0-readonly/readonly_subdir/testfile_in_subdir"), 1);
-    QCOMPARE(m_displayNameListResult.count("fileFromHome"), 1);
-    QCOMPARE(m_displayNameListResult.count("fileFromHome 1"), 1);
-    QCOMPARE(m_displayNameListResult.count("trashDirFromHome/testfile"), 1);
-    QCOMPARE(m_displayNameListResult.count("readonly/readonly_subdir/testfile_in_subdir"), 1);
-    
-}
-
-void TestTrash::listSubDir()
-{
-    m_entryCount = 0;
-    m_listResult.clear();
-    m_displayNameListResult.clear();
-    KIO::ListJob* job = KIO::listDir( QUrl("trash:/0-trashDirFromHome"), KIO::HideProgressInfo );
-    connect( job, SIGNAL( entries( KIO::Job*, const KIO::UDSEntryList& ) ),
-             SLOT( slotEntries( KIO::Job*, const KIO::UDSEntryList& ) ) );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( ok );
-    qDebug() << "listDir done - m_entryCount=" << m_entryCount;
-    QCOMPARE(m_entryCount, 3);
-
-    //qDebug() << m_listResult;
-    //qDebug() << m_displayNameListResult;
-    QCOMPARE(m_listResult.count( "." ), 1); // found it, and only once
-    QCOMPARE(m_listResult.count( "testfile" ), 1); // found it, and only once
-    QCOMPARE(m_listResult.count("subdir"), 1);
-    QCOMPARE(m_displayNameListResult.count("testfile"), 1);
-    QCOMPARE(m_displayNameListResult.count("subdir"), 1);
-}
-
-void TestTrash::slotEntries( KIO::Job*, const KIO::UDSEntryList& lst )
-{
-    for( KIO::UDSEntryList::ConstIterator it = lst.begin(); it != lst.end(); ++it ) {
-        const KIO::UDSEntry& entry (*it);
-        QString name = entry.stringValue(KIO::UDSEntry::UDS_NAME);
-        QString displayName = entry.stringValue(KIO::UDSEntry::UDS_DISPLAY_NAME);
-        QUrl url(entry.stringValue( KIO::UDSEntry::UDS_URL ));
-        qDebug() << "name" << name << "displayName" << displayName << " UDS_URL=" << url;
-        if ( !url.isEmpty() ) {
-            QVERIFY( url.scheme() == "trash" );
-        }
-        m_listResult << name;
-        m_displayNameListResult << displayName;
-    }
-    m_entryCount += lst.count();
-}
-
-void TestTrash::emptyTrash()
-{
-    // ## Even though we use a custom XDG_DATA_HOME value, emptying the
-    // trash would still empty the other trash directories in other partitions.
-    // So we can't activate this test by default.
-#if 0
-
-    // To make this test standalone
-    trashFileFromHome();
-
-    // #167051: orphaned files
-    createTestFile( m_trashDir + "/files/testfile_nometadata" );
-
-    QByteArray packedArgs;
-    QDataStream stream( &packedArgs, QIODevice::WriteOnly );
-    stream << (int)1;
-    KIO::Job* job = KIO::special( QUrl( "trash:/" ), packedArgs, KIO::HideProgressInfo );
-    bool ok = KIO::NetAccess::synchronousRun( job, 0 );
-    QVERIFY( ok );
-
-    KConfig cfg( "trashrc", KConfig::SimpleConfig );
-    QVERIFY( cfg.hasGroup( "Status" ) );
-    QVERIFY( cfg.group("Status").readEntry( "Empty", false ) == true );
-
-    QVERIFY( !QFile::exists( m_trashDir + "/files/fileFromHome" ) );
-    QVERIFY( !QFile::exists( m_trashDir + "/files/readonly" ) );
-    QVERIFY( !QFile::exists( m_trashDir + "/info/readonly.trashinfo" ) );
-    QVERIFY(QDir(m_trashDir + "/info").entryList(QDir::NoDotAndDotDot|QDir::AllEntries).isEmpty());
-    QVERIFY(QDir(m_trashDir + "/files").entryList(QDir::NoDotAndDotDot|QDir::AllEntries).isEmpty());
-
-#else
-    qDebug() << " : SKIPPED";
-#endif
-}
-
-void TestTrash::testEmptyTrashSize()
-{
-    KIO::DirectorySizeJob* job = KIO::directorySize(QUrl("trash:/"));
-    QVERIFY(job->exec());
-    QVERIFY(job->totalSize() < 1000000000 /*1GB*/); // #157023
-}
-
-static void checkIcon( const QUrl& url, const QString& expectedIcon )
-{
-    QString icon = KIO::iconNameForUrl( url );
-    QCOMPARE( icon, expectedIcon );
-}
-
-void TestTrash::testIcons()
-{
-    QCOMPARE(KProtocolInfo::icon("trash"), QString("user-trash-full") ); // #100321
-    checkIcon( QUrl("trash:/"), "user-trash-full" ); // #100321
-    checkIcon( QUrl("trash:/foo/"), "inode-directory" );
-}
-
-QTEST_MAIN(TestTrash) // QT5 TODO: NOGUI
-
-#include "testtrash.moc"
diff --git a/trash/tests/testtrash.h b/trash/tests/testtrash.h
deleted file mode 100644
index 3f5063e..0000000
--- a/trash/tests/testtrash.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef TESTTRASH_H
-#define TESTTRASH_H
-
-#include <QObject>
-
-#include <KIO/Job>
-
-class TestTrash : public QObject
-{
-    Q_OBJECT
-
-public:
-    TestTrash() {}
-
-private Q_SLOTS:
-    void initTestCase();
-    void cleanupTestCase();
-
-    void testIcons();
-
-    void urlTestFile();
-    void urlTestDirectory();
-    void urlTestSubDirectory();
-
-    void trashFileFromHome();
-    void trashPercentFileFromHome();
-    void trashUtf8FileFromHome();
-    void trashUmlautFileFromHome();
-    void testTrashNotEmpty();
-    void trashFileFromOther();
-    void trashFileIntoOtherPartition();
-    void trashFileOwnedByRoot();
-    void trashSymlinkFromHome();
-    void trashSymlinkFromOther();
-    void trashBrokenSymlinkFromHome();
-    void trashDirectoryFromHome();
-    void trashDotDirectory();
-    void trashReadOnlyDirFromHome();
-    void trashDirectoryFromOther();
-    void trashDirectoryOwnedByRoot();
-    void trashDirectoryWithTrailingSlash();
-
-    void tryRenameInsideTrash();
-
-    void statRoot();
-    void statFileInRoot();
-    void statDirectoryInRoot();
-    void statSymlinkInRoot();
-    void statFileInDirectory();
-
-    void copyFileFromTrash();
-    void copyFileInDirectoryFromTrash();
-    void copyDirectoryFromTrash();
-    void copySymlinkFromTrash();
-
-    void moveFileFromTrash();
-    void moveFileInDirectoryFromTrash();
-    void moveDirectoryFromTrash();
-    void moveSymlinkFromTrash();
-
-    void listRootDir();
-    void listRecursiveRootDir();
-    void listSubDir();
-
-    void delRootFile();
-    void delFileInDirectory();
-    void delDirectory();
-
-    void getFile();
-    void restoreFile();
-    void restoreFileFromSubDir();
-    void restoreFileToDeletedDirectory();
-
-    void emptyTrash();
-    void testEmptyTrashSize();
-
-protected Q_SLOTS:
-    void slotEntries( KIO::Job*, const KIO::UDSEntryList& );
-
-private:
-    void trashFile( const QString& origFilePath, const QString& fileId );
-    void trashSymlink( const QString& origFilePath, const QString& fileName, bool broken );
-    void trashDirectory( const QString& origPath, const QString& fileName );
-    void copyFromTrash( const QString& fileId, const QString& destPath, const QString& relativePath = QString() );
-    void moveFromTrash( const QString& fileId, const QString& destPath, const QString& relativePath = QString() );
-    void checkDirCacheValidity();
-
-    QString homeTmpDir() const;
-    QString otherTmpDir() const;
-    QString utf8FileName() const;
-    QString umlautFileName() const;
-    QString readOnlyDirPath() const;
-
-    QString m_trashDir;
-
-    QString m_otherPartitionTopDir;
-    QString m_otherPartitionTrashDir;
-    bool m_tmpIsWritablePartition;
-    int m_tmpTrashId;
-    int m_otherPartitionId;
-
-    int m_entryCount;
-    QStringList m_listResult;
-    QStringList m_displayNameListResult;
-};
-
-#endif
diff --git a/trash/trash.protocol b/trash/trash.protocol
deleted file mode 100644
index 2776985..0000000
--- a/trash/trash.protocol
+++ /dev/null
@@ -1,111 +0,0 @@
-[Protocol]
-exec=kio_trash
-protocol=trash
-input=none
-output=filesystem
-# AccessDate doesn't make sense.
-# OTOH we need deletion date :)
-listing=Name,Type,Size,Extra1,Extra2,Date,Access,Owner,Group,Link
-reading=true
-writing=true
-makedir=false
-deleting=true
-linking=false
-moving=true
-Icon=user-trash-full
-maxInstances=2
-Class=:local
-renameFromFile=true
-renameToFile=true
-copyFromFile=true
-copyToFile=true
-deleteRecursive=true
-fileNameUsedForCopying=DisplayName
-#TODO DocPath
-ExtraNames=Original Path,Deletion Date
-ExtraNames[af]=Oorspronklike gids, Uitvee-datum
-ExtraNames[ar]=المسار الأصلي, تاريخ الحذف
-ExtraNames[ast]=Camín orixinal,Data de desaniciu
-ExtraNames[be]=Арыгінальнае месцазнаходжанне,Час выдалення
-ExtraNames[be@latin]=Byłaja ściežka,data vydaleńnia
-ExtraNames[bg]=Местоположение,Дата на изтриване
-ExtraNames[bn]=পূর্বতন পাথ, মোছার তারিখ
-ExtraNames[bn_IN]=মূল অবস্থানের পাথ, অপসারণের তারিখ
-ExtraNames[bs]=prvobitna putanja,datum brisanja
-ExtraNames[ca]=Camí original,Data d'esborrat
-ExtraNames[ca@valencia]=Camí original,Data d'esborrat
-ExtraNames[cs]=Původní cesta,Datum smazání
-ExtraNames[csb]=Òriginalnô stegna,Datum remniãcô
-ExtraNames[da]=Original sti, sletningsdato
-ExtraNames[de]=Ursprünglicher Pfad, Löschzeitpunkt
-ExtraNames[el]=Αρχική διαδρομή,Ημερομηνία διαγραφής
-ExtraNames[en_GB]=Original Path,Deletion Date
-ExtraNames[eo]=Origina vojo,Foriga dato
-ExtraNames[es]=Ruta original,Fecha de borrado
-ExtraNames[et]=Algne asukoht,Kustutamisaeg
-ExtraNames[eu]=Jatorrizko bide-izena, ezabatze-data
-ExtraNames[fa]=مسیر اصلی، تاریخ حذف
-ExtraNames[fi]=Alkuperäinen polku, poistopäivä
-ExtraNames[fr]=Emplacement d'origine, date de suppression
-ExtraNames[fy]=Oarspronklike lokaasje,datum fan wiskjen
-ExtraNames[ga]=Bunchonair,Dáta Scriosta
-ExtraNames[gl]=Ruta orixinal,Data de eliminación
-ExtraNames[gu]=મૂળભૂત પાથ,દૂર કરવાની તારીખ
-ExtraNames[he]=נתיב מקורי,תאריך מחיקה
-ExtraNames[hi]=मूल पथ, मिटाने की तिथि
-ExtraNames[hne]=मूल पथ, मेटाव के तारीक
-ExtraNames[hr]=Izvorna putanja,Datum brisanja
-ExtraNames[hsb]=Originalny puć, datum zničenja
-ExtraNames[hu]=Eredeti elérési út,Törlési dátum
-ExtraNames[ia]=Percurso original, Data de Cancellation
-ExtraNames[id]=Alamat Asli,Tanggal Penghapusan
-ExtraNames[is]=Upprunaleg slóð,dagsetning á eyðingu
-ExtraNames[it]=Percorso originale,data di eliminazione
-ExtraNames[ja]=元のパス,削除日
-ExtraNames[ka]=საწყისი გეზი, წაშლის თარიღი
-ExtraNames[kk]=Бұрынғы орны,Өшірілген кезі
-ExtraNames[km]=ផ្លូវដើម ការ​លុប​កាល​បរិច្ឆេទ
-ExtraNames[kn]=ಮೂಲ ಪಥ (ಪಾತ್), ಅಳಿಸಿಹಾಕುವಿಕೆಯ ದಿನಾಂಕ
-ExtraNames[ko]=원본 경로,삭제 날짜
-ExtraNames[ku]=Rêça Resen,Jêbirina Mêjûyê
-ExtraNames[lt]=Originalus kelias,Trynimo data
-ExtraNames[lv]=Orģinālais ceļš,Dzēšanas datums
-ExtraNames[mai]=मूल पथ, मेटाबै कए तिथि
-ExtraNames[mk]=Оригинална патека,Датум на бришење
-ExtraNames[ml]=നേരത്തെയുണ്ടായിരുന്ന വഴി,നീക്കം ചെയ്ത തിയ്യതി
-ExtraNames[mr]=मूळ मार्ग, काढून टाकण्याचा दिनांक
-ExtraNames[ms]=Laluan Asli, Tarikh Penghapusan
-ExtraNames[nb]=Opprinnelig sti, slettedato
-ExtraNames[nds]=Orginaalpadd,Wegdodatum
-ExtraNames[ne]=मौलिक मार्ग, मेट्ने मिति
-ExtraNames[nl]=Oorspronkelijke locatie,Datum van verwijdering
-ExtraNames[nn]=Opprinneleg sti, slettedato
-ExtraNames[or]=ପ୍ରକୃତ ପଥ, ଅପସାରଣ ତାରିଖ
-ExtraNames[pa]=ਅਸਲੀ ਮਾਰਗ,ਹਟਾਉਣ ਮਿਤੀ
-ExtraNames[pl]=Ścieżka oryginalna,Data usunięcia
-ExtraNames[pt]=Localização Original,Data de Remoção
-ExtraNames[pt_BR]=Caminho original, data da remoção
-ExtraNames[ro]=Calea originală,data ștergerii
-ExtraNames[ru]=Исходный путь, дата удаления
-ExtraNames[se]=Álgovuolggálaš bálggis,sihkkundáhton
-ExtraNames[si]=මූලික මාර්ගය, මකාදැමීමේ දිනය
-ExtraNames[sk]=Pôvodné umiestnenie,Dátum odstránenia
-ExtraNames[sl]=Prvotna pot,Datum izbrisa
-ExtraNames[sr]=првобитна путања,датум брисања
-ExtraNames[sr@ijekavian]=првобитна путања,датум брисања
-ExtraNames[sr@ijekavianlatin]=prvobitna putanja,datum brisanja
-ExtraNames[sr@latin]=prvobitna putanja,datum brisanja
-ExtraNames[sv]=Ursprunglig sökväg,Borttagsdatum
-ExtraNames[ta]=மூலப் பாதை,அகற்றப்பட்ட தேதி
-ExtraNames[te]=అసలు దారు, తీసివేసిన తేది
-ExtraNames[tg]=Роҳчаи аслӣ, Санаи несткунӣ
-ExtraNames[th]=พาธเดิม,วันที่ที่ลบ
-ExtraNames[tr]=Orijinal Yol, Silinme Tarihi
-ExtraNames[ug]=ئەسلى يولى، ئۆچۈرۈلگەن ۋاقتى
-ExtraNames[uk]=Шлях,Дата вилучення
-ExtraNames[vi]=Đường dẫn gốc,Ngày xoá
-ExtraNames[wa]=Tchimin do cominçmint, Date di disfaçaedje
-ExtraNames[x-test]=xxOriginal Path,Deletion Datexx
-ExtraNames[zh_CN]=原始路径,删除日期
-ExtraNames[zh_TW]=原始路徑,刪除日期
-ExtraTypes=QString,QDateTime
diff --git a/trash/trashimpl.cpp b/trash/trashimpl.cpp
deleted file mode 100644
index 224a1e8..0000000
--- a/trash/trashimpl.cpp
+++ /dev/null
@@ -1,1167 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#define QT_NO_CAST_FROM_ASCII
-
-#include "trashimpl.h"
-#include "discspaceutil.h"
-#include "trashsizecache.h"
-
-#include <klocale.h>
-#include <kde_file.h>
- #include <KLocalizedString>
-#include <kio/global.h>
-#include <kio/job.h>
-#include <kio/chmodjob.h>
-#include <kio/copyjob.h>
-#include <kio/deletejob.h>
-#include <qdebug.h>
-#include <QUrl>
-#include <kdirnotify.h>
-#include <kglobal.h>
-#include <kstandarddirs.h>
-#include <kglobalsettings.h>
-#include <kfileitem.h>
-#include <kconfiggroup.h>
-#include <kmountpoint.h>
-
-#include <QEventLoop>
-#include <QFile>
-#include <QDir>
-#include <kjobuidelegate.h>
-
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/param.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <stdlib.h>
-#include <errno.h>
-
-#include <solid/device.h>
-#include <solid/block.h>
-#include <solid/storageaccess.h>
-#include <QStandardPaths>
-
-TrashImpl::TrashImpl() :
-    QObject(),
-    m_lastErrorCode( 0 ),
-    m_initStatus( InitToBeDone ),
-    m_homeDevice( 0 ),
-    m_trashDirectoriesScanned( false ),
-    // not using kio_trashrc since KIO uses that one already for kio_trash
-    // so better have a separate one, for faster parsing by e.g. kmimetype.cpp
-    m_config(QString::fromLatin1("trashrc"), KConfig::SimpleConfig)
-{
-    KDE_struct_stat buff;
-    if ( KDE_lstat( QFile::encodeName( QDir::homePath() ), &buff ) == 0 ) {
-        m_homeDevice = buff.st_dev;
-    } else {
-        qDebug() << "Should never happen: couldn't stat $HOME " << strerror( errno ) << endl;
-    }
-}
-
-/**
- * Test if a directory exists, create otherwise
- * @param _name full path of the directory
- * @return errorcode, or 0 if the dir was created or existed already
- * Warning, don't use return value like a bool
- */
-int TrashImpl::testDir( const QString &_name ) const
-{
-  DIR *dp = opendir( QFile::encodeName(_name) );
-  if ( dp == NULL )
-  {
-    QString name = _name;
-    if (name.endsWith(QLatin1Char('/')))
-      name.truncate( name.length() - 1 );
-    QByteArray path = QFile::encodeName(name);
-
-    bool ok = KDE_mkdir( path, S_IRWXU ) == 0;
-    if ( !ok && errno == EEXIST ) {
-#if 0 // this would require to use SlaveBase's method to ask the question
-        //int ret = KMessageBox::warningYesNo( 0, i18n("%1 is a file, but KDE needs it to be a directory. Move it to %2.orig and create directory?").arg(name).arg(name) );
-        //if ( ret == KMessageBox::Yes ) {
-#endif
-            QByteArray new_path = path;
-            path.append(QByteArray(".orig"));
-            if ( KDE_rename( path, new_path) == 0 ) {
-                ok = KDE_mkdir( path, S_IRWXU ) == 0;
-            } else { // foo.orig existed already. How likely is that?
-                ok = false;
-            }
-            if ( !ok ) {
-                return KIO::ERR_DIR_ALREADY_EXIST;
-            }
-#if 0
-        //} else {
-        //    return 0;
-        //}
-#endif
-    }
-    if ( !ok )
-    {
-        //KMessageBox::sorry( 0, i18n( "Could not create directory %1. Check for permissions." ).arg( name ) );
-        qWarning() << "could not create" << name ;
-        return KIO::ERR_COULD_NOT_MKDIR;
-    } else {
-        qDebug() << name << "created.";
-    }
-  }
-  else // exists already
-  {
-    closedir( dp );
-  }
-  return 0; // success
-}
-
-bool TrashImpl::init()
-{
-    if ( m_initStatus == InitOK )
-        return true;
-    if ( m_initStatus == InitError )
-        return false;
-
-    // Check the trash directory and its info and files subdirs
-    // see also kdesktop/init.cc for first time initialization
-    m_initStatus = InitError;
-    // $XDG_DATA_HOME/Trash, i.e. ~/.local/share/Trash by default.
-    const QString xdgDataDir = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1Char('/');
-   if ( !QDir().mkpath( xdgDataDir ) ) {
-        qWarning() << "failed to create " << xdgDataDir ;
-        return false;
-    }
-
-    const QString trashDir = xdgDataDir + QString::fromLatin1("Trash");
-    int err;
-    if ( ( err = testDir( trashDir ) ) ) {
-        error( err, trashDir );
-        return false;
-    }
-    if ( ( err = testDir( trashDir + QString::fromLatin1("/info") ) ) ) {
-        error( err, trashDir + QString::fromLatin1("/info") );
-        return false;
-    }
-    if ( ( err = testDir( trashDir + QString::fromLatin1("/files") ) ) ) {
-        error( err, trashDir + QString::fromLatin1("/files") );
-        return false;
-    }
-    m_trashDirectories.insert( 0, trashDir );
-    m_initStatus = InitOK;
-    qDebug() << "initialization OK, home trash dir: " << trashDir;
-    return true;
-}
-
-void TrashImpl::migrateOldTrash()
-{
-    qDebug() ;
-
-    KConfigGroup g( KSharedConfig::openConfig(), "Paths" );
-    const QString oldTrashDir = g.readPathEntry( "Trash", QString() );
-
-    if ( oldTrashDir.isEmpty() )
-        return;
-
-    const QStringList entries = listDir( oldTrashDir );
-    bool allOK = true;
-    for ( QStringList::const_iterator entryIt = entries.begin(), entryEnd = entries.end();
-          entryIt != entryEnd ; ++entryIt )
-    {
-        QString srcPath = *entryIt;
-        if ( srcPath == QLatin1String(".") || srcPath == QLatin1String("..") || srcPath == QLatin1String(".directory") )
-            continue;
-        srcPath.prepend( oldTrashDir ); // make absolute
-        int trashId;
-        QString fileId;
-        if ( !createInfo( srcPath, trashId, fileId ) ) {
-            qWarning() << "Trash migration: failed to create info for " << srcPath ;
-            allOK = false;
-        } else {
-            bool ok = moveToTrash( srcPath, trashId, fileId );
-            if ( !ok ) {
-                (void)deleteInfo( trashId, fileId );
-                qWarning() << "Trash migration: failed to create info for " << srcPath ;
-                allOK = false;
-            } else {
-                qDebug() << "Trash migration: moved " << srcPath;
-            }
-        }
-    }
-    if ( allOK ) {
-        // We need to remove the old one, otherwise the desktop will have two trashcans...
-        qDebug() << "Trash migration: all OK, removing old trash directory";
-        synchronousDel( oldTrashDir, false, true );
-    }
-}
-
-bool TrashImpl::createInfo( const QString& origPath, int& trashId, QString& fileId )
-{
-    qDebug() << origPath;
-    // Check source
-    const QByteArray origPath_c( QFile::encodeName( origPath ) );
-
-    // off_t should be 64bit on Unix systems to have large file support
-    // FIXME: on windows this gets disabled until trash gets integrated
-    // BUG: 165449
-#ifndef Q_OS_WIN
-    Q_STATIC_ASSERT(sizeof(off_t) >= 8);
-#endif
-
-    KDE_struct_stat buff_src;
-    if ( KDE_lstat( origPath_c.data(), &buff_src ) == -1 ) {
-        if ( errno == EACCES )
-           error( KIO::ERR_ACCESS_DENIED, origPath );
-        else
-           error( KIO::ERR_DOES_NOT_EXIST, origPath );
-        return false;
-    }
-
-    // Choose destination trash
-    trashId = findTrashDirectory( origPath );
-    if ( trashId < 0 ) {
-        qWarning() << "OUCH - internal error, TrashImpl::findTrashDirectory returned " << trashId ;
-        return false; // ### error() needed?
-    }
-    qDebug() << "trashing to " << trashId;
-
-    // Grab original filename
-    QUrl url = QUrl::fromLocalFile( origPath );
-    url = url.adjusted(QUrl::StripTrailingSlash);
-    const QString origFileName = url.fileName();
-
-    // Make destination file in info/
-    url.setPath( infoPath( trashId, origFileName ) ); // we first try with origFileName
-    QUrl baseDirectory = QUrl::fromLocalFile( url.path() );
-    // Here we need to use O_EXCL to avoid race conditions with other kioslave processes
-    int fd = 0;
-    QString fileName;
-    do {
-        qDebug() << "trying to create " << url.path() ;
-        fd = KDE_open( QFile::encodeName( url.path() ), O_WRONLY | O_CREAT | O_EXCL, 0600 );
-        if ( fd < 0 ) {
-            if (errno == EEXIST ) {
-                fileName = url.fileName();
-                url = url.adjusted(QUrl::RemoveFilename);
-                url.setPath(url.path() + KIO::suggestName( baseDirectory,  fileName)  );
-                // and try again on the next iteration
-            } else {
-                error( KIO::ERR_COULD_NOT_WRITE, url.path() );
-                return false;
-            }
-        }
-    } while ( fd < 0 );
-    const QString infoPath = url.path();
-    fileId = url.fileName();
-    Q_ASSERT( fileId.endsWith( QLatin1String(".trashinfo") ) );
-    fileId.truncate( fileId.length() - 10 ); // remove .trashinfo from fileId
-
-    FILE* file = ::fdopen( fd, "w" );
-    if ( !file ) { // can't see how this would happen
-        error( KIO::ERR_COULD_NOT_WRITE, infoPath );
-        return false;
-    }
-
-    // Contents of the info file. We could use KSimpleConfig, but that would
-    // mean closing and reopening fd, i.e. opening a race condition...
-    QByteArray info = "[Trash Info]\n";
-    info += "Path=";
-    // Escape filenames according to the way they are encoded on the filesystem
-    // All this to basically get back to the raw 8-bit representation of the filename...
-    if ( trashId == 0 ) // home trash: absolute path
-        info += QUrl::toPercentEncoding( origPath, "/" );
-    else
-        info += QUrl::toPercentEncoding( makeRelativePath( topDirectoryPath( trashId ), origPath ), "/" );
-    info += '\n';
-    info += "DeletionDate=";
-    info += QDateTime::currentDateTime().toString( Qt::ISODate ).toLatin1();
-    info += '\n';
-    size_t sz = info.size();
-
-    size_t written = ::fwrite(info.data(), 1, sz, file);
-    if ( written != sz ) {
-        ::fclose( file );
-        QFile::remove( infoPath );
-        error( KIO::ERR_DISK_FULL, infoPath );
-        return false;
-    }
-
-    ::fclose( file );
-
-    qDebug() << "info file created in trashId=" << trashId << " : " << fileId;
-    return true;
-}
-
-QString TrashImpl::makeRelativePath( const QString& topdir, const QString& path )
-{
-    const QString realPath = KStandardDirs::realFilePath( path );
-    // topdir ends with '/'
-#ifndef Q_OS_WIN
-    if ( realPath.startsWith( topdir ) ) {
-#else
-    if ( realPath.startsWith( topdir, Qt::CaseInsensitive ) ) {
-#endif
-        const QString rel = realPath.mid( topdir.length() );
-        Q_ASSERT( rel[0] != QLatin1Char('/') );
-        return rel;
-    } else { // shouldn't happen...
-        qWarning() << "Couldn't make relative path for " << realPath << " (" << path << "), with topdir=" << topdir ;
-        return realPath;
-    }
-}
-
-void TrashImpl::enterLoop()
-{
-    QEventLoop eventLoop;
-    connect(this, SIGNAL(leaveModality()),
-        &eventLoop, SLOT(quit()));
-    eventLoop.exec(QEventLoop::ExcludeUserInputEvents);
-}
-
-QString TrashImpl::infoPath( int trashId, const QString& fileId ) const
-{
-    QString trashPath = trashDirectoryPath( trashId );
-    trashPath += QString::fromLatin1("/info/");
-    trashPath += fileId;
-    trashPath += QString::fromLatin1(".trashinfo");
-    return trashPath;
-}
-
-QString TrashImpl::filesPath( int trashId, const QString& fileId ) const
-{
-    QString trashPath = trashDirectoryPath( trashId );
-    trashPath += QString::fromLatin1("/files/");
-    trashPath += fileId;
-    return trashPath;
-}
-
-bool TrashImpl::deleteInfo( int trashId, const QString& fileId )
-{
-    bool ok = QFile::remove( infoPath( trashId, fileId ) );
-    if ( ok )
-        fileRemoved();
-    return ok;
-}
-
-bool TrashImpl::moveToTrash( const QString& origPath, int trashId, const QString& fileId )
-{
-    qDebug() <<"Trashing" << origPath<<trashId<<fileId;
-    if ( !adaptTrashSize( origPath, trashId ) )
-        return false;
-
-    const qulonglong pathSize = DiscSpaceUtil::sizeOfPath( origPath );
-
-    const QString dest = filesPath( trashId, fileId );
-    if ( !move( origPath, dest ) ) {
-        // Maybe the move failed due to no permissions to delete source.
-        // In that case, delete dest to keep things consistent, since KIO doesn't do it.
-        if ( QFileInfo( dest ).isFile() )
-            QFile::remove( dest );
-        else
-            synchronousDel( dest, false, true );
-        return false;
-    }
-
-    if (QFileInfo(dest).isDir()) {
-        TrashSizeCache trashSize( trashDirectoryPath( trashId ) );
-        trashSize.add( fileId, pathSize );
-    }
-
-    fileAdded();
-    return true;
-}
-
-bool TrashImpl::moveFromTrash( const QString& dest, int trashId, const QString& fileId, const QString& relativePath )
-{
-    QString src = filesPath( trashId, fileId );
-    if ( !relativePath.isEmpty() ) {
-        src += QLatin1Char('/');
-        src += relativePath;
-    }
-    if ( !move( src, dest ) )
-        return false;
-
-    TrashSizeCache trashSize( trashDirectoryPath( trashId ) );
-    trashSize.remove( fileId );
-
-    return true;
-}
-
-bool TrashImpl::move( const QString& src, const QString& dest )
-{
-    if ( directRename( src, dest ) ) {
-        // This notification is done by KIO::moveAs when using the code below
-        // But if we do a direct rename we need to do the notification ourselves
-        org::kde::KDirNotify::emitFilesAdded( QUrl::fromLocalFile(dest) );
-        return true;
-    }
-    if ( m_lastErrorCode != KIO::ERR_UNSUPPORTED_ACTION )
-        return false;
-
-    QUrl urlSrc = QUrl::fromLocalFile(src);
-    QUrl urlDest = QUrl::fromLocalFile(dest);
-
-    qDebug() << urlSrc << " -> " << urlDest;
-    KIO::CopyJob* job = KIO::moveAs( urlSrc, urlDest, KIO::HideProgressInfo );
-    job->setUiDelegate(0);
-    connect( job, SIGNAL( result(KJob*) ),
-             this, SLOT( jobFinished(KJob*) ) );
-    enterLoop();
-
-    return m_lastErrorCode == 0;
-}
-
-void TrashImpl::jobFinished(KJob* job)
-{
-    qDebug() << " error=" << job->error() << job->errorText();
-    error( job->error(), job->errorText() );
-
-    emit leaveModality();
-}
-
-bool TrashImpl::copyToTrash( const QString& origPath, int trashId, const QString& fileId )
-{
-    qDebug() ;
-    if ( !adaptTrashSize( origPath, trashId ) )
-        return false;
-
-    const qulonglong pathSize = DiscSpaceUtil::sizeOfPath( origPath );
-
-    const QString dest = filesPath( trashId, fileId );
-    if ( !copy( origPath, dest ) )
-        return false;
-
-    if (QFileInfo(dest).isDir()) {
-        TrashSizeCache trashSize( trashDirectoryPath( trashId ) );
-        trashSize.add( fileId, pathSize );
-    }
-
-    fileAdded();
-    return true;
-}
-
-bool TrashImpl::copyFromTrash( const QString& dest, int trashId, const QString& fileId, const QString& relativePath )
-{
-    QString src = filesPath( trashId, fileId );
-    if ( !relativePath.isEmpty() ) {
-        src += QLatin1Char('/');
-        src += relativePath;
-    }
-    return copy( src, dest );
-}
-
-bool TrashImpl::copy( const QString& src, const QString& dest )
-{
-    // kio_file's copy() method is quite complex (in order to be fast), let's just call it...
-    m_lastErrorCode = 0;
-    QUrl urlSrc = QUrl::fromLocalFile( src );
-    QUrl urlDest = QUrl::fromLocalFile( dest );
-    qDebug() << "copying " << src << " to " << dest;
-    KIO::CopyJob* job = KIO::copyAs( urlSrc, urlDest, KIO::HideProgressInfo );
-    job->setUiDelegate(0);
-    connect( job, SIGNAL( result(KJob*) ),
-             this, SLOT( jobFinished(KJob*) ) );
-    enterLoop();
-
-    return m_lastErrorCode == 0;
-}
-
-bool TrashImpl::directRename( const QString& src, const QString& dest )
-{
-    qDebug() << src << " -> " << dest;
-    if ( KDE_rename( QFile::encodeName( src ), QFile::encodeName( dest ) ) != 0 ) {
-        if (errno == EXDEV) {
-            error( KIO::ERR_UNSUPPORTED_ACTION, QString::fromLatin1("rename") );
-        } else {
-            if (( errno == EACCES ) || (errno == EPERM)) {
-                error( KIO::ERR_ACCESS_DENIED, dest );
-            } else if (errno == EROFS) { // The file is on a read-only filesystem
-                error( KIO::ERR_CANNOT_DELETE, src );
-            } else {
-                error( KIO::ERR_CANNOT_RENAME, src );
-            }
-        }
-        return false;
-    }
-    return true;
-}
-
-#if 0
-bool TrashImplKDE_mkdir( int trashId, const QString& fileId, int permissions )
-{
-    const QString path = filesPath( trashId, fileId );
-    if ( KDE_mkdir( QFile::encodeName( path ), permissions ) != 0 ) {
-        if ( errno == EACCES ) {
-            error( KIO::ERR_ACCESS_DENIED, path );
-            return false;
-        } else if ( errno == ENOSPC ) {
-            error( KIO::ERR_DISK_FULL, path );
-            return false;
-        } else {
-            error( KIO::ERR_COULD_NOT_MKDIR, path );
-            return false;
-        }
-    } else {
-        if ( permissions != -1 )
-            ::chmod( QFile::encodeName( path ), permissions );
-    }
-    return true;
-}
-#endif
-
-bool TrashImpl::del( int trashId, const QString& fileId )
-{
-    QString info = infoPath(trashId, fileId);
-    QString file = filesPath(trashId, fileId);
-
-    QByteArray info_c = QFile::encodeName(info);
-
-    KDE_struct_stat buff;
-    if ( KDE_lstat( info_c.data(), &buff ) == -1 ) {
-        if ( errno == EACCES )
-            error( KIO::ERR_ACCESS_DENIED, file );
-        else
-            error( KIO::ERR_DOES_NOT_EXIST, file );
-        return false;
-    }
-
-    const bool isDir = QFileInfo(file).isDir();
-    if ( !synchronousDel( file, true, isDir ) )
-        return false;
-
-    if (isDir) {
-        TrashSizeCache trashSize( trashDirectoryPath( trashId ) );
-        trashSize.remove( fileId );
-    }
-
-    QFile::remove( info );
-    fileRemoved();
-    return true;
-}
-
-bool TrashImpl::synchronousDel( const QString& path, bool setLastErrorCode, bool isDir )
-{
-    const int oldErrorCode = m_lastErrorCode;
-    const QString oldErrorMsg = m_lastErrorMessage;
-    QUrl url = QUrl::fromLocalFile( path );
-    // First ensure that all dirs have u+w permissions,
-    // otherwise we won't be able to delete files in them (#130780).
-    if ( isDir ) {
-       qDebug() << "chmod'ing " << url;
-        KFileItem fileItem( url, QString::fromLatin1("inode/directory"), KFileItem::Unknown );
-        KFileItemList fileItemList;
-        fileItemList.append( fileItem );
-        KIO::ChmodJob* chmodJob = KIO::chmod( fileItemList, 0200, 0200, QString(), QString(), true /*recursive*/, KIO::HideProgressInfo );
-        connect( chmodJob, SIGNAL( result(KJob *) ),
-                 this, SLOT( jobFinished(KJob *) ) );
-        enterLoop();
-    }
-
-    KIO::DeleteJob *job = KIO::del( url, KIO::HideProgressInfo );
-    connect( job, SIGNAL( result(KJob*) ),
-             this, SLOT( jobFinished(KJob*) ) );
-    enterLoop();
-    bool ok = m_lastErrorCode == 0;
-    if ( !setLastErrorCode ) {
-        m_lastErrorCode = oldErrorCode;
-        m_lastErrorMessage = oldErrorMsg;
-    }
-    return ok;
-}
-
-bool TrashImpl::emptyTrash()
-{
-    qDebug() ;
-    // The naive implementation "delete info and files in every trash directory"
-    // breaks when deleted directories contain files owned by other users.
-    // We need to ensure that the .trashinfo file is only removed when the
-    // corresponding files could indeed be removed (#116371)
-
-    // On the other hand, we certainly want to remove any file that has no associated
-    // .trashinfo file for some reason (#167051)
-
-    QSet<QString> unremoveableFiles;
-
-    int myErrorCode = 0;
-    QString myErrorMsg;
-    const TrashedFileInfoList fileInfoList = list();
-
-    TrashedFileInfoList::const_iterator it = fileInfoList.begin();
-    const TrashedFileInfoList::const_iterator end = fileInfoList.end();
-    for ( ; it != end ; ++it ) {
-        const TrashedFileInfo& info = *it;
-        const QString filesPath = info.physicalPath;
-        if ( synchronousDel( filesPath, true, true ) || m_lastErrorCode == KIO::ERR_DOES_NOT_EXIST) {
-            QFile::remove( infoPath( info.trashId, info.fileId ) );
-        } else {
-            // error code is set by synchronousDel, let's remember it
-            // (so that successfully removing another file doesn't erase the error)
-            myErrorCode = m_lastErrorCode;
-            myErrorMsg = m_lastErrorMessage;
-            // and remember not to remove this file
-            unremoveableFiles.insert(filesPath);
-            qDebug() << "Unremoveable:" << filesPath;
-        }
-
-        TrashSizeCache trashSize( trashDirectoryPath( info.trashId ) );
-        trashSize.clear();
-    }
-
-    // Now do the orphaned-files cleanup
-    TrashDirMap::const_iterator trit = m_trashDirectories.constBegin();
-    for (; trit != m_trashDirectories.constEnd() ; ++trit) {
-        //const int trashId = trit.key();
-        QString filesDir = trit.value();
-        filesDir += QString::fromLatin1("/files");
-        Q_FOREACH(const QString& fileName, listDir(filesDir)) {
-            if (fileName == QString::fromLatin1(".") || fileName == QString::fromLatin1(".."))
-                continue;
-            const QString filePath = filesDir + QLatin1Char('/') + fileName;
-            if (!unremoveableFiles.contains(filePath)) {
-                qWarning() << "Removing orphaned file" << filePath;
-                QFile::remove(filePath);
-            }
-        }
-    }
-
-    m_lastErrorCode = myErrorCode;
-    m_lastErrorMessage = myErrorMsg;
-
-    fileRemoved();
-
-    return m_lastErrorCode == 0;
-}
-
-TrashImpl::TrashedFileInfoList TrashImpl::list()
-{
-    // Here we scan for trash directories unconditionally. This allows
-    // noticing plugged-in [e.g. removeable] devices, or new mounts etc.
-    scanTrashDirectories();
-
-    TrashedFileInfoList lst;
-    // For each known trash directory...
-    TrashDirMap::const_iterator it = m_trashDirectories.constBegin();
-    for ( ; it != m_trashDirectories.constEnd() ; ++it ) {
-        const int trashId = it.key();
-        QString infoPath = it.value();
-        infoPath += QString::fromLatin1("/info");
-        // Code taken from kio_file
-        const QStringList entryNames = listDir( infoPath );
-        //char path_buffer[PATH_MAX];
-        //getcwd(path_buffer, PATH_MAX - 1);
-        //if ( chdir( infoPathEnc ) )
-        //    continue;
-        for ( QStringList::const_iterator entryIt = entryNames.constBegin(), entryEnd = entryNames.constEnd();
-              entryIt != entryEnd ; ++entryIt )
-        {
-            QString fileName = *entryIt;
-            if ( fileName == QLatin1String(".") || fileName == QLatin1String("..") )
-                continue;
-            if ( !fileName.endsWith( QLatin1String(".trashinfo") ) ) {
-                qWarning() << "Invalid info file found in " << infoPath << " : " << fileName ;
-                continue;
-            }
-            fileName.truncate( fileName.length() - 10 );
-
-            TrashedFileInfo info;
-            if ( infoForFile( trashId, fileName, info ) )
-                lst << info;
-        }
-    }
-    return lst;
-}
-
-// Returns the entries in a given directory - including "." and ".."
-QStringList TrashImpl::listDir( const QString& physicalPath )
-{
-    QDir dir( physicalPath );
-    return dir.entryList( QDir::Dirs | QDir::Files | QDir::Hidden );
-}
-
-bool TrashImpl::infoForFile( int trashId, const QString& fileId, TrashedFileInfo& info )
-{
-    qDebug() << trashId << " " << fileId;
-    info.trashId = trashId; // easy :)
-    info.fileId = fileId; // equally easy
-    info.physicalPath = filesPath( trashId, fileId );
-    return readInfoFile( infoPath( trashId, fileId ), info, trashId );
-}
-
-bool TrashImpl::readInfoFile( const QString& infoPath, TrashedFileInfo& info, int trashId )
-{
-    KConfig cfg( infoPath, KConfig::SimpleConfig);
-    if ( !cfg.hasGroup( "Trash Info" ) ) {
-        error( KIO::ERR_CANNOT_OPEN_FOR_READING, infoPath );
-        return false;
-    }
-    const KConfigGroup group = cfg.group( "Trash Info" );
-    info.origPath = QUrl::fromPercentEncoding( group.readEntry( "Path" ).toLatin1() );
-    if ( info.origPath.isEmpty() )
-        return false; // path is mandatory...
-    if ( trashId == 0 ) {
-        Q_ASSERT( info.origPath[0] == QLatin1Char('/') );
-    } else {
-        const QString topdir = topDirectoryPath( trashId ); // includes trailing slash
-        info.origPath.prepend( topdir );
-    }
-    const QString line = group.readEntry( "DeletionDate" );
-    if ( !line.isEmpty() ) {
-        info.deletionDate = QDateTime::fromString( line, Qt::ISODate );
-    }
-    return true;
-}
-
-QString TrashImpl::physicalPath( int trashId, const QString& fileId, const QString& relativePath )
-{
-    QString filePath = filesPath( trashId, fileId );
-    if ( !relativePath.isEmpty() ) {
-        filePath += QLatin1Char('/');
-        filePath += relativePath;
-    }
-    return filePath;
-}
-
-void TrashImpl::error( int e, const QString& s )
-{
-    if ( e )
-        qDebug() << e << " " << s;
-    m_lastErrorCode = e;
-    m_lastErrorMessage = s;
-}
-
-bool TrashImpl::isEmpty() const
-{
-    // For each known trash directory...
-    if ( !m_trashDirectoriesScanned )
-        scanTrashDirectories();
-    TrashDirMap::const_iterator it = m_trashDirectories.constBegin();
-    for ( ; it != m_trashDirectories.constEnd() ; ++it ) {
-        QString infoPath = it.value();
-        infoPath += QString::fromLatin1("/info");
-
-        DIR *dp = opendir( QFile::encodeName( infoPath ) );
-        if ( dp )
-        {
-            KDE_struct_dirent *ep;
-            ep = KDE_readdir( dp );
-            ep = KDE_readdir( dp ); // ignore '.' and '..' dirent
-            ep = KDE_readdir( dp ); // look for third file
-            closedir( dp );
-            if ( ep != 0 ) {
-                //qDebug() << ep->d_name << " in " << infoPath << " -> not empty";
-                return false; // not empty
-            }
-        }
-    }
-    return true;
-}
-
-void TrashImpl::fileAdded()
-{
-    m_config.reparseConfiguration();
-    KConfigGroup group = m_config.group( "Status" );
-    if ( group.readEntry( "Empty", true) == true ) {
-        group.writeEntry( "Empty", false );
-        m_config.sync();
-    }
-    // The apps showing the trash (e.g. kdesktop) will be notified
-    // of this change when KDirNotify::FilesAdded("trash:/") is emitted,
-    // which will be done by the job soon after this.
-}
-
-void TrashImpl::fileRemoved()
-{
-    if ( isEmpty() ) {
-        KConfigGroup group = m_config.group( "Status" );
-        group.writeEntry( "Empty", true );
-        m_config.sync();
-    }
-    // The apps showing the trash (e.g. kdesktop) will be notified
-    // of this change when KDirNotify::FilesRemoved(...) is emitted,
-    // which will be done by the job soon after this.
-}
-
-static int idForDevice(const Solid::Device& device)
-{
-    const Solid::Block* block = device.as<Solid::Block>();
-    if (block) {
-        qDebug() << "major=" << block->deviceMajor() << " minor=" << block->deviceMinor();
-        return block->deviceMajor()*1000 + block->deviceMinor();
-    } else {
-        // Not a block device. Maybe a NFS mount?
-        return -1;
-    }
-}
-
-int TrashImpl::findTrashDirectory( const QString& origPath )
-{
-    qDebug() << origPath;
-    // First check if same device as $HOME, then we use the home trash right away.
-    KDE_struct_stat buff;
-    if ( KDE_lstat( QFile::encodeName( origPath ), &buff ) == 0
-         && buff.st_dev == m_homeDevice )
-        return 0;
-
-    KMountPoint::Ptr mp = KMountPoint::currentMountPoints().findByPath( origPath );
-    if (!mp) {
-        qDebug() << "KMountPoint found no mount point for" << origPath;
-        return 0;
-    }
-    QString mountPoint = mp->mountPoint();
-    const QString trashDir = trashForMountPoint( mountPoint, true );
-    qDebug() << "mountPoint=" << mountPoint << " trashDir=" << trashDir;
-    if ( trashDir.isEmpty() )
-        return 0; // no trash available on partition
-    int id = idForTrashDirectory( trashDir );
-    if ( id > -1 ) {
-        qDebug() << " known with id " << id;
-        return id;
-    }
-    // new trash dir found, register it
-    // but we need stability in the trash IDs, so that restoring or asking
-    // for properties works even kio_trash gets killed because idle.
-#if 0
-    qDebug() << "found " << trashDir;
-    m_trashDirectories.insert( ++m_lastId, trashDir );
-    if ( !mountPoint.endsWith( '/' ) )
-        mountPoint += '/';
-    m_topDirectories.insert( m_lastId, mountPoint );
-    return m_lastId;
-#endif
-
-    const QString query = QString::fromLatin1("[StorageAccess.accessible == true AND StorageAccess.filePath == '")+mountPoint+QString::fromLatin1("']");
-    //qDebug() << "doing solid query:" << query;
-    const QList<Solid::Device> lst = Solid::Device::listFromQuery(query);
-    //qDebug() << "got" << lst.count() << "devices";
-    if ( lst.isEmpty() ) // not a device. Maybe some tmpfs mount for instance.
-        return 0; // use the home trash instead
-    // Pretend we got exactly one...
-    const Solid::Device device = lst[0];
-
-    // new trash dir found, register it
-    id = idForDevice( device );
-    if (id == -1) {
-        return 0;
-    }
-    m_trashDirectories.insert( id, trashDir );
-    qDebug() << "found" << trashDir << "gave it id" << id;
-    if (!mountPoint.endsWith(QLatin1Char('/')))
-        mountPoint += QLatin1Char('/');
-    m_topDirectories.insert( id, mountPoint );
-
-    return idForTrashDirectory( trashDir );
-}
-
-void TrashImpl::scanTrashDirectories() const
-{
-    const QList<Solid::Device> lst = Solid::Device::listFromQuery(QString::fromLatin1("StorageAccess.accessible == true"));
-    for ( QList<Solid::Device>::ConstIterator it = lst.begin() ; it != lst.end() ; ++it ) {
-        QString topdir = (*it).as<Solid::StorageAccess>()->filePath();
-        QString trashDir = trashForMountPoint( topdir, false );
-        if ( !trashDir.isEmpty() ) {
-            // OK, trashDir is a valid trash directory. Ensure it's registered.
-            int trashId = idForTrashDirectory( trashDir );
-            if ( trashId == -1 ) {
-                // new trash dir found, register it
-                trashId = idForDevice( *it );
-                if (trashId == -1) {
-                    continue;
-                }
-                m_trashDirectories.insert( trashId, trashDir );
-                qDebug() << "found " << trashDir << " gave it id " << trashId;
-                if (!topdir.endsWith(QLatin1Char('/')))
-                    topdir += QLatin1Char('/');
-                m_topDirectories.insert( trashId, topdir );
-            }
-        }
-    }
-    m_trashDirectoriesScanned = true;
-}
-
-TrashImpl::TrashDirMap TrashImpl::trashDirectories() const
-{
-    if ( !m_trashDirectoriesScanned )
-        scanTrashDirectories();
-    return m_trashDirectories;
-}
-
-TrashImpl::TrashDirMap TrashImpl::topDirectories() const
-{
-    if ( !m_trashDirectoriesScanned )
-        scanTrashDirectories();
-    return m_topDirectories;
-}
-
-QString TrashImpl::trashForMountPoint( const QString& topdir, bool createIfNeeded ) const
-{
-    // (1) Administrator-created $topdir/.Trash directory
-
-    const QString rootTrashDir = topdir + QString::fromLatin1("/.Trash");
-    const QByteArray rootTrashDir_c = QFile::encodeName( rootTrashDir );
-    // Can't use QFileInfo here since we need to test for the sticky bit
-    uid_t uid = getuid();
-    KDE_struct_stat buff;
-    const unsigned int requiredBits = S_ISVTX; // Sticky bit required
-    if ( KDE_lstat( rootTrashDir_c, &buff ) == 0 ) {
-        if ( (S_ISDIR(buff.st_mode)) // must be a dir
-             && (!S_ISLNK(buff.st_mode)) // not a symlink
-             && ((buff.st_mode & requiredBits) == requiredBits)
-             && (::access(rootTrashDir_c, W_OK) == 0) // must be user-writable
-            ) {
-            const QString trashDir = rootTrashDir + QLatin1Char('/') + QString::number( uid );
-            const QByteArray trashDir_c = QFile::encodeName( trashDir );
-            if ( KDE_lstat( trashDir_c, &buff ) == 0 ) {
-                if ( (buff.st_uid == uid) // must be owned by user
-                     && (S_ISDIR(buff.st_mode)) // must be a dir
-                     && (!S_ISLNK(buff.st_mode)) // not a symlink
-                     && (buff.st_mode & 0777) == 0700 ) { // rwx for user
-                    return trashDir;
-                }
-                qDebug() << "Directory " << trashDir << " exists but didn't pass the security checks, can't use it";
-            }
-            else if ( createIfNeeded && initTrashDirectory( trashDir_c ) ) {
-                return trashDir;
-            }
-        } else {
-            qDebug() << "Root trash dir " << rootTrashDir << " exists but didn't pass the security checks, can't use it";
-        }
-    }
-
-    // (2) $topdir/.Trash-$uid
-    const QString trashDir = topdir + QString::fromLatin1("/.Trash-") + QString::number( uid );
-    const QByteArray trashDir_c = QFile::encodeName( trashDir );
-    if ( KDE_lstat( trashDir_c, &buff ) == 0 )
-    {
-        if ( (buff.st_uid == uid) // must be owned by user
-             && (S_ISDIR(buff.st_mode)) // must be a dir
-             && (!S_ISLNK(buff.st_mode)) // not a symlink
-             && ((buff.st_mode & 0777) == 0700) ) { // rwx for user, ------ for group and others
-
-            if ( checkTrashSubdirs( trashDir_c ) )
-                return trashDir;
-        }
-        qDebug() << "Directory " << trashDir << " exists but didn't pass the security checks, can't use it";
-        // Exists, but not useable
-        return QString();
-    }
-    if ( createIfNeeded && initTrashDirectory( trashDir_c ) ) {
-        return trashDir;
-    }
-    return QString();
-}
-
-int TrashImpl::idForTrashDirectory( const QString& trashDir ) const
-{
-    // If this is too slow we can always use a reverse map...
-    TrashDirMap::ConstIterator it = m_trashDirectories.constBegin();
-    for ( ; it != m_trashDirectories.constEnd() ; ++it ) {
-        if ( it.value() == trashDir ) {
-            return it.key();
-        }
-    }
-    return -1;
-}
-
-bool TrashImpl::initTrashDirectory( const QByteArray& trashDir_c ) const
-{
-    qDebug() << trashDir_c;
-    if ( KDE_mkdir( trashDir_c, 0700 ) != 0 )
-        return false;
-    qDebug() ;
-    // This trash dir will be useable only if the directory is owned by user.
-    // In theory this is the case, but not on e.g. USB keys...
-    uid_t uid = getuid();
-    KDE_struct_stat buff;
-    if ( KDE_lstat( trashDir_c, &buff ) != 0 )
-        return false; // huh?
-    if ( (buff.st_uid == uid) // must be owned by user
-         && ((buff.st_mode & 0777) == 0700) ) { // rwx for user, --- for group and others
-
-        return checkTrashSubdirs( trashDir_c );
-
-    } else {
-        qDebug() << trashDir_c << " just created, by it doesn't have the right permissions, probably some strange unsupported filesystem";
-        ::rmdir( trashDir_c );
-        return false;
-    }
-    return true;
-}
-
-bool TrashImpl::checkTrashSubdirs( const QByteArray& trashDir_c ) const
-{
-    // testDir currently works with a QString - ## optimize
-    QString trashDir = QFile::decodeName( trashDir_c );
-    const QString info = trashDir + QString::fromLatin1("/info");
-    if ( testDir( info ) != 0 )
-        return false;
-    const QString files = trashDir + QString::fromLatin1("/files");
-    if ( testDir( files ) != 0 )
-        return false;
-    return true;
-}
-
-QString TrashImpl::trashDirectoryPath( int trashId ) const
-{
-    // Never scanned for trash dirs? (This can happen after killing kio_trash
-    // and reusing a directory listing from the earlier instance.)
-    if ( !m_trashDirectoriesScanned )
-        scanTrashDirectories();
-    Q_ASSERT( m_trashDirectories.contains( trashId ) );
-    return m_trashDirectories[trashId];
-}
-
-QString TrashImpl::topDirectoryPath( int trashId ) const
-{
-    if ( !m_trashDirectoriesScanned )
-        scanTrashDirectories();
-    assert( trashId != 0 );
-    Q_ASSERT( m_topDirectories.contains( trashId ) );
-    return m_topDirectories[trashId];
-}
-
-// Helper method. Creates a URL with the format trash:/trashid-fileid or
-// trash:/trashid-fileid/relativePath/To/File for a file inside a trashed directory.
-QUrl TrashImpl::makeURL( int trashId, const QString& fileId, const QString& relativePath )
-{
-    QUrl url;
-    url.setScheme(QString::fromLatin1("trash"));
-    QString path = QString::fromLatin1("/");
-    path += QString::number( trashId );
-    path += QLatin1Char('-');
-    path += fileId;
-    if ( !relativePath.isEmpty() ) {
-        path += QLatin1Char('/');
-        path += relativePath;
-    }
-    url.setPath( path );
-    return url;
-}
-
-// Helper method. Parses a trash URL with the URL scheme defined in makeURL.
-// The trash:/ URL itself isn't parsed here, must be caught by the caller before hand.
-bool TrashImpl::parseURL( const QUrl& url, int& trashId, QString& fileId, QString& relativePath )
-{
-    if (url.scheme() != QLatin1String("trash"))
-        return false;
-    const QString path = url.path();
-    int start = 0;
-    if ( path[0] == QLatin1Char('/') ) // always true I hope
-        start = 1;
-    int slashPos = path.indexOf(QLatin1Char('-'), 0); // don't match leading slash
-    if ( slashPos <= 0 )
-        return false;
-    bool ok = false;
-    trashId = path.mid( start, slashPos - start ).toInt( &ok );
-    Q_ASSERT( ok );
-    if ( !ok )
-        return false;
-    start = slashPos + 1;
-    slashPos = path.indexOf(QLatin1Char('/'), start);
-    if ( slashPos <= 0 ) {
-        fileId = path.mid( start );
-        relativePath.clear();
-        return true;
-    }
-    fileId = path.mid( start, slashPos - start );
-    relativePath = path.mid( slashPos + 1 );
-    return true;
-}
-
-bool TrashImpl::adaptTrashSize( const QString& origPath, int trashId )
-{
-    KConfig config(QString::fromLatin1("ktrashrc"));
-
-    const QString trashPath = trashDirectoryPath( trashId );
-    KConfigGroup group = config.group( trashPath );
-
-    bool useTimeLimit = group.readEntry( "UseTimeLimit", false );
-    bool useSizeLimit = group.readEntry( "UseSizeLimit", true );
-    double percent = group.readEntry( "Percent", 10.0 );
-    int actionType = group.readEntry( "LimitReachedAction", 0 );
-
-    if ( useTimeLimit ) { // delete all files in trash older than X days
-        const int maxDays = group.readEntry( "Days", 7 );
-        const QDateTime currentDate = QDateTime::currentDateTime();
-
-        const TrashedFileInfoList trashedFiles = list();
-        for ( int i = 0; i < trashedFiles.count(); ++i ) {
-            struct TrashedFileInfo info = trashedFiles.at( i );
-            if ( info.trashId != trashId )
-                continue;
-
-            if ( info.deletionDate.daysTo( currentDate ) > maxDays )
-              del( info.trashId, info.fileId );
-        }
-    }
-
-    if ( useSizeLimit ) { // check if size limit exceeded
-
-        // calculate size of the files to be put into the trash
-        qulonglong additionalSize = DiscSpaceUtil::sizeOfPath( origPath );
-
-        TrashSizeCache trashSize( trashPath );
-        DiscSpaceUtil util(trashPath + QString::fromLatin1("/files/"));
-        if ( util.usage( trashSize.calculateSize() + additionalSize ) >= percent ) {
-            if ( actionType == 0 ) { // warn the user only
-                m_lastErrorCode = KIO::ERR_SLAVE_DEFINED;
-                m_lastErrorMessage = i18n( "The trash has reached its maximum size!\nCleanup the trash manually." );
-                return false;
-            } else {
-                // before we start to remove any files from the trash,
-                // check whether the new file will fit into the trash
-                // at all...
-
-                qulonglong partitionSize = util.size();
-
-                if ( (((double)additionalSize/(double)partitionSize)*100) >= percent ) {
-                    m_lastErrorCode = KIO::ERR_SLAVE_DEFINED;
-                    m_lastErrorMessage = i18n( "The file is too large to be trashed." );
-                    return false;
-                }
-
-                // the size of the to be trashed file is ok, so lets start removing
-                // some other files from the trash
-
-                QDir dir(trashPath + QString::fromLatin1("/files"));
-                QFileInfoList infoList;
-                if ( actionType == 1 )  // delete oldest files first
-                    infoList = dir.entryInfoList( QDir::Files | QDir::AllDirs | QDir::NoDotAndDotDot, QDir::Time | QDir::Reversed );
-                else if ( actionType == 2 ) // delete biggest files first
-                    infoList = dir.entryInfoList( QDir::Files | QDir::AllDirs | QDir::NoDotAndDotDot, QDir::Size );
-                else
-                    qWarning( "Should never happen!" );
-
-                bool deleteFurther = true;
-                for ( int i = 0; (i < infoList.count()) && deleteFurther; ++i ) {
-                    const QFileInfo info = infoList.at( i );
-
-                    del( trashId, info.fileName() ); // delete trashed file
-
-                    TrashSizeCache trashSize( trashPath );
-                    if ( util.usage( trashSize.calculateSize() + additionalSize ) < percent ) // check whether we have enough space now
-                         deleteFurther = false;
-                }
-            }
-        }
-    }
-
-    return true;
-}
-
-#include "moc_trashimpl.cpp"
diff --git a/trash/trashimpl.h b/trash/trashimpl.h
deleted file mode 100644
index 06e9dda..0000000
--- a/trash/trashimpl.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/* This file is part of the KDE project
-   Copyright (C) 2004 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef TRASHIMPL_H
-#define TRASHIMPL_H
-
-#include <kio/jobclasses.h>
-#include <kconfig.h>
-
-#include <QDateTime>
-#include <QMap>
-#include <assert.h>
-
-/**
- * Implementation of all low-level operations done by kio_trash
- * The structure of the trash directory follows the freedesktop.org standard <TODO URL>
- */
-class TrashImpl : public QObject
-{
-    Q_OBJECT
-public:
-    TrashImpl();
-
-    /// Check the "home" trash directory
-    /// This MUST be called before doing anything else
-    bool init();
-
-    /// Create info for a file to be trashed
-    /// Returns trashId and fileId
-    /// The caller is then responsible for actually trashing the file
-    bool createInfo( const QString& origPath, int& trashId, QString& fileId );
-
-    /// Delete info file for a file to be trashed
-    /// Usually used for undoing what createInfo did if trashing failed
-    bool deleteInfo( int trashId, const QString& fileId );
-
-    /// Moving a file or directory into the trash. The ids come from createInfo.
-    bool moveToTrash( const QString& origPath, int trashId, const QString& fileId );
-
-    /// Moving a file or directory out of the trash. The ids come from createInfo.
-    bool moveFromTrash( const QString& origPath, int trashId, const QString& fileId, const QString& relativePath );
-
-    /// Copying a file or directory into the trash. The ids come from createInfo.
-    bool copyToTrash( const QString& origPath, int trashId, const QString& fileId );
-
-    /// Copying a file or directory out of the trash. The ids come from createInfo.
-    bool copyFromTrash( const QString& origPath, int trashId, const QString& fileId, const QString& relativePath );
-
-    /// Create a top-level trashed directory
-    //bool mkdir( int trashId, const QString& fileId, int permissions );
-
-    /// Get rid of a trashed file
-    bool del( int trashId, const QString& fileId );
-
-    /// Empty trash, i.e. delete all trashed files
-    bool emptyTrash();
-
-    /// Return true if the trash is empty
-    bool isEmpty() const;
-
-    struct TrashedFileInfo {
-        int trashId; // for the url
-        QString fileId; // for the url
-        QString physicalPath; // for stat'ing etc.
-        QString origPath; // from info file
-        QDateTime deletionDate; // from info file
-    };
-    /// List trashed files
-    typedef QList<TrashedFileInfo> TrashedFileInfoList;
-    TrashedFileInfoList list();
-
-    /// Return the info for a given trashed file
-    bool infoForFile( int trashId, const QString& fileId, TrashedFileInfo& info );
-
-    /// Return the physicalPath for a given trashed file - helper method which
-    /// encapsulates the call to infoForFile. Don't use if you need more info from TrashedFileInfo.
-    QString physicalPath( int trashId, const QString& fileId, const QString& relativePath );
-
-    /// Move data from the old trash system to the new one
-    void migrateOldTrash();
-
-    /// KIO error code
-    int lastErrorCode() const { return m_lastErrorCode; }
-    QString lastErrorMessage() const { return m_lastErrorMessage; }
-
-    QStringList listDir( const QString& physicalPath );
-
-    static QUrl makeURL( int trashId, const QString& fileId, const QString& relativePath );
-    static bool parseURL( const QUrl& url, int& trashId, QString& fileId, QString& relativePath );
-
-    typedef QMap<int, QString> TrashDirMap;
-    /// @internal This method is for TestTrash only. Home trash is included (id 0).
-    TrashDirMap trashDirectories() const;
-    /// @internal This method is for TestTrash only. No entry with id 0.
-    TrashDirMap topDirectories() const;
-
-Q_SIGNALS:
-    void leaveModality();
-
-private:
-    /// Helper method. Moves a file or directory using the appropriate method.
-    bool move( const QString& src, const QString& dest );
-    bool copy( const QString& src, const QString& dest );
-    /// Helper method. Tries to call ::rename(src,dest) and does error handling.
-    bool directRename( const QString& src, const QString& dest );
-
-    void fileAdded();
-    void fileRemoved();
-
-    bool adaptTrashSize( const QString& origPath, int trashId );
-
-    // Warning, returns error code, not a bool
-    int testDir( const QString& name ) const;
-    void error( int e, const QString& s );
-
-    bool readInfoFile( const QString& infoPath, TrashedFileInfo& info, int trashId );
-
-    QString infoPath( int trashId, const QString& fileId ) const;
-    QString filesPath( int trashId, const QString& fileId ) const;
-
-    /// Find the trash dir to use for a given file to delete, based on original path
-    int findTrashDirectory( const QString& origPath );
-
-    QString trashDirectoryPath( int trashId ) const;
-    QString topDirectoryPath( int trashId ) const;
-
-    bool synchronousDel( const QString& path, bool setLastErrorCode, bool isDir );
-
-    void scanTrashDirectories() const;
-
-    int idForTrashDirectory( const QString& trashDir ) const;
-    bool initTrashDirectory( const QByteArray& trashDir_c ) const;
-    bool checkTrashSubdirs( const QByteArray& trashDir_c ) const;
-    QString trashForMountPoint( const QString& topdir, bool createIfNeeded ) const;
-    static QString makeRelativePath( const QString& topdir, const QString& path );
-
-    void enterLoop();
-
-private Q_SLOTS:
-    void jobFinished(KJob *job);
-
-private:
-    /// Last error code stored in class to simplify API.
-    /// Note that this means almost no method can be const.
-    int m_lastErrorCode;
-    QString m_lastErrorMessage;
-
-    enum { InitToBeDone, InitOK, InitError } m_initStatus;
-
-    // A "trash directory" is a physical directory on disk,
-    // e.g. $HOME/.local/share/Trash/$uid or /mnt/foo/.Trash/$uid
-    // It has an id (number) and a path.
-    // The home trash has id 0.
-    mutable TrashDirMap m_trashDirectories; // id -> path of trash directory
-    mutable TrashDirMap m_topDirectories; // id -> $topdir of partition
-    dev_t m_homeDevice;
-    mutable bool m_trashDirectoriesScanned;
-    int m_mibEnum;
-
-    KConfig m_config;
-
-    // We don't cache any data related to the trashed files.
-    // Another kioslave could change that behind our feet.
-    // If we want to start caching data - and avoiding some race conditions -,
-    // we should turn this class into a kded module and use DCOP to talk to it
-    // from the kioslave.
-};
-
-#endif
diff --git a/trash/trashsizecache.cpp b/trash/trashsizecache.cpp
deleted file mode 100644
index 2f067f3..0000000
--- a/trash/trashsizecache.cpp
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
-   This file is part of the KDE project
-
-   Copyright (C) 2009 Tobias Koenig <tokoe@kde.org>
-   Copyright (C) 2014 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#include "trashsizecache.h"
-
-#include "discspaceutil.h"
-
-#include <qplatformdefs.h> // QT_LSTAT, QT_STAT, QT_STATBUF
-#include <QDir>
-#include <QDirIterator>
-#include <QFile>
-#include <QDateTime>
-#include <QSaveFile>
-#include <QDebug>
-
-TrashSizeCache::TrashSizeCache( const QString &path )
-    : mTrashSizeCachePath( path + QString::fromLatin1( "/directorysizes" ) ),
-      mTrashPath( path )
-{
-    //qDebug() << "CACHE:" << mTrashSizeCachePath;
-}
-
-void TrashSizeCache::add( const QString &directoryName, qulonglong directorySize )
-{
-    //qDebug() << directoryName << directorySize;
-    const QByteArray encodedDir = QFile::encodeName(directoryName).toPercentEncoding();
-    const QByteArray spaceAndDirAndNewline = ' ' + encodedDir + '\n';
-    QFile file( mTrashSizeCachePath );
-    QSaveFile out( mTrashSizeCachePath );
-    if (out.open(QIODevice::WriteOnly)) {
-        if (file.open(QIODevice::ReadOnly)) {
-            while (!file.atEnd()) {
-                const QByteArray line = file.readLine();
-                if (line.endsWith(spaceAndDirAndNewline)) {
-                    // Already there!
-                    out.cancelWriting();
-                    //qDebug() << "already there!";
-                    return;
-                }
-                out.write(line);
-            }
-        }
-
-        const QString fileInfoPath = mTrashPath + "/info/" + directoryName + ".trashinfo";
-        QDateTime mtime = QFileInfo(fileInfoPath).lastModified();
-        QByteArray newLine = QByteArray::number(directorySize) + ' ' + QByteArray::number(mtime.toMSecsSinceEpoch()) + spaceAndDirAndNewline;
-        out.write(newLine);
-        out.commit();
-    }
-    //qDebug() << mTrashSizeCachePath << "exists:" << QFile::exists(mTrashSizeCachePath);
-}
-
-void TrashSizeCache::remove( const QString &directoryName )
-{
-    //qDebug() << directoryName;
-    const QByteArray encodedDir = QFile::encodeName(directoryName).toPercentEncoding();
-    const QByteArray spaceAndDirAndNewline = ' ' + encodedDir + '\n';
-    QFile file( mTrashSizeCachePath );
-    QSaveFile out( mTrashSizeCachePath );
-    if (file.open(QIODevice::ReadOnly) && out.open(QIODevice::WriteOnly)) {
-        while (!file.atEnd()) {
-            const QByteArray line = file.readLine();
-            if (line.endsWith(spaceAndDirAndNewline)) {
-                // Found it -> skip it
-                continue;
-            }
-            out.write(line);
-        }
-    }
-    out.commit();
-}
-
-void TrashSizeCache::clear()
-{
-    QFile::remove(mTrashSizeCachePath);
-}
-
-struct CacheData {
-    qint64 mtime;
-    qulonglong size;
-};
-
-qulonglong TrashSizeCache::calculateSize()
-{
-    // First read the directorysizes cache into memory
-    QFile file( mTrashSizeCachePath );
-    typedef QHash<QByteArray, CacheData> DirCacheHash;
-    DirCacheHash dirCache;
-    if (file.open(QIODevice::ReadOnly)) {
-        while (!file.atEnd()) {
-            const QByteArray line = file.readLine();
-            const int firstSpace = line.indexOf(' ');
-            const int secondSpace = line.indexOf(' ', firstSpace + 1);
-            CacheData data;
-            data.mtime = line.left(firstSpace).toLongLong();
-            // "012 4567 name" -> firstSpace=3, secondSpace=8, we want mid(4,4)
-            data.size = line.mid(firstSpace + 1, secondSpace - firstSpace - 1).toULongLong();
-            dirCache.insert(line.mid(secondSpace + 1), data);
-        }
-    }
-    // Iterate over the actual trashed files.
-    // Orphan items (no .fileinfo) still take space.
-    QDirIterator it( mTrashPath + QString::fromLatin1( "/files/" ), QDirIterator::NoIteratorFlags );
-
-    qulonglong sum = 0;
-    while ( it.hasNext() ) {
-        const QFileInfo file = it.next();
-        if (file.fileName() == QLatin1String(".") || file.fileName() == QLatin1String("..")) {
-            continue;
-        }
-        if ( file.isSymLink() ) {
-            // QFileInfo::size does not return the actual size of a symlink. #253776
-            QT_STATBUF buff;
-            return static_cast<qulonglong>(QT_LSTAT(QFile::encodeName(file.absoluteFilePath()), &buff) == 0 ? buff.st_size : 0);
-        } else if (file.isFile()) {
-            sum += file.size();
-        } else {
-            bool usableCache = false;
-            const QString fileId = file.fileName();
-            DirCacheHash::const_iterator it = dirCache.constFind(QFile::encodeName(fileId));
-            if (it != dirCache.constEnd()) {
-                const CacheData &data = *it;
-                const QString fileInfoPath = mTrashPath + "/info/" + fileId + ".trashinfo";
-                if (QFileInfo(fileInfoPath).lastModified().toMSecsSinceEpoch() == data.mtime) {
-                    sum += data.size;
-                    usableCache = true;
-                }
-            }
-            if (!usableCache) {
-                const qulonglong size = DiscSpaceUtil::sizeOfPath(file.absoluteFilePath());
-                sum += size;
-                add(fileId, size);
-            }
-        }
-
-    }
-
-    return sum;
-}
diff --git a/trash/trashsizecache.h b/trash/trashsizecache.h
deleted file mode 100644
index 72cac67..0000000
--- a/trash/trashsizecache.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
-   This file is part of the KDE project
-
-   Copyright (C) 2009 Tobias Koenig <tokoe@kde.org>
-   Copyright (C) 2014 David Faure <faure@kde.org>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-
-#ifndef TRASHSIZECACHE_H
-#define TRASHSIZECACHE_H
-
-#include <QtCore/QString>
-
-#include <kconfig.h>
-
-/**
- * @short A class that encapsulates the directory size cache.
- *
- * The directory size cache is used to speed up the determination of the trash size.
- *
- * Since version 1.0, http://standards.freedesktop.org/trash-spec/trashspec-latest.html specifies this cache
- * as a standard way to cache this information.
- *
- */
-class TrashSizeCache
-{
-    public:
-        /**
-         * Creates a new trash size cache object for the given trash @p path.
-         */
-        TrashSizeCache( const QString &path );
-
-        /**
-         * Adds a directory to the cache.
-         * @param directoryName fileId of the directory
-         * @param directorySize size in bytes
-         */
-        void add( const QString &directoryName, qulonglong directorySize );
-
-        /**
-         * Removes a directory from the cache.
-         */
-        void remove( const QString &directoryName );
-
-        /**
-         * Sets the trash size to 0 bytes.
-         */
-        void clear();
-
-        /**
-         * Calculates and returns the current trash size.
-         */
-        qulonglong calculateSize();
-
-    private:
-        QString mTrashSizeCachePath;
-        QString mTrashPath;
-};
-
-#endif
-- 
2.1.2

