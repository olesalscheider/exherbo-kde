Upstream: backported from master

From 86c6f570f3565010c81c5450092d85d8586edd8b Mon Sep 17 00:00:00 2001
From: Johannes Huber <johu@gentoo.org>
Date: Wed, 30 Jul 2014 22:35:21 +0200
Subject: [PATCH] CVE-2014-4607: Unbundle libvncserver

http://seclists.org/oss-sec/2014/q2/676

REVIEW: 119548

Conflicts:
	CMakeLists.txt
	libvncserver/main.c
	libvncserver/sockets.c
---
 CMakeLists.txt                           |   12 +-
 cmake/modules/FindLibVNCServer.cmake     |   41 +
 krfb/CMakeLists.txt                      |    2 +
 krfb/rfb.h                               |    2 +-
 libvncserver/CMakeLists.txt              |  132 -
 libvncserver/auth.c                      |  375 ---
 libvncserver/cargs.c                     |  213 --
 libvncserver/corre.c                     |  342 ---
 libvncserver/cursor.c                    |  756 ------
 libvncserver/cutpaste.c                  |   38 -
 libvncserver/d3des.c                     |  436 ----
 libvncserver/d3des.h                     |   56 -
 libvncserver/draw.c                      |   61 -
 libvncserver/font.c                      |  196 --
 libvncserver/hextile.c                   |  342 ---
 libvncserver/httpd.c                     |  600 -----
 libvncserver/libvncserver-config.h.cmake |   95 -
 libvncserver/lzoconf.h                   |  419 ---
 libvncserver/lzodefs.h                   | 1851 -------------
 libvncserver/main.c                      | 1178 ---------
 libvncserver/minilzo.c                   | 4192 ------------------------------
 libvncserver/minilzo.h                   |  108 -
 libvncserver/private.h                   |   35 -
 libvncserver/rfb/default8x16.h           |  261 --
 libvncserver/rfb/keysym.h                | 1638 ------------
 libvncserver/rfb/rfb.h                   | 1188 ---------
 libvncserver/rfb/rfbclient.h             |  430 ---
 libvncserver/rfb/rfbproto.h              | 1431 ----------
 libvncserver/rfb/rfbregion.h             |   65 -
 libvncserver/rfbregion.c                 |  886 -------
 libvncserver/rfbserver.c                 | 3326 ------------------------
 libvncserver/rre.c                       |  309 ---
 libvncserver/scale.c                     |  416 ---
 libvncserver/scale.h                     |   10 -
 libvncserver/selbox.c                    |  300 ---
 libvncserver/sockets.c                   |  737 ------
 libvncserver/stats.c                     |  478 ----
 libvncserver/tableinit24.c               |  157 --
 libvncserver/tableinitcmtemplate.c       |   84 -
 libvncserver/tableinittctemplate.c       |  142 -
 libvncserver/tabletrans24template.c      |  281 --
 libvncserver/tabletranstemplate.c        |  117 -
 libvncserver/tight.c                     | 1824 -------------
 libvncserver/translate.c                 |  477 ----
 libvncserver/ultra.c                     |  231 --
 libvncserver/vncauth.c                   |  212 --
 libvncserver/zlib.c                      |  331 ---
 libvncserver/zrle.c                      |  257 --
 libvncserver/zrleencodetemplate.c        |  316 ---
 libvncserver/zrleoutstream.c             |  275 --
 libvncserver/zrleoutstream.h             |   62 -
 libvncserver/zrlepalettehelper.c         |   62 -
 libvncserver/zrlepalettehelper.h         |   46 -
 libvncserver/zrletypes.h                 |   30 -
 libvncserver/zywrletemplate.c            |  828 ------
 55 files changed, 52 insertions(+), 28637 deletions(-)
 create mode 100644 cmake/modules/FindLibVNCServer.cmake
 delete mode 100644 libvncserver/CMakeLists.txt
 delete mode 100644 libvncserver/auth.c
 delete mode 100644 libvncserver/cargs.c
 delete mode 100644 libvncserver/corre.c
 delete mode 100644 libvncserver/cursor.c
 delete mode 100644 libvncserver/cutpaste.c
 delete mode 100644 libvncserver/d3des.c
 delete mode 100644 libvncserver/d3des.h
 delete mode 100644 libvncserver/draw.c
 delete mode 100644 libvncserver/font.c
 delete mode 100644 libvncserver/hextile.c
 delete mode 100644 libvncserver/httpd.c
 delete mode 100644 libvncserver/libvncserver-config.h.cmake
 delete mode 100644 libvncserver/lzoconf.h
 delete mode 100644 libvncserver/lzodefs.h
 delete mode 100644 libvncserver/main.c
 delete mode 100644 libvncserver/minilzo.c
 delete mode 100644 libvncserver/minilzo.h
 delete mode 100644 libvncserver/private.h
 delete mode 100644 libvncserver/rfb/default8x16.h
 delete mode 100644 libvncserver/rfb/keysym.h
 delete mode 100644 libvncserver/rfb/rfb.h
 delete mode 100644 libvncserver/rfb/rfbclient.h
 delete mode 100644 libvncserver/rfb/rfbproto.h
 delete mode 100644 libvncserver/rfb/rfbregion.h
 delete mode 100644 libvncserver/rfbregion.c
 delete mode 100644 libvncserver/rfbserver.c
 delete mode 100644 libvncserver/rre.c
 delete mode 100644 libvncserver/scale.c
 delete mode 100644 libvncserver/scale.h
 delete mode 100644 libvncserver/selbox.c
 delete mode 100644 libvncserver/sockets.c
 delete mode 100644 libvncserver/stats.c
 delete mode 100644 libvncserver/tableinit24.c
 delete mode 100644 libvncserver/tableinitcmtemplate.c
 delete mode 100644 libvncserver/tableinittctemplate.c
 delete mode 100644 libvncserver/tabletrans24template.c
 delete mode 100644 libvncserver/tabletranstemplate.c
 delete mode 100644 libvncserver/tight.c
 delete mode 100644 libvncserver/translate.c
 delete mode 100644 libvncserver/ultra.c
 delete mode 100644 libvncserver/vncauth.c
 delete mode 100644 libvncserver/zlib.c
 delete mode 100644 libvncserver/zrle.c
 delete mode 100644 libvncserver/zrleencodetemplate.c
 delete mode 100644 libvncserver/zrleoutstream.c
 delete mode 100644 libvncserver/zrleoutstream.h
 delete mode 100644 libvncserver/zrlepalettehelper.c
 delete mode 100644 libvncserver/zrlepalettehelper.h
 delete mode 100644 libvncserver/zrletypes.h
 delete mode 100644 libvncserver/zywrletemplate.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 78c19b3..7b0af64 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -26,6 +26,13 @@ if(NOT INSIDE_KDENETWORK)
     include_directories(${CMAKE_SOURCE_DIR} ${CMAKE_BINARY_DIR} ${KDE4_INCLUDES})
 endif(NOT INSIDE_KDENETWORK)
 
+set(CMAKE_MODULE_PATH
+    "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules"
+    ${CMAKE_MODULE_PATH}
+)
+
+find_package(LibVNCServer REQUIRED)
+
 macro_optional_find_package(TelepathyQt4)
 macro_log_feature(TelepathyQt4_FOUND "telepathy-qt" "Telepathy Qt Bindings" "http://telepathy.freedesktop.org" FALSE "0.9" "Needed to build Telepathy Tubes support.")
 
@@ -35,8 +42,6 @@ macro_bool_to_01(X11_XShm_FOUND HAVE_XSHM)
 include_directories ("${CMAKE_CURRENT_BINARY_DIR}/krfb"
                      "${CMAKE_CURRENT_SOURCE_DIR}/krfb"
                      "${CMAKE_CURRENT_SOURCE_DIR}/krfb/ui"
-                     "${CMAKE_CURRENT_SOURCE_DIR}/libvncserver/"
-                     "${CMAKE_CURRENT_BINARY_DIR}/libvncserver/"
 )
 
 if(Q_WS_X11)
@@ -45,9 +50,8 @@ if(Q_WS_X11)
   endif(NOT X11_XTest_FOUND)
 endif(Q_WS_X11)
 
-add_subdirectory(libvncserver)
 add_subdirectory(krfb)
-add_subdirectory (framebuffers)
+add_subdirectory(framebuffers)
 add_subdirectory(doc)
 
 if (NOT INSIDE_KDENETWORK)
diff --git a/cmake/modules/FindLibVNCServer.cmake b/cmake/modules/FindLibVNCServer.cmake
new file mode 100644
index 0000000..5927ab2
--- /dev/null
+++ b/cmake/modules/FindLibVNCServer.cmake
@@ -0,0 +1,41 @@
+# cmake macro to test LIBVNCSERVER LIB
+
+# Copyright (c) 2006, Alessandro Praduroux <pradu@pradu.it>
+# Copyright (c) 2007, Urs Wolfer <uwolfer @ kde.org>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+INCLUDE(CheckPointerMember)
+
+IF (LIBVNCSERVER_INCLUDE_DIR AND LIBVNCSERVER_LIBRARIES)
+    # Already in cache, be silent
+    SET(LIBVNCSERVER_FIND_QUIETLY TRUE)
+ENDIF (LIBVNCSERVER_INCLUDE_DIR AND LIBVNCSERVER_LIBRARIES)
+
+FIND_PATH(LIBVNCSERVER_INCLUDE_DIR rfb/rfb.h)
+
+FIND_LIBRARY(LIBVNCSERVER_LIBRARIES NAMES vncserver libvncserver)
+
+# libvncserver and libvncclient are in the same package, so it does
+# not make sense to add a new cmake script for finding libvncclient.
+# instead just find the libvncclient also in this file.
+FIND_PATH(LIBVNCCLIENT_INCLUDE_DIR rfb/rfbclient.h)
+FIND_LIBRARY(LIBVNCCLIENT_LIBRARIES NAMES vncclient libvncclient)
+
+IF (LIBVNCSERVER_INCLUDE_DIR AND LIBVNCSERVER_LIBRARIES)
+   SET(CMAKE_REQUIRED_INCLUDES "${LIBVNCSERVER_INCLUDE_DIR}" "${CMAKE_REQUIRED_INCLUDES}")
+   CHECK_POINTER_MEMBER(rfbClient* GotXCutText rfb/rfbclient.h LIBVNCSERVER_FOUND)
+ENDIF (LIBVNCSERVER_INCLUDE_DIR AND LIBVNCSERVER_LIBRARIES)
+
+IF (LIBVNCSERVER_FOUND)
+  IF (NOT LIBVNCSERVER_FIND_QUIETLY)
+    MESSAGE(STATUS "Found LibVNCServer: ${LIBVNCSERVER_LIBRARIES}")
+  ENDIF (NOT LIBVNCSERVER_FIND_QUIETLY)
+ELSE (LIBVNCSERVER_FOUND)
+  IF (LIBVNCSERVER_FIND_REQUIRED)
+    MESSAGE(FATAL_ERROR "Could NOT find acceptable version of LibVNCServer (version 0.9 or later required).")
+  ENDIF (LIBVNCSERVER_FIND_REQUIRED)
+ENDIF (LIBVNCSERVER_FOUND)
+
+MARK_AS_ADVANCED(LIBVNCSERVER_INCLUDE_DIR LIBVNCSERVER_LIBRARIES)
\ No newline at end of file
diff --git a/krfb/CMakeLists.txt b/krfb/CMakeLists.txt
index bbc508d..08ee30c 100644
--- a/krfb/CMakeLists.txt
+++ b/krfb/CMakeLists.txt
@@ -20,6 +20,7 @@ target_link_libraries (krfbprivate
                        ${QT_QTCORE_LIBRARY}
                        ${QT_QTGUI_LIBRARY}
                        ${X11_X11_LIB}
+                       ${LIBVNCSERVER_LIBRARIES}
 )
 
 set_target_properties (krfbprivate PROPERTIES
@@ -104,6 +105,7 @@ target_link_libraries (krfb
                        ${QT_QTNETWORK_LIBRARY}
                        ${KDE4_KDNSSD_LIBS}
                        ${KDE4_KDEUI_LIBS}
+                       ${LIBVNCSERVER_LIBRARIES}
 )
 
 if(TelepathyQt4_FOUND)
diff --git a/krfb/rfb.h b/krfb/rfb.h
index 40308a2..fa94eda 100644
--- a/krfb/rfb.h
+++ b/krfb/rfb.h
@@ -6,7 +6,7 @@
 #ifndef KRFB_RFB_H
 #define KRFB_RFB_H
 
-#include "../libvncserver/rfb/rfb.h"
+#include "rfb/rfb.h"
 
 #undef TRUE
 #undef FALSE
diff --git a/libvncserver/CMakeLists.txt b/libvncserver/CMakeLists.txt
deleted file mode 100644
index a7d831c..0000000
--- a/libvncserver/CMakeLists.txt
+++ /dev/null
@@ -1,132 +0,0 @@
-# Striped down version of libvncserver's original CMakeLists.txt
-
-project(LibVNCServer)
-include(CheckFunctionExists)
-include(CheckIncludeFile)
-include(CheckTypeSize)
-include(TestBigEndian)
-include(MacroBoolTo01)
-
-set(FULL_PACKAGE_NAME      "Krfb LibVNCServer")
-set(PACKAGE_VERSION        "0.9.8-10-g17ce0c5")
-
-include_directories(${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})
-
-macro_optional_find_package(ZLIB)
-macro_log_feature(ZLIB_FOUND "ZLib" "The Zlib compression library" "http://www.zlib.net" FALSE "" "Used by the vncserver library.")
-
-macro_optional_find_package(JPEG)
-macro_log_feature(JPEG_FOUND "LibJPEG" "The JPEG library" "" FALSE "" "Used by the vncserver library")
-
-macro_bool_to_01(ZLIB_FOUND LIBVNCSERVER_HAVE_LIBZ)
-macro_bool_to_01(JPEG_FOUND LIBVNCSERVER_HAVE_LIBJPEG)
-option(LIBVNCSERVER_ALLOW24BPP "Allow 24 bpp" ON)
-# if(GNUTLS_FOUND)
-#   set(LIBVNCSERVER_WITH_CLIENT_TLS 1)
-# endif(GNUTLS_FOUND)
-# if(LIBGCRYPT_LIBRARIES)
-#   message(STATUS "Found libgcrypt: ${LIBGCRYPT_LIBRARIES}")
-#   set(LIBVNCSERVER_WITH_CLIENT_GCRYPT 1)
-# endif(LIBGCRYPT_LIBRARIES)
-
-
-check_include_file("fcntl.h"       LIBVNCSERVER_HAVE_FCNTL_H)
-check_include_file("netinet/in.h"  LIBVNCSERVER_HAVE_NETINET_IN_H)
-check_include_file("sys/socket.h"  LIBVNCSERVER_HAVE_SYS_SOCKET_H)
-check_include_file("sys/stat.h"    LIBVNCSERVER_HAVE_SYS_STAT_H)
-check_include_file("sys/time.h"    LIBVNCSERVER_HAVE_SYS_TIME_H)
-check_include_file("sys/types.h"   LIBVNCSERVER_HAVE_SYS_TYPES_H)
-check_include_file("sys/wait.h"    LIBVNCSERVER_HAVE_SYS_WAIT_H)
-check_include_file("unistd.h"      LIBVNCSERVER_HAVE_UNISTD_H)
-
-# headers needed for check_type_size()
-check_include_file("arpa/inet.h"   HAVE_ARPA_INET_H)
-check_include_file("stdint.h"      HAVE_STDINT_H)
-check_include_file("stddef.h"      HAVE_STDDEF_H)
-check_include_file("sys/types.h"   HAVE_SYS_TYPES_H)
-
-check_function_exists(gettimeofday    LIBVNCSERVER_HAVE_GETTIMEOFDAY)
-
-macro_bool_to_01(CMAKE_USE_PTHREADS_INIT LIBVNCSERVER_HAVE_LIBPTHREAD)
-if(LIBVNCSERVER_HAVE_SYS_SOCKET_H)
-  # socklen_t
-  list(APPEND CMAKE_EXTRA_INCLUDE_FILES "sys/socket.h")
-endif(LIBVNCSERVER_HAVE_SYS_SOCKET_H)
-if(HAVE_ARPA_INET_H)
-  # in_addr_t
-  list(APPEND CMAKE_EXTRA_INCLUDE_FILES "arpa/inet.h")
-endif(HAVE_ARPA_INET_H)
-
-check_type_size(pid_t     LIBVNCSERVER_PID_T)
-check_type_size(size_t    LIBVNCSERVER_SIZE_T)
-check_type_size(socklen_t LIBVNCSERVER_SOCKLEN_T)
-check_type_size(in_addr_t LIBVNCSERVER_IN_ADDR_T)
-if(NOT HAVE_LIBVNCSERVER_IN_ADDR_T)
-  set(LIBVNCSERVER_NEED_INADDR_T 1)
-endif(NOT HAVE_LIBVNCSERVER_IN_ADDR_T)
-
-test_big_endian(LIBVNCSERVER_WORDS_BIGENDIAN)
-
-
-configure_file (${CMAKE_CURRENT_SOURCE_DIR}/libvncserver-config.h.cmake
-                ${CMAKE_CURRENT_BINARY_DIR}/libvncserver-config.h
-)
-
-set(LIBVNCSERVER_SOURCES
-    main.c
-    rfbserver.c
-    rfbregion.c
-    auth.c
-    sockets.c
-    stats.c
-    corre.c
-    hextile.c
-    rre.c
-    translate.c
-    cutpaste.c
-    httpd.c
-    cursor.c
-    font.c
-    draw.c
-    selbox.c
-    d3des.c
-    vncauth.c
-    cargs.c
-    minilzo.c
-    ultra.c
-    scale.c
-)
-
-if(ZLIB_FOUND)
-  add_definitions(-DLIBVNCSERVER_HAVE_LIBZ)
-  include_directories(${ZLIB_INCLUDE_DIR})
-  set(LIBVNCSERVER_SOURCES
-    ${LIBVNCSERVER_SOURCES}
-    zlib.c
-    zrle.c
-    zrleoutstream.c
-    zrlepalettehelper.c
-  )
-endif(ZLIB_FOUND)
-
-if(JPEG_FOUND)
-  add_definitions(-DLIBVNCSERVER_HAVE_LIBJPEG)
-  include_directories(${JPEG_INCLUDE_DIR})
-  set(LIBVNCSERVER_SOURCES
-    ${LIBVNCSERVER_SOURCES}
-    tight.c
-  )
-endif(JPEG_FOUND)
-
-
-add_library(vncserver STATIC ${LIBVNCSERVER_SOURCES})
-
-if(WIN32)
-  set(ADDITIONAL_LIBS ws2_32)
-endif(WIN32)
-
-target_link_libraries(vncserver
-    ${ADDITIONAL_LIBS}
-    ${ZLIB_LIBRARIES}
-    ${JPEG_LIBRARIES}
-)
diff --git a/libvncserver/auth.c b/libvncserver/auth.c
deleted file mode 100644
index c353a1e..0000000
--- a/libvncserver/auth.c
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * auth.c - deal with authentication.
- *
- * This file implements the VNC authentication protocol when setting up an RFB
- * connection.
- */
-
-/*
- *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-/* RFB 3.8 clients are well informed */
-void rfbClientSendString(rfbClientPtr cl, const char *reason);
-
-
-/*
- * Handle security types
- */
-
-static rfbSecurityHandler* securityHandlers = NULL;
-
-/*
- * This method registers a list of new security types.  
- * It avoids same security type getting registered multiple times. 
- * The order is not preserved if multiple security types are
- * registered at one-go.
- */
-void
-rfbRegisterSecurityHandler(rfbSecurityHandler* handler)
-{
-	rfbSecurityHandler *head = securityHandlers, *next = NULL;
-
-	if(handler == NULL)
-		return;
-
-	next = handler->next;
-
-	while(head != NULL) {
-		if(head == handler) {
-			rfbRegisterSecurityHandler(next);
-			return;
-		}
-
-		head = head->next;
-	}
-
-	handler->next = securityHandlers;
-	securityHandlers = handler;
-
-	rfbRegisterSecurityHandler(next);
-}
-
-/*
- * This method unregisters a list of security types. 
- * These security types won't be available for any new
- * client connection. 
- */
-void
-rfbUnregisterSecurityHandler(rfbSecurityHandler* handler)
-{
-	rfbSecurityHandler *cur = NULL, *pre = NULL;
-
-	if(handler == NULL)
-		return;
-
-	if(securityHandlers == handler) {
-		securityHandlers = securityHandlers->next;
-		rfbUnregisterSecurityHandler(handler->next);
-		return;
-	}
-
-	cur = pre = securityHandlers;
-
-	while(cur) {
-		if(cur == handler) {
-			pre->next = cur->next;
-			break;
-		}
-		pre = cur;
-		cur = cur->next;
-	}
-	rfbUnregisterSecurityHandler(handler->next);
-}
-
-/*
- * Send the authentication challenge.
- */
-
-static void
-rfbVncAuthSendChallenge(rfbClientPtr cl)
-{
-	
-    /* 4 byte header is alreay sent. Which is rfbSecTypeVncAuth 
-       (same as rfbVncAuth). Just send the challenge. */
-    rfbRandomBytes(cl->authChallenge);
-    if (rfbWriteExact(cl, (char *)cl->authChallenge, CHALLENGESIZE) < 0) {
-        rfbLogPerror("rfbAuthNewClient: write");
-        rfbCloseClient(cl);
-        return;
-    }
-    
-    /* Dispatch client input to rfbVncAuthProcessResponse. */
-    cl->state = RFB_AUTHENTICATION;
-}
-
-/*
- * Send the NO AUTHENTICATION. SCARR
- */
-
-static void
-rfbVncAuthNone(rfbClientPtr cl)
-{
-    uint32_t authResult;
-
-    if (cl->protocolMajorVersion==3 && cl->protocolMinorVersion > 7) {
-        rfbLog("rfbProcessClientSecurityType: returning securityResult for client rfb version >= 3.8\n");
-        authResult = Swap32IfLE(rfbVncAuthOK);
-        if (rfbWriteExact(cl, (char *)&authResult, 4) < 0) {
-            rfbLogPerror("rfbAuthProcessClientMessage: write");
-            rfbCloseClient(cl);
-            return;
-        }
-    }
-    cl->state = RFB_INITIALISATION;
-    return;
-}
-
-
-/*
- * Advertise the supported security types (protocol 3.7). Here before sending 
- * the list of security types to the client one more security type is added 
- * to the list if primaryType is not set to rfbSecTypeInvalid. This security
- * type is the standard vnc security type which does the vnc authentication
- * or it will be security type for no authentication.
- * Different security types will be added by applications using this library.
- */
-
-static rfbSecurityHandler VncSecurityHandlerVncAuth = {
-    rfbSecTypeVncAuth,
-    rfbVncAuthSendChallenge,
-    NULL
-};
-
-static rfbSecurityHandler VncSecurityHandlerNone = {
-    rfbSecTypeNone,
-    rfbVncAuthNone,
-    NULL
-};
-                        
-
-static void
-rfbSendSecurityTypeList(rfbClientPtr cl, int primaryType)
-{
-    /* The size of the message is the count of security types +1,
-     * since the first byte is the number of types. */
-    int size = 1;
-    rfbSecurityHandler* handler;
-#define MAX_SECURITY_TYPES 255
-    uint8_t buffer[MAX_SECURITY_TYPES+1];
-
-
-    /* Fill in the list of security types in the client structure. (NOTE: Not really in the client structure) */
-    switch (primaryType) {
-    case rfbSecTypeNone:
-        rfbRegisterSecurityHandler(&VncSecurityHandlerNone);
-        break;
-    case rfbSecTypeVncAuth:
-        rfbRegisterSecurityHandler(&VncSecurityHandlerVncAuth);
-        break;
-    }
-
-    for (handler = securityHandlers;
-	    handler && size<MAX_SECURITY_TYPES; handler = handler->next) {
-	buffer[size] = handler->type;
-	size++;
-    }
-    buffer[0] = (unsigned char)size-1;
-
-    /* Send the list. */
-    if (rfbWriteExact(cl, (char *)buffer, size) < 0) {
-	rfbLogPerror("rfbSendSecurityTypeList: write");
-	rfbCloseClient(cl);
-	return;
-    }
-
-    /*
-      * if count is 0, we need to send the reason and close the connection.
-      */
-    if(size <= 1) {
-	/* This means total count is Zero and so reason msg should be sent */
-	/* The execution should never reach here */
-	char* reason = "No authentication mode is registered!";
-
-	rfbClientSendString(cl, reason);
-	return;
-    }
-
-    /* Dispatch client input to rfbProcessClientSecurityType. */
-    cl->state = RFB_SECURITY_TYPE;
-}
-
-
-
-
-/*
- * Tell the client what security type will be used (protocol 3.3).
- */
-static void
-rfbSendSecurityType(rfbClientPtr cl, int32_t securityType)
-{
-    uint32_t value32;
-
-    /* Send the value. */
-    value32 = Swap32IfLE(securityType);
-    if (rfbWriteExact(cl, (char *)&value32, 4) < 0) {
-	rfbLogPerror("rfbSendSecurityType: write");
-	rfbCloseClient(cl);
-	return;
-    }
-
-    /* Decide what to do next. */
-    switch (securityType) {
-    case rfbSecTypeNone:
-	/* Dispatch client input to rfbProcessClientInitMessage. */
-	cl->state = RFB_INITIALISATION;
-	break;
-    case rfbSecTypeVncAuth:
-	/* Begin the standard VNC authentication procedure. */
-	rfbVncAuthSendChallenge(cl);
-	break;
-    default:
-	/* Impossible case (hopefully). */
-	rfbLogPerror("rfbSendSecurityType: assertion failed");
-	rfbCloseClient(cl);
-    }
-}
-
-
-
-/*
- * rfbAuthNewClient is called right after negotiating the protocol
- * version. Depending on the protocol version, we send either a code
- * for authentication scheme to be used (protocol 3.3), or a list of
- * possible "security types" (protocol 3.7).
- */
-
-void
-rfbAuthNewClient(rfbClientPtr cl)
-{
-    int32_t securityType = rfbSecTypeInvalid;
-
-    if (!cl->screen->authPasswdData || cl->reverseConnection) {
-	/* chk if this condition is valid or not. */
-	securityType = rfbSecTypeNone;
-    } else if (cl->screen->authPasswdData) {
- 	    securityType = rfbSecTypeVncAuth;
-    }
-
-    if (cl->protocolMajorVersion==3 && cl->protocolMinorVersion < 7)
-    {
-	/* Make sure we use only RFB 3.3 compatible security types. */
-	if (securityType == rfbSecTypeInvalid) {
-	    rfbLog("VNC authentication disabled - RFB 3.3 client rejected\n");
-	    rfbClientConnFailed(cl, "Your viewer cannot handle required "
-				"authentication methods");
-	    return;
-	}
-	rfbSendSecurityType(cl, securityType);
-    } else {
-	/* Here it's ok when securityType is set to rfbSecTypeInvalid. */
-	rfbSendSecurityTypeList(cl, securityType);
-    }
-}
-
-/*
- * Read the security type chosen by the client (protocol 3.7).
- */
-
-void
-rfbProcessClientSecurityType(rfbClientPtr cl)
-{
-    int n;
-    uint8_t chosenType;
-    rfbSecurityHandler* handler;
-    
-    /* Read the security type. */
-    n = rfbReadExact(cl, (char *)&chosenType, 1);
-    if (n <= 0) {
-	if (n == 0)
-	    rfbLog("rfbProcessClientSecurityType: client gone\n");
-	else
-	    rfbLogPerror("rfbProcessClientSecurityType: read");
-	rfbCloseClient(cl);
-	return;
-    }
-
-    /* Make sure it was present in the list sent by the server. */
-    for (handler = securityHandlers; handler; handler = handler->next) {
-	if (chosenType == handler->type) {
-	      rfbLog("rfbProcessClientSecurityType: executing handler for type %d\n", chosenType);
-	      handler->handler(cl);
-	      return;
-	}
-    }
-
-    rfbLog("rfbProcessClientSecurityType: wrong security type (%d) requested\n", chosenType);
-    rfbCloseClient(cl);
-}
-
-
-
-/*
- * rfbAuthProcessClientMessage is called when the client sends its
- * authentication response.
- */
-
-void
-rfbAuthProcessClientMessage(rfbClientPtr cl)
-{
-    int n;
-    uint8_t response[CHALLENGESIZE];
-    uint32_t authResult;
-
-    if ((n = rfbReadExact(cl, (char *)response, CHALLENGESIZE)) <= 0) {
-        if (n != 0)
-            rfbLogPerror("rfbAuthProcessClientMessage: read");
-        rfbCloseClient(cl);
-        return;
-    }
-
-    if(!cl->screen->passwordCheck(cl,(const char*)response,CHALLENGESIZE)) {
-        rfbErr("rfbAuthProcessClientMessage: password check failed\n");
-        authResult = Swap32IfLE(rfbVncAuthFailed);
-        if (rfbWriteExact(cl, (char *)&authResult, 4) < 0) {
-            rfbLogPerror("rfbAuthProcessClientMessage: write");
-        }
-	/* support RFB 3.8 clients, they expect a reason *why* it was disconnected */
-        if (cl->protocolMinorVersion > 7) {
-            rfbClientSendString(cl, "password check failed!");
-	}
-	else
-            rfbCloseClient(cl);
-        return;
-    }
-
-    authResult = Swap32IfLE(rfbVncAuthOK);
-
-    if (rfbWriteExact(cl, (char *)&authResult, 4) < 0) {
-        rfbLogPerror("rfbAuthProcessClientMessage: write");
-        rfbCloseClient(cl);
-        return;
-    }
-
-    cl->state = RFB_INITIALISATION;
-}
diff --git a/libvncserver/cargs.c b/libvncserver/cargs.c
deleted file mode 100644
index 186723a..0000000
--- a/libvncserver/cargs.c
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- *  This parses the command line arguments. It was seperated from main.c by 
- *  Justin Dearing <jdeari01@longisland.poly.edu>.
- */
-
-/*
- *  LibVNCServer (C) 2001 Johannes E. Schindelin <Johannes.Schindelin@gmx.de>
- *  Original OSXvnc (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  see GPL (latest version) for full details
- */
-
-#include "rfb/rfb.h"
-
-extern int rfbStringToAddr(char *str, in_addr_t *iface);
-
-void
-rfbUsage(void)
-{
-    rfbProtocolExtension* extension;
-
-    fprintf(stderr, "-rfbport port          TCP port for RFB protocol\n");
-    fprintf(stderr, "-rfbwait time          max time in ms to wait for RFB client\n");
-    fprintf(stderr, "-rfbauth passwd-file   use authentication on RFB protocol\n"
-                    "                       (use 'storepasswd' to create a password file)\n");
-    fprintf(stderr, "-rfbversion 3.x        Set the version of the RFB we choose to advertise\n");
-    fprintf(stderr, "-permitfiletransfer    permit file transfer support\n");
-    fprintf(stderr, "-passwd plain-password use authentication \n"
-                    "                       (use plain-password as password, USE AT YOUR RISK)\n");
-    fprintf(stderr, "-deferupdate time      time in ms to defer updates "
-                                                             "(default 40)\n");
-    fprintf(stderr, "-deferptrupdate time   time in ms to defer pointer updates"
-                                                           " (default none)\n");
-    fprintf(stderr, "-desktop name          VNC desktop name (default \"LibVNCServer\")\n");
-    fprintf(stderr, "-alwaysshared          always treat new clients as shared\n");
-    fprintf(stderr, "-nevershared           never treat new clients as shared\n");
-    fprintf(stderr, "-dontdisconnect        don't disconnect existing clients when a "
-                                                             "new non-shared\n"
-                    "                       connection comes in (refuse new connection "
-                                                                "instead)\n");
-    fprintf(stderr, "-httpdir dir-path      enable http server using dir-path home\n");
-    fprintf(stderr, "-httpport portnum      use portnum for http connection\n");
-    fprintf(stderr, "-enablehttpproxy       enable http proxy support\n");
-    fprintf(stderr, "-progressive height    enable progressive updating for slow links\n");
-    fprintf(stderr, "-listen ipaddr         listen for connections only on network interface with\n");
-    fprintf(stderr, "                       addr ipaddr. '-listen localhost' and hostname work too.\n");
-
-    for(extension=rfbGetExtensionIterator();extension;extension=extension->next)
-	if(extension->usage)
-		extension->usage();
-    rfbReleaseExtensionIterator();
-}
-
-/* purges COUNT arguments from ARGV at POSITION and decrements ARGC.
-   POSITION points to the first non purged argument afterwards. */
-void rfbPurgeArguments(int* argc,int* position,int count,char *argv[])
-{
-  int amount=(*argc)-(*position)-count;
-  if(amount)
-    memmove(argv+(*position),argv+(*position)+count,sizeof(char*)*amount);
-  (*argc)-=count;
-}
-
-rfbBool 
-rfbProcessArguments(rfbScreenInfoPtr rfbScreen,int* argc, char *argv[])
-{
-    int i,i1;
-
-    if(!argc) return TRUE;
-    
-    for (i = i1 = 1; i < *argc;) {
-        if (strcmp(argv[i], "-help") == 0) {
-	    rfbUsage();
-	    return FALSE;
-	} else if (strcmp(argv[i], "-rfbport") == 0) { /* -rfbport port */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-	    rfbScreen->port = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-rfbwait") == 0) {  /* -rfbwait ms */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-	    rfbScreen->maxClientWait = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-rfbauth") == 0) {  /* -rfbauth passwd-file */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            rfbScreen->authPasswdData = argv[++i];
-
-        } else if (strcmp(argv[i], "-permitfiletransfer") == 0) {  /* -permitfiletransfer  */
-            rfbScreen->permitFileTransfer = TRUE;
-        } else if (strcmp(argv[i], "-rfbversion") == 0) {  /* -rfbversion 3.6  */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-	    sscanf(argv[++i],"%d.%d", &rfbScreen->protocolMajorVersion, &rfbScreen->protocolMinorVersion);
-	} else if (strcmp(argv[i], "-passwd") == 0) {  /* -passwd password */
-	    char **passwds = malloc(sizeof(char**)*2);
-	    if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-	    passwds[0] = argv[++i];
-	    passwds[1] = NULL;
-	    rfbScreen->authPasswdData = (void*)passwds;
-	    rfbScreen->passwordCheck = rfbCheckPasswordByList;
-        } else if (strcmp(argv[i], "-deferupdate") == 0) {  /* -deferupdate milliseconds */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            rfbScreen->deferUpdateTime = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-deferptrupdate") == 0) {  /* -deferptrupdate milliseconds */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            rfbScreen->deferPtrUpdateTime = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-desktop") == 0) {  /* -desktop desktop-name */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            rfbScreen->desktopName = argv[++i];
-        } else if (strcmp(argv[i], "-alwaysshared") == 0) {
-	    rfbScreen->alwaysShared = TRUE;
-        } else if (strcmp(argv[i], "-nevershared") == 0) {
-            rfbScreen->neverShared = TRUE;
-        } else if (strcmp(argv[i], "-dontdisconnect") == 0) {
-            rfbScreen->dontDisconnect = TRUE;
-        } else if (strcmp(argv[i], "-httpdir") == 0) {  /* -httpdir directory-path */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            rfbScreen->httpDir = argv[++i];
-        } else if (strcmp(argv[i], "-httpport") == 0) {  /* -httpport portnum */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            rfbScreen->httpPort = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-enablehttpproxy") == 0) {
-            rfbScreen->httpEnableProxyConnect = TRUE;
-        } else if (strcmp(argv[i], "-progressive") == 0) {  /* -httpport portnum */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            rfbScreen->progressiveSliceHeight = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-listen") == 0) {  /* -listen ipaddr */
-            if (i + 1 >= *argc) {
-		rfbUsage();
-		return FALSE;
-	    }
-            if (! rfbStringToAddr(argv[++i], &(rfbScreen->listenInterface))) {
-                return FALSE;
-            }
-        } else {
-	    rfbProtocolExtension* extension;
-	    int handled=0;
-
-	    for(extension=rfbGetExtensionIterator();handled==0 && extension;
-			extension=extension->next)
-		if(extension->processArgument)
-			handled = extension->processArgument(*argc - i, argv + i);
-	    rfbReleaseExtensionIterator();
-
-	    if(handled==0) {
-		i++;
-		i1=i;
-		continue;
-	    }
-	    i+=handled-1;
-	}
-	/* we just remove the processed arguments from the list */
-	rfbPurgeArguments(argc,&i1,i-i1+1,argv);
-	i=i1;
-    }
-    return TRUE;
-}
-
-rfbBool 
-rfbProcessSizeArguments(int* width,int* height,int* bpp,int* argc, char *argv[])
-{
-    int i,i1;
-
-    if(!argc) return TRUE;
-    for (i = i1 = 1; i < *argc-1;) {
-        if (strcmp(argv[i], "-bpp") == 0) {
-               *bpp = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-width") == 0) {
-               *width = atoi(argv[++i]);
-        } else if (strcmp(argv[i], "-height") == 0) {
-               *height = atoi(argv[++i]);
-        } else {
-	    i++;
-	    i1=i;
-	    continue;
-	}
-	rfbPurgeArguments(argc,&i1,i-i1,argv);
-	i=i1;
-    }
-    return TRUE;
-}
-
diff --git a/libvncserver/corre.c b/libvncserver/corre.c
deleted file mode 100644
index be9eae5..0000000
--- a/libvncserver/corre.c
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * corre.c
- *
- * Routines to implement Compact Rise-and-Run-length Encoding (CoRRE).  This
- * code is based on krw's original javatel rfbserver.
- */
-
-/*
- *  Copyright (C) 2002 RealVNC Ltd.
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-/*
- * cl->beforeEncBuf contains pixel data in the client's format.
- * cl->afterEncBuf contains the RRE encoded version.  If the RRE encoded version is
- * larger than the raw data or if it exceeds cl->afterEncBufSize then
- * raw encoding is used instead.
- */
-
-static int subrectEncode8(rfbClientPtr cl, uint8_t *data, int w, int h);
-static int subrectEncode16(rfbClientPtr cl, uint16_t *data, int w, int h);
-static int subrectEncode32(rfbClientPtr cl, uint32_t *data, int w, int h);
-static uint32_t getBgColour(char *data, int size, int bpp);
-static rfbBool rfbSendSmallRectEncodingCoRRE(rfbClientPtr cl, int x, int y,
-                                          int w, int h);
-
-
-/*
- * rfbSendRectEncodingCoRRE - send an arbitrary size rectangle using CoRRE
- * encoding.
- */
-
-rfbBool
-rfbSendRectEncodingCoRRE(rfbClientPtr cl,
-                         int x,
-                         int y,
-                         int w,
-                         int h)
-{
-    if (h > cl->correMaxHeight) {
-        return (rfbSendRectEncodingCoRRE(cl, x, y, w, cl->correMaxHeight) &&
-		rfbSendRectEncodingCoRRE(cl, x, y + cl->correMaxHeight, w,
-					 h - cl->correMaxHeight));
-    }
-
-    if (w > cl->correMaxWidth) {
-        return (rfbSendRectEncodingCoRRE(cl, x, y, cl->correMaxWidth, h) &&
-		rfbSendRectEncodingCoRRE(cl, x + cl->correMaxWidth, y,
-					 w - cl->correMaxWidth, h));
-    }
-
-    rfbSendSmallRectEncodingCoRRE(cl, x, y, w, h);
-    return TRUE;
-}
-
-
-
-/*
- * rfbSendSmallRectEncodingCoRRE - send a small (guaranteed < 256x256)
- * rectangle using CoRRE encoding.
- */
-
-static rfbBool
-rfbSendSmallRectEncodingCoRRE(rfbClientPtr cl,
-                              int x,
-                              int y,
-                              int w,
-                              int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    rfbRREHeader hdr;
-    int nSubrects;
-    int i;
-    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)
-                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));
-
-    int maxRawSize = (cl->scaledScreen->width * cl->scaledScreen->height
-                      * (cl->format.bitsPerPixel / 8));
-
-    if (cl->beforeEncBufSize < maxRawSize) {
-        cl->beforeEncBufSize = maxRawSize;
-        if (cl->beforeEncBuf == NULL)
-            cl->beforeEncBuf = (char *)malloc(cl->beforeEncBufSize);
-        else
-            cl->beforeEncBuf = (char *)realloc(cl->beforeEncBuf, cl->beforeEncBufSize);
-    }
-
-    if (cl->afterEncBufSize < maxRawSize) {
-        cl->afterEncBufSize = maxRawSize;
-        if (cl->afterEncBuf == NULL)
-            cl->afterEncBuf = (char *)malloc(cl->afterEncBufSize);
-        else
-            cl->afterEncBuf = (char *)realloc(cl->afterEncBuf, cl->afterEncBufSize);
-    }
-
-    (*cl->translateFn)(cl->translateLookupTable,&(cl->screen->serverFormat),
-                       &cl->format, fbptr, cl->beforeEncBuf,
-                       cl->scaledScreen->paddedWidthInBytes, w, h);
-
-    switch (cl->format.bitsPerPixel) {
-    case 8:
-        nSubrects = subrectEncode8(cl, (uint8_t *)cl->beforeEncBuf, w, h);
-        break;
-    case 16:
-        nSubrects = subrectEncode16(cl, (uint16_t *)cl->beforeEncBuf, w, h);
-        break;
-    case 32:
-        nSubrects = subrectEncode32(cl, (uint32_t *)cl->beforeEncBuf, w, h);
-        break;
-    default:
-        rfbLog("getBgColour: bpp %d?\n",cl->format.bitsPerPixel);
-        return FALSE;
-    }
-        
-    if (nSubrects < 0) {
-
-        /* RRE encoding was too large, use raw */
-
-        return rfbSendRectEncodingRaw(cl, x, y, w, h);
-    }
-
-    rfbStatRecordEncodingSent(cl,rfbEncodingCoRRE,
-        sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader + cl->afterEncBufLen,
-        sz_rfbFramebufferUpdateRectHeader + w * h * (cl->format.bitsPerPixel / 8));
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader
-        > UPDATE_BUF_SIZE)
-    {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.r.x = Swap16IfLE(x);
-    rect.r.y = Swap16IfLE(y);
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-    rect.encoding = Swap32IfLE(rfbEncodingCoRRE);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-           sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    hdr.nSubrects = Swap32IfLE(nSubrects);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbRREHeader);
-    cl->ublen += sz_rfbRREHeader;
-
-    for (i = 0; i < cl->afterEncBufLen;) {
-
-        int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;
-
-        if (i + bytesToCopy > cl->afterEncBufLen) {
-            bytesToCopy = cl->afterEncBufLen - i;
-        }
-
-        memcpy(&cl->updateBuf[cl->ublen], &cl->afterEncBuf[i], bytesToCopy);
-
-        cl->ublen += bytesToCopy;
-        i += bytesToCopy;
-
-        if (cl->ublen == UPDATE_BUF_SIZE) {
-            if (!rfbSendUpdateBuf(cl))
-                return FALSE;
-        }
-    }
-
-    return TRUE;
-}
-
-
-
-/*
- * subrectEncode() encodes the given multicoloured rectangle as a background 
- * colour overwritten by single-coloured rectangles.  It returns the number 
- * of subrectangles in the encoded buffer, or -1 if subrect encoding won't
- * fit in the buffer.  It puts the encoded rectangles in cl->afterEncBuf.  The
- * single-colour rectangle partition is not optimal, but does find the biggest
- * horizontal or vertical rectangle top-left anchored to each consecutive 
- * coordinate position.
- *
- * The coding scheme is simply [<bgcolour><subrect><subrect>...] where each 
- * <subrect> is [<colour><x><y><w><h>].
- */
-
-#define DEFINE_SUBRECT_ENCODE(bpp)                                            \
-static int                                                                    \
-subrectEncode##bpp(rfbClientPtr client, uint##bpp##_t *data, int w, int h) {                       \
-    uint##bpp##_t cl;                                                         \
-    rfbCoRRERectangle subrect;                                                \
-    int x,y;                                                                  \
-    int i,j;                                                                  \
-    int hx=0,hy,vx=0,vy;                                                      \
-    int hyflag;                                                               \
-    uint##bpp##_t *seg;                                                       \
-    uint##bpp##_t *line;                                                      \
-    int hw,hh,vw,vh;                                                          \
-    int thex,they,thew,theh;                                                  \
-    int numsubs = 0;                                                          \
-    int newLen;                                                               \
-    uint##bpp##_t bg = (uint##bpp##_t)getBgColour((char*)data,w*h,bpp);       \
-                                                                              \
-    *((uint##bpp##_t*)client->afterEncBuf) = bg;                                      \
-                                                                              \
-    client->afterEncBufLen = (bpp/8);                                                 \
-                                                                              \
-    for (y=0; y<h; y++) {                                                     \
-      line = data+(y*w);                                                      \
-      for (x=0; x<w; x++) {                                                   \
-        if (line[x] != bg) {                                                  \
-          cl = line[x];                                                       \
-          hy = y-1;                                                           \
-          hyflag = 1;                                                         \
-          for (j=y; j<h; j++) {                                               \
-            seg = data+(j*w);                                                 \
-            if (seg[x] != cl) {break;}                                        \
-            i = x;                                                            \
-            while ((seg[i] == cl) && (i < w)) i += 1;                         \
-            i -= 1;                                                           \
-            if (j == y) vx = hx = i;                                          \
-            if (i < vx) vx = i;                                               \
-            if ((hyflag > 0) && (i >= hx)) {hy += 1;} else {hyflag = 0;}      \
-          }                                                                   \
-          vy = j-1;                                                           \
-                                                                              \
-          /*  We now have two possible subrects: (x,y,hx,hy) and (x,y,vx,vy)  \
-           *  We'll choose the bigger of the two.                             \
-           */                                                                 \
-          hw = hx-x+1;                                                        \
-          hh = hy-y+1;                                                        \
-          vw = vx-x+1;                                                        \
-          vh = vy-y+1;                                                        \
-                                                                              \
-          thex = x;                                                           \
-          they = y;                                                           \
-                                                                              \
-          if ((hw*hh) > (vw*vh)) {                                            \
-            thew = hw;                                                        \
-            theh = hh;                                                        \
-          } else {                                                            \
-            thew = vw;                                                        \
-            theh = vh;                                                        \
-          }                                                                   \
-                                                                              \
-          subrect.x = thex;                                                   \
-          subrect.y = they;                                                   \
-          subrect.w = thew;                                                   \
-          subrect.h = theh;                                                   \
-                                                                              \
-          newLen = client->afterEncBufLen + (bpp/8) + sz_rfbCoRRERectangle;           \
-          if ((newLen > (w * h * (bpp/8))) || (newLen > client->afterEncBufSize))     \
-            return -1;                                                        \
-                                                                              \
-          numsubs += 1;                                                       \
-          *((uint##bpp##_t*)(client->afterEncBuf + client->afterEncBufLen)) = cl;             \
-          client->afterEncBufLen += (bpp/8);                                          \
-          memcpy(&client->afterEncBuf[client->afterEncBufLen],&subrect,sz_rfbCoRRERectangle); \
-          client->afterEncBufLen += sz_rfbCoRRERectangle;                             \
-                                                                              \
-          /*                                                                  \
-           * Now mark the subrect as done.                                    \
-           */                                                                 \
-          for (j=they; j < (they+theh); j++) {                                \
-            for (i=thex; i < (thex+thew); i++) {                              \
-              data[j*w+i] = bg;                                               \
-            }                                                                 \
-          }                                                                   \
-        }                                                                     \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    return numsubs;                                                           \
-}
-
-DEFINE_SUBRECT_ENCODE(8)
-DEFINE_SUBRECT_ENCODE(16)
-DEFINE_SUBRECT_ENCODE(32)
-
-
-/*
- * getBgColour() gets the most prevalent colour in a byte array.
- */
-static uint32_t
-getBgColour(char *data, int size, int bpp)
-{
-
-#define NUMCLRS 256
-  
-  static int counts[NUMCLRS];
-  int i,j,k;
-
-  int maxcount = 0;
-  uint8_t maxclr = 0;
-
-  if (bpp != 8) {
-    if (bpp == 16) {
-      return ((uint16_t *)data)[0];
-    } else if (bpp == 32) {
-      return ((uint32_t *)data)[0];
-    } else {
-      rfbLog("getBgColour: bpp %d?\n",bpp);
-      return 0;
-    }
-  }
-
-  for (i=0; i<NUMCLRS; i++) {
-    counts[i] = 0;
-  }
-
-  for (j=0; j<size; j++) {
-    k = (int)(((uint8_t *)data)[j]);
-    if (k >= NUMCLRS) {
-      rfbLog("getBgColour: unusual colour = %d\n", k);
-      return 0;
-    }
-    counts[k] += 1;
-    if (counts[k] > maxcount) {
-      maxcount = counts[k];
-      maxclr = ((uint8_t *)data)[j];
-    }
-  }
-  
-  return maxclr;
-}
diff --git a/libvncserver/cursor.c b/libvncserver/cursor.c
deleted file mode 100644
index ef6d8f8..0000000
--- a/libvncserver/cursor.c
+++ /dev/null
@@ -1,756 +0,0 @@
-/*
- * cursor.c - support for cursor shape updates.
- */
-
-/*
- *  Copyright (C) 2000, 2001 Const Kaplinsky.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-#include "rfb/rfbregion.h"
-#include "private.h"
-
-void rfbScaledScreenUpdate(rfbScreenInfoPtr screen, int x1, int y1, int x2, int y2);
-
-/*
- * Send cursor shape either in X-style format or in client pixel format.
- */
-
-rfbBool
-rfbSendCursorShape(rfbClientPtr cl)
-{
-    rfbCursorPtr pCursor;
-    rfbFramebufferUpdateRectHeader rect;
-    rfbXCursorColors colors;
-    int saved_ublen;
-    int bitmapRowBytes, maskBytes, dataBytes;
-    int i, j;
-    uint8_t *bitmapData;
-    uint8_t bitmapByte;
-
-    /* TODO: scale the cursor data to the correct size */
-
-    pCursor = cl->screen->getCursorPtr(cl);
-    /*if(!pCursor) return TRUE;*/
-
-    if (cl->useRichCursorEncoding) {
-      if(pCursor && !pCursor->richSource)
-	rfbMakeRichCursorFromXCursor(cl->screen,pCursor);
-      rect.encoding = Swap32IfLE(rfbEncodingRichCursor);
-    } else {
-       if(pCursor && !pCursor->source)
-	 rfbMakeXCursorFromRichCursor(cl->screen,pCursor);
-       rect.encoding = Swap32IfLE(rfbEncodingXCursor);
-    }
-
-    /* If there is no cursor, send update with empty cursor data. */
-
-    if ( pCursor && pCursor->width == 1 &&
-	 pCursor->height == 1 &&
-	 pCursor->mask[0] == 0 ) {
-	pCursor = NULL;
-    }
-
-    if (pCursor == NULL) {
-	if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE ) {
-	    if (!rfbSendUpdateBuf(cl))
-		return FALSE;
-	}
-	rect.r.x = rect.r.y = 0;
-	rect.r.w = rect.r.h = 0;
-	memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-	       sz_rfbFramebufferUpdateRectHeader);
-	cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-	if (!rfbSendUpdateBuf(cl))
-	    return FALSE;
-
-	return TRUE;
-    }
-
-    /* Calculate data sizes. */
-
-    bitmapRowBytes = (pCursor->width + 7) / 8;
-    maskBytes = bitmapRowBytes * pCursor->height;
-    dataBytes = (cl->useRichCursorEncoding) ?
-	(pCursor->width * pCursor->height *
-	 (cl->format.bitsPerPixel / 8)) : maskBytes;
-
-    /* Send buffer contents if needed. */
-
-    if ( cl->ublen + sz_rfbFramebufferUpdateRectHeader +
-	 sz_rfbXCursorColors + maskBytes + dataBytes > UPDATE_BUF_SIZE ) {
-	if (!rfbSendUpdateBuf(cl))
-	    return FALSE;
-    }
-
-    if ( cl->ublen + sz_rfbFramebufferUpdateRectHeader +
-	 sz_rfbXCursorColors + maskBytes + dataBytes > UPDATE_BUF_SIZE ) {
-	return FALSE;		/* FIXME. */
-    }
-
-    saved_ublen = cl->ublen;
-
-    /* Prepare rectangle header. */
-
-    rect.r.x = Swap16IfLE(pCursor->xhot);
-    rect.r.y = Swap16IfLE(pCursor->yhot);
-    rect.r.w = Swap16IfLE(pCursor->width);
-    rect.r.h = Swap16IfLE(pCursor->height);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    /* Prepare actual cursor data (depends on encoding used). */
-
-    if (!cl->useRichCursorEncoding) {
-	/* XCursor encoding. */
-	colors.foreRed   = (char)(pCursor->foreRed   >> 8);
-	colors.foreGreen = (char)(pCursor->foreGreen >> 8);
-	colors.foreBlue  = (char)(pCursor->foreBlue  >> 8);
-	colors.backRed   = (char)(pCursor->backRed   >> 8);
-	colors.backGreen = (char)(pCursor->backGreen >> 8);
-	colors.backBlue  = (char)(pCursor->backBlue  >> 8);
-
-	memcpy(&cl->updateBuf[cl->ublen], (char *)&colors, sz_rfbXCursorColors);
-	cl->ublen += sz_rfbXCursorColors;
-
-	bitmapData = (uint8_t *)pCursor->source;
-
-	for (i = 0; i < pCursor->height; i++) {
-	    for (j = 0; j < bitmapRowBytes; j++) {
-		bitmapByte = bitmapData[i * bitmapRowBytes + j];
-		cl->updateBuf[cl->ublen++] = (char)bitmapByte;
-	    }
-	}
-    } else {
-	/* RichCursor encoding. */
-       int bpp1=cl->screen->serverFormat.bitsPerPixel/8,
-	 bpp2=cl->format.bitsPerPixel/8;
-       (*cl->translateFn)(cl->translateLookupTable,
-		       &(cl->screen->serverFormat),
-                       &cl->format, (char*)pCursor->richSource,
-		       &cl->updateBuf[cl->ublen],
-                       pCursor->width*bpp1, pCursor->width, pCursor->height);
-
-       cl->ublen += pCursor->width*bpp2*pCursor->height;
-    }
-
-    /* Prepare transparency mask. */
-
-    bitmapData = (uint8_t *)pCursor->mask;
-
-    for (i = 0; i < pCursor->height; i++) {
-	for (j = 0; j < bitmapRowBytes; j++) {
-	    bitmapByte = bitmapData[i * bitmapRowBytes + j];
-	    cl->updateBuf[cl->ublen++] = (char)bitmapByte;
-	}
-    }
-
-    /* Send everything we have prepared in the cl->updateBuf[]. */
-    rfbStatRecordEncodingSent(cl, (cl->useRichCursorEncoding ? rfbEncodingRichCursor : rfbEncodingXCursor), 
-        sz_rfbFramebufferUpdateRectHeader + (cl->ublen - saved_ublen), sz_rfbFramebufferUpdateRectHeader + (cl->ublen - saved_ublen));
-
-    if (!rfbSendUpdateBuf(cl))
-	return FALSE;
-
-    return TRUE;
-}
-
-/*
- * Send cursor position (PointerPos pseudo-encoding).
- */
-
-rfbBool
-rfbSendCursorPos(rfbClientPtr cl)
-{
-  rfbFramebufferUpdateRectHeader rect;
-
-  if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {
-    if (!rfbSendUpdateBuf(cl))
-      return FALSE;
-  }
-
-  rect.encoding = Swap32IfLE(rfbEncodingPointerPos);
-  rect.r.x = Swap16IfLE(cl->screen->cursorX);
-  rect.r.y = Swap16IfLE(cl->screen->cursorY);
-  rect.r.w = 0;
-  rect.r.h = 0;
-
-  memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-	 sz_rfbFramebufferUpdateRectHeader);
-  cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-  rfbStatRecordEncodingSent(cl, rfbEncodingPointerPos, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);
-
-  if (!rfbSendUpdateBuf(cl))
-    return FALSE;
-
-  return TRUE;
-}
-
-/* conversion routine for predefined cursors in LSB order */
-unsigned char rfbReverseByte[0x100] = {
-  /* copied from Xvnc/lib/font/util/utilbitmap.c */
-	0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
-	0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
-	0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
-	0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
-	0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
-	0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
-	0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
-	0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
-	0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
-	0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
-	0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
-	0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
-	0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
-	0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
-	0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
-	0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
-	0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
-	0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
-	0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
-	0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
-	0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
-	0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
-	0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
-	0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
-	0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
-	0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
-	0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
-	0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
-	0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
-	0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
-	0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
-	0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
-};
-
-void rfbConvertLSBCursorBitmapOrMask(int width,int height,unsigned char* bitmap)
-{
-   int i,t=(width+7)/8*height;
-   for(i=0;i<t;i++)
-     bitmap[i]=rfbReverseByte[(int)bitmap[i]];
-}
-
-/* Cursor creation. You "paint" a cursor and let these routines do the work */
-
-rfbCursorPtr rfbMakeXCursor(int width,int height,char* cursorString,char* maskString)
-{
-   int i,j,w=(width+7)/8;
-   rfbCursorPtr cursor = (rfbCursorPtr)calloc(1,sizeof(rfbCursor));
-   char* cp;
-   unsigned char bit;
-
-   cursor->cleanup=TRUE;
-   cursor->width=width;
-   cursor->height=height;
-   /*cursor->backRed=cursor->backGreen=cursor->backBlue=0xffff;*/
-   cursor->foreRed=cursor->foreGreen=cursor->foreBlue=0xffff;
-   
-   cursor->source = (unsigned char*)calloc(w,height);
-   cursor->cleanupSource = TRUE;
-   for(j=0,cp=cursorString;j<height;j++)
-      for(i=0,bit=0x80;i<width;i++,bit=(bit&1)?0x80:bit>>1,cp++)
-	if(*cp!=' ') cursor->source[j*w+i/8]|=bit;
-
-   if(maskString) {
-      cursor->mask = (unsigned char*)calloc(w,height);
-      for(j=0,cp=maskString;j<height;j++)
-	for(i=0,bit=0x80;i<width;i++,bit=(bit&1)?0x80:bit>>1,cp++)
-	  if(*cp!=' ') cursor->mask[j*w+i/8]|=bit;
-   } else
-     cursor->mask = (unsigned char*)rfbMakeMaskForXCursor(width,height,(char*)cursor->source);
-   cursor->cleanupMask = TRUE;
-
-   return(cursor);
-}
-
-char* rfbMakeMaskForXCursor(int width,int height,char* source)
-{
-   int i,j,w=(width+7)/8;
-   char* mask=(char*)calloc(w,height);
-   unsigned char c;
-   
-   for(j=0;j<height;j++)
-     for(i=w-1;i>=0;i--) {
-	c=source[j*w+i];
-	if(j>0) c|=source[(j-1)*w+i];
-	if(j<height-1) c|=source[(j+1)*w+i];
-	
-	if(i>0 && (c&0x80))
-	  mask[j*w+i-1]|=0x01;
-	if(i<w-1 && (c&0x01))
-	  mask[j*w+i+1]|=0x80;
-	
-	mask[j*w+i]|=(c<<1)|c|(c>>1);
-     }
-   
-   return(mask);
-}
-
-/* this function dithers the alpha using Floyd-Steinberg */
-
-char* rfbMakeMaskFromAlphaSource(int width,int height,unsigned char* alphaSource)
-{
-	int* error=(int*)calloc(sizeof(int),width);
-	int i,j,currentError=0,maskStride=(width+7)/8;
-	unsigned char* result=(unsigned char*)calloc(maskStride,height);
-	
-	for(j=0;j<height;j++)
-		for(i=0;i<width;i++) {
-			int right,middle,left;
-			currentError+=alphaSource[i+width*j]+error[i];
-		
-			if(currentError<0x80) {
-				/* set to transparent */
-				/* alpha was treated as 0 */
-			} else {
-				/* set to solid */
-				result[i/8+j*maskStride]|=(0x100>>(i&7));
-				/* alpha was treated as 0xff */
-				currentError-=0xff;
-			}
-			/* propagate to next row */
-			right=currentError/16;
-			middle=currentError*5/16;
-			left=currentError*3/16;
-			currentError-=right+middle+left;
-			error[i]=right;
-			if(i>0) {
-				error[i-1]=middle;
-				if(i>1)
-					error[i-2]=left;
-			}
-		}
-	free(error);
-	return (char *) result;
-}
-
-void rfbFreeCursor(rfbCursorPtr cursor)
-{
-   if(cursor) {
-       if(cursor->cleanupRichSource && cursor->richSource)
-	   free(cursor->richSource);
-       if(cursor->cleanupRichSource && cursor->alphaSource)
-	   free(cursor->alphaSource);
-       if(cursor->cleanupSource && cursor->source)
-	   free(cursor->source);
-       if(cursor->cleanupMask && cursor->mask)
-	   free(cursor->mask);
-       if(cursor->cleanup)
-	   free(cursor);
-       else {
-	   cursor->cleanup=cursor->cleanupSource=cursor->cleanupMask
-	       =cursor->cleanupRichSource=FALSE;
-	   cursor->source=cursor->mask=cursor->richSource=NULL;
-	   cursor->alphaSource=NULL;
-       }
-   }
-   
-}
-
-/* background and foregroud colour have to be set beforehand */
-void rfbMakeXCursorFromRichCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr cursor)
-{
-   rfbPixelFormat* format=&rfbScreen->serverFormat;
-   int i,j,w=(cursor->width+7)/8,bpp=format->bitsPerPixel/8,
-     width=cursor->width*bpp;
-   uint32_t background;
-   char *back=(char*)&background;
-   unsigned char bit;
-   int interp = 0, db = 0;
-
-   if(cursor->source && cursor->cleanupSource)
-       free(cursor->source);
-   cursor->source=(unsigned char*)calloc(w,cursor->height);
-   cursor->cleanupSource=TRUE;
-   
-   if(format->bigEndian) {
-      back+=4-bpp;
-   }
-
-	/* all zeros means we should interpolate to black+white ourselves */
-	if (!cursor->backRed && !cursor->backGreen && !cursor->backBlue &&
-	    !cursor->foreRed && !cursor->foreGreen && !cursor->foreBlue) {
-		if (format->trueColour && (bpp == 1 || bpp == 2 || bpp == 4)) {
-			interp = 1;
-			cursor->foreRed = cursor->foreGreen = cursor->foreBlue = 0xffff;
-		}
-	}
-
-   background = ((format->redMax   * cursor->backRed)   / 0xffff) << format->redShift   |
-                ((format->greenMax * cursor->backGreen) / 0xffff) << format->greenShift |
-                ((format->blueMax  * cursor->backBlue)  / 0xffff) << format->blueShift;
-
-#define SETRGB(u) \
-   r = (255 * (((format->redMax   << format->redShift)   & (*u)) >> format->redShift))   / format->redMax; \
-   g = (255 * (((format->greenMax << format->greenShift) & (*u)) >> format->greenShift)) / format->greenMax; \
-   b = (255 * (((format->blueMax  << format->blueShift)  & (*u)) >> format->blueShift))  / format->blueMax;
-
-   if (db) fprintf(stderr, "interp: %d\n", interp);
-
-   for(j=0;j<cursor->height;j++) {
-	for(i=0,bit=0x80;i<cursor->width;i++,bit=(bit&1)?0x80:bit>>1) {
-		if (interp) {
-			int r = 0, g = 0, b = 0, grey;
-			unsigned char *p = cursor->richSource+j*width+i*bpp;
-			if (bpp == 1) {
-				unsigned char*  uc = (unsigned char*)  p;
-				SETRGB(uc);
-			} else if (bpp == 2) {
-				unsigned short* us = (unsigned short*) p;
-				SETRGB(us);
-			} else if (bpp == 4) {
-				unsigned int*   ui = (unsigned int*)   p;
-				SETRGB(ui);
-			}
-			grey = (r + g + b) / 3;
-			if (grey >= 128) {
-				cursor->source[j*w+i/8]|=bit;
-				if (db) fprintf(stderr, "1");
-			} else {
-				if (db) fprintf(stderr, "0");
-			}
-			
-		} else if(memcmp(cursor->richSource+j*width+i*bpp, back, bpp)) {
-			cursor->source[j*w+i/8]|=bit;
-		}
-	}
-	if (db) fprintf(stderr, "\n");
-   }
-}
-
-void rfbMakeRichCursorFromXCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr cursor)
-{
-   rfbPixelFormat* format=&rfbScreen->serverFormat;
-   int i,j,w=(cursor->width+7)/8,bpp=format->bitsPerPixel/8;
-   uint32_t background,foreground;
-   char *back=(char*)&background,*fore=(char*)&foreground;
-   unsigned char *cp;
-   unsigned char bit;
-
-   if(cursor->richSource && cursor->cleanupRichSource)
-       free(cursor->richSource);
-   cp=cursor->richSource=(unsigned char*)calloc(cursor->width*bpp,cursor->height);
-   cursor->cleanupRichSource=TRUE;
-   
-   if(format->bigEndian) {
-      back+=4-bpp;
-      fore+=4-bpp;
-   }
-
-   background=cursor->backRed<<format->redShift|
-     cursor->backGreen<<format->greenShift|cursor->backBlue<<format->blueShift;
-   foreground=cursor->foreRed<<format->redShift|
-     cursor->foreGreen<<format->greenShift|cursor->foreBlue<<format->blueShift;
-   
-   for(j=0;j<cursor->height;j++)
-     for(i=0,bit=0x80;i<cursor->width;i++,bit=(bit&1)?0x80:bit>>1,cp+=bpp)
-       if(cursor->source[j*w+i/8]&bit) memcpy(cp,fore,bpp);
-       else memcpy(cp,back,bpp);
-}
-
-/* functions to draw/hide cursor directly in the frame buffer */
-
-void rfbHideCursor(rfbClientPtr cl)
-{
-   rfbScreenInfoPtr s=cl->screen;
-   rfbCursorPtr c=s->cursor;
-   int j,x1,x2,y1,y2,bpp=s->serverFormat.bitsPerPixel/8,
-     rowstride=s->paddedWidthInBytes;
-   LOCK(s->cursorMutex);
-   if(!c) {
-     UNLOCK(s->cursorMutex);
-     return;
-   }
-   
-   /* restore what is under the cursor */
-   x1=cl->cursorX-c->xhot;
-   x2=x1+c->width;
-   if(x1<0) x1=0;
-   if(x2>=s->width) x2=s->width-1;
-   x2-=x1; if(x2<=0) {
-     UNLOCK(s->cursorMutex);
-     return;
-   }
-   y1=cl->cursorY-c->yhot;
-   y2=y1+c->height;
-   if(y1<0) y1=0;
-   if(y2>=s->height) y2=s->height-1;
-   y2-=y1; if(y2<=0) {
-     UNLOCK(s->cursorMutex);
-     return;
-   }
-
-   /* get saved data */
-   for(j=0;j<y2;j++)
-     memcpy(s->frameBuffer+(y1+j)*rowstride+x1*bpp,
-	    s->underCursorBuffer+j*x2*bpp,
-	    x2*bpp);
-
-   /* Copy to all scaled versions */
-   rfbScaledScreenUpdate(s, x1, y1, x1+x2, y1+y2);
-   
-   UNLOCK(s->cursorMutex);
-}
-
-void rfbShowCursor(rfbClientPtr cl)
-{
-   rfbScreenInfoPtr s=cl->screen;
-   rfbCursorPtr c=s->cursor;
-   int i,j,x1,x2,y1,y2,i1,j1,bpp=s->serverFormat.bitsPerPixel/8,
-     rowstride=s->paddedWidthInBytes,
-     bufSize,w;
-   rfbBool wasChanged=FALSE;
-
-   if(!c) return;
-   LOCK(s->cursorMutex);
-
-   bufSize=c->width*c->height*bpp;
-   w=(c->width+7)/8;
-   if(s->underCursorBufferLen<bufSize) {
-      if(s->underCursorBuffer!=NULL)
-	free(s->underCursorBuffer);
-      s->underCursorBuffer=malloc(bufSize);
-      s->underCursorBufferLen=bufSize;
-   }
-
-   /* save what is under the cursor */
-   i1=j1=0; /* offset in cursor */
-   x1=cl->cursorX-c->xhot;
-   x2=x1+c->width;
-   if(x1<0) { i1=-x1; x1=0; }
-   if(x2>=s->width) x2=s->width-1;
-   x2-=x1; if(x2<=0) {
-     UNLOCK(s->cursorMutex);
-     return; /* nothing to do */
-   }
-
-   y1=cl->cursorY-c->yhot;
-   y2=y1+c->height;
-   if(y1<0) { j1=-y1; y1=0; }
-   if(y2>=s->height) y2=s->height-1;
-   y2-=y1; if(y2<=0) {
-     UNLOCK(s->cursorMutex);
-     return; /* nothing to do */
-   }
-
-   /* save data */
-   for(j=0;j<y2;j++) {
-     char* dest=s->underCursorBuffer+j*x2*bpp;
-     const char* src=s->frameBuffer+(y1+j)*rowstride+x1*bpp;
-     unsigned int count=x2*bpp;
-     if(wasChanged || memcmp(dest,src,count)) {
-       wasChanged=TRUE;
-       memcpy(dest,src,count);
-     }
-   }
-   
-   if(!c->richSource)
-     rfbMakeRichCursorFromXCursor(s,c);
-  
-   if (c->alphaSource) {
-	int rmax, rshift;
-	int gmax, gshift;
-	int bmax, bshift;
-	int amax = 255;	/* alphaSource is always 8bits of info per pixel */
-	unsigned int rmask, gmask, bmask;
-
-	rmax   = s->serverFormat.redMax;
-	gmax   = s->serverFormat.greenMax;
-	bmax   = s->serverFormat.blueMax;
-	rshift = s->serverFormat.redShift;
-	gshift = s->serverFormat.greenShift;
-	bshift = s->serverFormat.blueShift;
-
-	rmask = (rmax << rshift);
-	gmask = (gmax << gshift);
-	bmask = (bmax << bshift);
-
-	for(j=0;j<y2;j++) {
-		for(i=0;i<x2;i++) {
-			/*
-			 * we loop over the whole cursor ignoring c->mask[],
-			 * using the extracted alpha value instead.
-			 */
-			char *dest;
-			unsigned char *src, *aptr;
-			unsigned int val, dval, sval;
-			int rdst, gdst, bdst;		/* fb RGB */
-			int asrc, rsrc, gsrc, bsrc;	/* rich source ARGB */
-
-			dest = s->frameBuffer + (j+y1)*rowstride + (i+x1)*bpp;
-			src  = c->richSource  + (j+j1)*c->width*bpp + (i+i1)*bpp;
-			aptr = c->alphaSource + (j+j1)*c->width + (i+i1);
-
-			asrc = *aptr;
-			if (!asrc) {
-				continue;
-			}
-
-			if (bpp == 1) {
-				dval = *((unsigned char*) dest);
-				sval = *((unsigned char*) src);
-			} else if (bpp == 2) {
-				dval = *((unsigned short*) dest);
-				sval = *((unsigned short*) src);
-			} else if (bpp == 3) {
-				unsigned char *dst = (unsigned char *) dest;
-				dval = 0;
-				dval |= ((*(dst+0)) << 0);
-				dval |= ((*(dst+1)) << 8);
-				dval |= ((*(dst+2)) << 16);
-				sval = 0;
-				sval |= ((*(src+0)) << 0);
-				sval |= ((*(src+1)) << 8);
-				sval |= ((*(src+2)) << 16);
-			} else if (bpp == 4) {
-				dval = *((unsigned int*) dest);
-				sval = *((unsigned int*) src);
-			} else {
-				continue;
-			}
-
-			/* extract dest and src RGB */
-			rdst = (dval & rmask) >> rshift;	/* fb */
-			gdst = (dval & gmask) >> gshift;
-			bdst = (dval & bmask) >> bshift;
-
-			rsrc = (sval & rmask) >> rshift;	/* richcursor */
-			gsrc = (sval & gmask) >> gshift;
-			bsrc = (sval & bmask) >> bshift;
-
-			/* blend in fb data. */
-			if (! c->alphaPreMultiplied) {
-				rsrc = (asrc * rsrc)/amax;
-				gsrc = (asrc * gsrc)/amax;
-				bsrc = (asrc * bsrc)/amax;
-			}
-			rdst = rsrc + ((amax - asrc) * rdst)/amax;
-			gdst = gsrc + ((amax - asrc) * gdst)/amax;
-			bdst = bsrc + ((amax - asrc) * bdst)/amax;
-
-			val = 0;
-			val |= (rdst << rshift);
-			val |= (gdst << gshift);
-			val |= (bdst << bshift);
-
-			/* insert the cooked pixel into the fb */
-			memcpy(dest, &val, bpp);
-		}
-	}
-   } else {
-      /* now the cursor has to be drawn */
-      for(j=0;j<y2;j++)
-        for(i=0;i<x2;i++)
-          if((c->mask[(j+j1)*w+(i+i1)/8]<<((i+i1)&7))&0x80)
-   	 memcpy(s->frameBuffer+(j+y1)*rowstride+(i+x1)*bpp,
-   		c->richSource+(j+j1)*c->width*bpp+(i+i1)*bpp,bpp);
-   }
-
-   /* Copy to all scaled versions */
-   rfbScaledScreenUpdate(s, x1, y1, x1+x2, y1+y2);
-
-   UNLOCK(s->cursorMutex);
-}
-
-/* 
- * If enableCursorShapeUpdates is FALSE, and the cursor is hidden, make sure
- * that if the frameBuffer was transmitted with a cursor drawn, then that
- * region gets redrawn.
- */
-
-void rfbRedrawAfterHideCursor(rfbClientPtr cl,sraRegionPtr updateRegion)
-{
-    rfbScreenInfoPtr s = cl->screen;
-    rfbCursorPtr c = s->cursor;
-    
-    if(c) {
-	int x,y,x2,y2;
-
-	x = cl->cursorX-c->xhot;
-	y = cl->cursorY-c->yhot;
-	x2 = x+c->width;
-	y2 = y+c->height;
-
-	if(sraClipRect2(&x,&y,&x2,&y2,0,0,s->width,s->height)) {
-	    sraRegionPtr rect;
-	    rect = sraRgnCreateRect(x,y,x2,y2);
-	    if(updateRegion) {
-	    	sraRgnOr(updateRegion,rect);
-	    } else {
-		    LOCK(cl->updateMutex);
-		    sraRgnOr(cl->modifiedRegion,rect);
-		    UNLOCK(cl->updateMutex);
-	    }
-	    sraRgnDestroy(rect);
-	}
-    }
-}
-
-#ifdef DEBUG
-
-static void rfbPrintXCursor(rfbCursorPtr cursor)
-{
-   int i,i1,j,w=(cursor->width+7)/8;
-   unsigned char bit;
-   for(j=0;j<cursor->height;j++) {
-      for(i=0,i1=0,bit=0x80;i1<cursor->width;i1++,i+=(bit&1)?1:0,bit=(bit&1)?0x80:bit>>1)
-	if(cursor->source[j*w+i]&bit) putchar('#'); else putchar(' ');
-      putchar(':');
-      for(i=0,i1=0,bit=0x80;i1<cursor->width;i1++,i+=(bit&1)?1:0,bit=(bit&1)?0x80:bit>>1)
-	if(cursor->mask[j*w+i]&bit) putchar('#'); else putchar(' ');
-      putchar('\n');
-   }
-}
-
-#endif
-
-void rfbSetCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr c)
-{
-  rfbClientIteratorPtr iterator;
-  rfbClientPtr cl;
-
-  LOCK(rfbScreen->cursorMutex);
-
-  if(rfbScreen->cursor) {
-    iterator=rfbGetClientIterator(rfbScreen);
-    while((cl=rfbClientIteratorNext(iterator)))
-	if(!cl->enableCursorShapeUpdates)
-	  rfbRedrawAfterHideCursor(cl,NULL);
-    rfbReleaseClientIterator(iterator);
-
-    if(rfbScreen->cursor->cleanup)
-	 rfbFreeCursor(rfbScreen->cursor);
-  }
-
-  rfbScreen->cursor = c;
-
-  iterator=rfbGetClientIterator(rfbScreen);
-  while((cl=rfbClientIteratorNext(iterator))) {
-    cl->cursorWasChanged = TRUE;
-    if(!cl->enableCursorShapeUpdates)
-      rfbRedrawAfterHideCursor(cl,NULL);
-  }
-  rfbReleaseClientIterator(iterator);
-
-  UNLOCK(rfbScreen->cursorMutex);
-}
-
diff --git a/libvncserver/cutpaste.c b/libvncserver/cutpaste.c
deleted file mode 100644
index 6533fd2..0000000
--- a/libvncserver/cutpaste.c
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * cutpaste.c - routines to deal with cut & paste buffers / selection.
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-
-/*
- * rfbSetXCutText sets the cut buffer to be the given string.  We also clear
- * the primary selection.  Ideally we'd like to set it to the same thing, but I
- * can't work out how to do that without some kind of helper X client.
- */
-
-void rfbGotXCutText(rfbScreenInfoPtr rfbScreen, char *str, int len)
-{
-   rfbSendServerCutText(rfbScreen, str, len);
-}
diff --git a/libvncserver/d3des.c b/libvncserver/d3des.c
deleted file mode 100644
index 2df1aab..0000000
--- a/libvncserver/d3des.c
+++ /dev/null
@@ -1,436 +0,0 @@
-/*
- * This is D3DES (V5.09) by Richard Outerbridge with the double and
- * triple-length support removed for use in VNC.  Also the bytebit[] array
- * has been reversed so that the most significant bit in each byte of the
- * key is ignored, not the least significant.
- *
- * These changes are:
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/* D3DES (V5.09) -
- *
- * A portable, public domain, version of the Data Encryption Standard.
- *
- * Written with Symantec's THINK (Lightspeed) C by Richard Outerbridge.
- * Thanks to: Dan Hoey for his excellent Initial and Inverse permutation
- * code;  Jim Gillogly & Phil Karn for the DES key schedule code; Dennis
- * Ferguson, Eric Young and Dana How for comparing notes; and Ray Lau,
- * for humouring me on.
- *
- * Copyright (c) 1988,1989,1990,1991,1992 by Richard Outerbridge.
- * (GEnie : OUTER; CIS : [71755,204]) Graven Imagery, 1992.
- */
-
-#include "d3des.h"
-
-static void scrunch(unsigned char *, unsigned long *);
-static void unscrun(unsigned long *, unsigned char *);
-static void desfunc(unsigned long *, unsigned long *);
-static void cookey(unsigned long *);
-
-static unsigned long KnL[32] = { 0L };
-/*
-static unsigned long KnR[32] = { 0L };
-static unsigned long Kn3[32] = { 0L };
-static unsigned char Df_Key[24] = {
-	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
-	0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,
-	0x89,0xab,0xcd,0xef,0x01,0x23,0x45,0x67 };
-*/
-
-static unsigned short bytebit[8]	= {
-	01, 02, 04, 010, 020, 040, 0100, 0200 };
-
-static unsigned long bigbyte[24] = {
-	0x800000L,	0x400000L,	0x200000L,	0x100000L,
-	0x80000L,	0x40000L,	0x20000L,	0x10000L,
-	0x8000L,	0x4000L,	0x2000L,	0x1000L,
-	0x800L, 	0x400L, 	0x200L, 	0x100L,
-	0x80L,		0x40L,		0x20L,		0x10L,
-	0x8L,		0x4L,		0x2L,		0x1L	};
-
-/* Use the key schedule specified in the Standard (ANSI X3.92-1981). */
-
-static unsigned char pc1[56] = {
-	56, 48, 40, 32, 24, 16,  8,	 0, 57, 49, 41, 33, 25, 17,
-	 9,  1, 58, 50, 42, 34, 26,	18, 10,  2, 59, 51, 43, 35,
-	62, 54, 46, 38, 30, 22, 14,	 6, 61, 53, 45, 37, 29, 21,
-	13,  5, 60, 52, 44, 36, 28,	20, 12,  4, 27, 19, 11,  3 };
-
-static unsigned char totrot[16] = {
-	1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28 };
-
-static unsigned char pc2[48] = {
-	13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
-	22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
-	40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
-	43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 };
-
-void rfbDesKey(unsigned char *key,
-               int edf)
-{
-	register int i, j, l, m, n;
-	unsigned char pc1m[56], pcr[56];
-	unsigned long kn[32];
-
-	for ( j = 0; j < 56; j++ ) {
-		l = pc1[j];
-		m = l & 07;
-		pc1m[j] = (key[l >> 3] & bytebit[m]) ? 1 : 0;
-		}
-	for( i = 0; i < 16; i++ ) {
-		if( edf == DE1 ) m = (15 - i) << 1;
-		else m = i << 1;
-		n = m + 1;
-		kn[m] = kn[n] = 0L;
-		for( j = 0; j < 28; j++ ) {
-			l = j + totrot[i];
-			if( l < 28 ) pcr[j] = pc1m[l];
-			else pcr[j] = pc1m[l - 28];
-			}
-		for( j = 28; j < 56; j++ ) {
-		    l = j + totrot[i];
-		    if( l < 56 ) pcr[j] = pc1m[l];
-		    else pcr[j] = pc1m[l - 28];
-		    }
-		for( j = 0; j < 24; j++ ) {
-			if( pcr[pc2[j]] ) kn[m] |= bigbyte[j];
-			if( pcr[pc2[j+24]] ) kn[n] |= bigbyte[j];
-			}
-		}
-	cookey(kn);
-	return;
-	}
-
-static void cookey(register unsigned long *raw1)
-{
-	register unsigned long *cook, *raw0;
-	unsigned long dough[32];
-	register int i;
-
-	cook = dough;
-	for( i = 0; i < 16; i++, raw1++ ) {
-		raw0 = raw1++;
-		*cook	 = (*raw0 & 0x00fc0000L) << 6;
-		*cook	|= (*raw0 & 0x00000fc0L) << 10;
-		*cook	|= (*raw1 & 0x00fc0000L) >> 10;
-		*cook++ |= (*raw1 & 0x00000fc0L) >> 6;
-		*cook	 = (*raw0 & 0x0003f000L) << 12;
-		*cook	|= (*raw0 & 0x0000003fL) << 16;
-		*cook	|= (*raw1 & 0x0003f000L) >> 4;
-		*cook++ |= (*raw1 & 0x0000003fL);
-		}
-	rfbUseKey(dough);
-	return;
-	}
-
-void rfbCPKey(register unsigned long *into)
-{
-	register unsigned long *from, *endp;
-
-	from = KnL, endp = &KnL[32];
-	while( from < endp ) *into++ = *from++;
-	return;
-	}
-
-void rfbUseKey(register unsigned long *from)
-{
-	register unsigned long *to, *endp;
-
-	to = KnL, endp = &KnL[32];
-	while( to < endp ) *to++ = *from++;
-	return;
-	}
-
-void rfbDes(unsigned char *inblock,
-            unsigned char *outblock)
-{
-	unsigned long work[2];
-
-	scrunch(inblock, work);
-	desfunc(work, KnL);
-	unscrun(work, outblock);
-	return;
-	}
-
-static void scrunch(register unsigned char *outof,
-                    register unsigned long *into)
-{
-	*into	 = (*outof++ & 0xffL) << 24;
-	*into	|= (*outof++ & 0xffL) << 16;
-	*into	|= (*outof++ & 0xffL) << 8;
-	*into++ |= (*outof++ & 0xffL);
-	*into	 = (*outof++ & 0xffL) << 24;
-	*into	|= (*outof++ & 0xffL) << 16;
-	*into	|= (*outof++ & 0xffL) << 8;
-	*into	|= (*outof   & 0xffL);
-	return;
-	}
-
-static void unscrun(register unsigned long *outof,
-                    register unsigned char *into)
-{
-	*into++ = (unsigned char)((*outof >> 24) & 0xffL);
-	*into++ = (unsigned char)((*outof >> 16) & 0xffL);
-	*into++ = (unsigned char)((*outof >>  8) & 0xffL);
-	*into++ = (unsigned char)( *outof++	 & 0xffL);
-	*into++ = (unsigned char)((*outof >> 24) & 0xffL);
-	*into++ = (unsigned char)((*outof >> 16) & 0xffL);
-	*into++ = (unsigned char)((*outof >>  8) & 0xffL);
-	*into	= (unsigned char)( *outof	 & 0xffL);
-	return;
-	}
-
-static unsigned long SP1[64] = {
-	0x01010400L, 0x00000000L, 0x00010000L, 0x01010404L,
-	0x01010004L, 0x00010404L, 0x00000004L, 0x00010000L,
-	0x00000400L, 0x01010400L, 0x01010404L, 0x00000400L,
-	0x01000404L, 0x01010004L, 0x01000000L, 0x00000004L,
-	0x00000404L, 0x01000400L, 0x01000400L, 0x00010400L,
-	0x00010400L, 0x01010000L, 0x01010000L, 0x01000404L,
-	0x00010004L, 0x01000004L, 0x01000004L, 0x00010004L,
-	0x00000000L, 0x00000404L, 0x00010404L, 0x01000000L,
-	0x00010000L, 0x01010404L, 0x00000004L, 0x01010000L,
-	0x01010400L, 0x01000000L, 0x01000000L, 0x00000400L,
-	0x01010004L, 0x00010000L, 0x00010400L, 0x01000004L,
-	0x00000400L, 0x00000004L, 0x01000404L, 0x00010404L,
-	0x01010404L, 0x00010004L, 0x01010000L, 0x01000404L,
-	0x01000004L, 0x00000404L, 0x00010404L, 0x01010400L,
-	0x00000404L, 0x01000400L, 0x01000400L, 0x00000000L,
-	0x00010004L, 0x00010400L, 0x00000000L, 0x01010004L };
-
-static unsigned long SP2[64] = {
-	0x80108020L, 0x80008000L, 0x00008000L, 0x00108020L,
-	0x00100000L, 0x00000020L, 0x80100020L, 0x80008020L,
-	0x80000020L, 0x80108020L, 0x80108000L, 0x80000000L,
-	0x80008000L, 0x00100000L, 0x00000020L, 0x80100020L,
-	0x00108000L, 0x00100020L, 0x80008020L, 0x00000000L,
-	0x80000000L, 0x00008000L, 0x00108020L, 0x80100000L,
-	0x00100020L, 0x80000020L, 0x00000000L, 0x00108000L,
-	0x00008020L, 0x80108000L, 0x80100000L, 0x00008020L,
-	0x00000000L, 0x00108020L, 0x80100020L, 0x00100000L,
-	0x80008020L, 0x80100000L, 0x80108000L, 0x00008000L,
-	0x80100000L, 0x80008000L, 0x00000020L, 0x80108020L,
-	0x00108020L, 0x00000020L, 0x00008000L, 0x80000000L,
-	0x00008020L, 0x80108000L, 0x00100000L, 0x80000020L,
-	0x00100020L, 0x80008020L, 0x80000020L, 0x00100020L,
-	0x00108000L, 0x00000000L, 0x80008000L, 0x00008020L,
-	0x80000000L, 0x80100020L, 0x80108020L, 0x00108000L };
-
-static unsigned long SP3[64] = {
-	0x00000208L, 0x08020200L, 0x00000000L, 0x08020008L,
-	0x08000200L, 0x00000000L, 0x00020208L, 0x08000200L,
-	0x00020008L, 0x08000008L, 0x08000008L, 0x00020000L,
-	0x08020208L, 0x00020008L, 0x08020000L, 0x00000208L,
-	0x08000000L, 0x00000008L, 0x08020200L, 0x00000200L,
-	0x00020200L, 0x08020000L, 0x08020008L, 0x00020208L,
-	0x08000208L, 0x00020200L, 0x00020000L, 0x08000208L,
-	0x00000008L, 0x08020208L, 0x00000200L, 0x08000000L,
-	0x08020200L, 0x08000000L, 0x00020008L, 0x00000208L,
-	0x00020000L, 0x08020200L, 0x08000200L, 0x00000000L,
-	0x00000200L, 0x00020008L, 0x08020208L, 0x08000200L,
-	0x08000008L, 0x00000200L, 0x00000000L, 0x08020008L,
-	0x08000208L, 0x00020000L, 0x08000000L, 0x08020208L,
-	0x00000008L, 0x00020208L, 0x00020200L, 0x08000008L,
-	0x08020000L, 0x08000208L, 0x00000208L, 0x08020000L,
-	0x00020208L, 0x00000008L, 0x08020008L, 0x00020200L };
-
-static unsigned long SP4[64] = {
-	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
-	0x00802080L, 0x00800081L, 0x00800001L, 0x00002001L,
-	0x00000000L, 0x00802000L, 0x00802000L, 0x00802081L,
-	0x00000081L, 0x00000000L, 0x00800080L, 0x00800001L,
-	0x00000001L, 0x00002000L, 0x00800000L, 0x00802001L,
-	0x00000080L, 0x00800000L, 0x00002001L, 0x00002080L,
-	0x00800081L, 0x00000001L, 0x00002080L, 0x00800080L,
-	0x00002000L, 0x00802080L, 0x00802081L, 0x00000081L,
-	0x00800080L, 0x00800001L, 0x00802000L, 0x00802081L,
-	0x00000081L, 0x00000000L, 0x00000000L, 0x00802000L,
-	0x00002080L, 0x00800080L, 0x00800081L, 0x00000001L,
-	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
-	0x00802081L, 0x00000081L, 0x00000001L, 0x00002000L,
-	0x00800001L, 0x00002001L, 0x00802080L, 0x00800081L,
-	0x00002001L, 0x00002080L, 0x00800000L, 0x00802001L,
-	0x00000080L, 0x00800000L, 0x00002000L, 0x00802080L };
-
-static unsigned long SP5[64] = {
-	0x00000100L, 0x02080100L, 0x02080000L, 0x42000100L,
-	0x00080000L, 0x00000100L, 0x40000000L, 0x02080000L,
-	0x40080100L, 0x00080000L, 0x02000100L, 0x40080100L,
-	0x42000100L, 0x42080000L, 0x00080100L, 0x40000000L,
-	0x02000000L, 0x40080000L, 0x40080000L, 0x00000000L,
-	0x40000100L, 0x42080100L, 0x42080100L, 0x02000100L,
-	0x42080000L, 0x40000100L, 0x00000000L, 0x42000000L,
-	0x02080100L, 0x02000000L, 0x42000000L, 0x00080100L,
-	0x00080000L, 0x42000100L, 0x00000100L, 0x02000000L,
-	0x40000000L, 0x02080000L, 0x42000100L, 0x40080100L,
-	0x02000100L, 0x40000000L, 0x42080000L, 0x02080100L,
-	0x40080100L, 0x00000100L, 0x02000000L, 0x42080000L,
-	0x42080100L, 0x00080100L, 0x42000000L, 0x42080100L,
-	0x02080000L, 0x00000000L, 0x40080000L, 0x42000000L,
-	0x00080100L, 0x02000100L, 0x40000100L, 0x00080000L,
-	0x00000000L, 0x40080000L, 0x02080100L, 0x40000100L };
-
-static unsigned long SP6[64] = {
-	0x20000010L, 0x20400000L, 0x00004000L, 0x20404010L,
-	0x20400000L, 0x00000010L, 0x20404010L, 0x00400000L,
-	0x20004000L, 0x00404010L, 0x00400000L, 0x20000010L,
-	0x00400010L, 0x20004000L, 0x20000000L, 0x00004010L,
-	0x00000000L, 0x00400010L, 0x20004010L, 0x00004000L,
-	0x00404000L, 0x20004010L, 0x00000010L, 0x20400010L,
-	0x20400010L, 0x00000000L, 0x00404010L, 0x20404000L,
-	0x00004010L, 0x00404000L, 0x20404000L, 0x20000000L,
-	0x20004000L, 0x00000010L, 0x20400010L, 0x00404000L,
-	0x20404010L, 0x00400000L, 0x00004010L, 0x20000010L,
-	0x00400000L, 0x20004000L, 0x20000000L, 0x00004010L,
-	0x20000010L, 0x20404010L, 0x00404000L, 0x20400000L,
-	0x00404010L, 0x20404000L, 0x00000000L, 0x20400010L,
-	0x00000010L, 0x00004000L, 0x20400000L, 0x00404010L,
-	0x00004000L, 0x00400010L, 0x20004010L, 0x00000000L,
-	0x20404000L, 0x20000000L, 0x00400010L, 0x20004010L };
-
-static unsigned long SP7[64] = {
-	0x00200000L, 0x04200002L, 0x04000802L, 0x00000000L,
-	0x00000800L, 0x04000802L, 0x00200802L, 0x04200800L,
-	0x04200802L, 0x00200000L, 0x00000000L, 0x04000002L,
-	0x00000002L, 0x04000000L, 0x04200002L, 0x00000802L,
-	0x04000800L, 0x00200802L, 0x00200002L, 0x04000800L,
-	0x04000002L, 0x04200000L, 0x04200800L, 0x00200002L,
-	0x04200000L, 0x00000800L, 0x00000802L, 0x04200802L,
-	0x00200800L, 0x00000002L, 0x04000000L, 0x00200800L,
-	0x04000000L, 0x00200800L, 0x00200000L, 0x04000802L,
-	0x04000802L, 0x04200002L, 0x04200002L, 0x00000002L,
-	0x00200002L, 0x04000000L, 0x04000800L, 0x00200000L,
-	0x04200800L, 0x00000802L, 0x00200802L, 0x04200800L,
-	0x00000802L, 0x04000002L, 0x04200802L, 0x04200000L,
-	0x00200800L, 0x00000000L, 0x00000002L, 0x04200802L,
-	0x00000000L, 0x00200802L, 0x04200000L, 0x00000800L,
-	0x04000002L, 0x04000800L, 0x00000800L, 0x00200002L };
-
-static unsigned long SP8[64] = {
-	0x10001040L, 0x00001000L, 0x00040000L, 0x10041040L,
-	0x10000000L, 0x10001040L, 0x00000040L, 0x10000000L,
-	0x00040040L, 0x10040000L, 0x10041040L, 0x00041000L,
-	0x10041000L, 0x00041040L, 0x00001000L, 0x00000040L,
-	0x10040000L, 0x10000040L, 0x10001000L, 0x00001040L,
-	0x00041000L, 0x00040040L, 0x10040040L, 0x10041000L,
-	0x00001040L, 0x00000000L, 0x00000000L, 0x10040040L,
-	0x10000040L, 0x10001000L, 0x00041040L, 0x00040000L,
-	0x00041040L, 0x00040000L, 0x10041000L, 0x00001000L,
-	0x00000040L, 0x10040040L, 0x00001000L, 0x00041040L,
-	0x10001000L, 0x00000040L, 0x10000040L, 0x10040000L,
-	0x10040040L, 0x10000000L, 0x00040000L, 0x10001040L,
-	0x00000000L, 0x10041040L, 0x00040040L, 0x10000040L,
-	0x10040000L, 0x10001000L, 0x10001040L, 0x00000000L,
-	0x10041040L, 0x00041000L, 0x00041000L, 0x00001040L,
-	0x00001040L, 0x00040040L, 0x10000000L, 0x10041000L };
-
-static void desfunc(register unsigned long *block,
-                    register unsigned long *keys)
-{
-	register unsigned long fval, work, right, leftt;
-	register int round;
-
-	leftt = block[0];
-	right = block[1];
-	work = ((leftt >> 4) ^ right) & 0x0f0f0f0fL;
-	right ^= work;
-	leftt ^= (work << 4);
-	work = ((leftt >> 16) ^ right) & 0x0000ffffL;
-	right ^= work;
-	leftt ^= (work << 16);
-	work = ((right >> 2) ^ leftt) & 0x33333333L;
-	leftt ^= work;
-	right ^= (work << 2);
-	work = ((right >> 8) ^ leftt) & 0x00ff00ffL;
-	leftt ^= work;
-	right ^= (work << 8);
-	right = ((right << 1) | ((right >> 31) & 1L)) & 0xffffffffL;
-	work = (leftt ^ right) & 0xaaaaaaaaL;
-	leftt ^= work;
-	right ^= work;
-	leftt = ((leftt << 1) | ((leftt >> 31) & 1L)) & 0xffffffffL;
-
-	for( round = 0; round < 8; round++ ) {
-		work  = (right << 28) | (right >> 4);
-		work ^= *keys++;
-		fval  = SP7[ work		 & 0x3fL];
-		fval |= SP5[(work >>  8) & 0x3fL];
-		fval |= SP3[(work >> 16) & 0x3fL];
-		fval |= SP1[(work >> 24) & 0x3fL];
-		work  = right ^ *keys++;
-		fval |= SP8[ work		 & 0x3fL];
-		fval |= SP6[(work >>  8) & 0x3fL];
-		fval |= SP4[(work >> 16) & 0x3fL];
-		fval |= SP2[(work >> 24) & 0x3fL];
-		leftt ^= fval;
-		work  = (leftt << 28) | (leftt >> 4);
-		work ^= *keys++;
-		fval  = SP7[ work		 & 0x3fL];
-		fval |= SP5[(work >>  8) & 0x3fL];
-		fval |= SP3[(work >> 16) & 0x3fL];
-		fval |= SP1[(work >> 24) & 0x3fL];
-		work  = leftt ^ *keys++;
-		fval |= SP8[ work		 & 0x3fL];
-		fval |= SP6[(work >>  8) & 0x3fL];
-		fval |= SP4[(work >> 16) & 0x3fL];
-		fval |= SP2[(work >> 24) & 0x3fL];
-		right ^= fval;
-		}
-
-	right = (right << 31) | (right >> 1);
-	work = (leftt ^ right) & 0xaaaaaaaaL;
-	leftt ^= work;
-	right ^= work;
-	leftt = (leftt << 31) | (leftt >> 1);
-	work = ((leftt >> 8) ^ right) & 0x00ff00ffL;
-	right ^= work;
-	leftt ^= (work << 8);
-	work = ((leftt >> 2) ^ right) & 0x33333333L;
-	right ^= work;
-	leftt ^= (work << 2);
-	work = ((right >> 16) ^ leftt) & 0x0000ffffL;
-	leftt ^= work;
-	right ^= (work << 16);
-	work = ((right >> 4) ^ leftt) & 0x0f0f0f0fL;
-	leftt ^= work;
-	right ^= (work << 4);
-	*block++ = right;
-	*block = leftt;
-	return;
-	}
-
-/* Validation sets:
- *
- * Single-length key, single-length plaintext -
- * Key	  : 0123 4567 89ab cdef
- * Plain  : 0123 4567 89ab cde7
- * Cipher : c957 4425 6a5e d31d
- *
- * Double-length key, single-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210
- * Plain  : 0123 4567 89ab cde7
- * Cipher : 7f1d 0a77 826b 8aff
- *
- * Double-length key, double-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210
- * Plain  : 0123 4567 89ab cdef 0123 4567 89ab cdff
- * Cipher : 27a0 8440 406a df60 278f 47cf 42d6 15d7
- *
- * Triple-length key, single-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210 89ab cdef 0123 4567
- * Plain  : 0123 4567 89ab cde7
- * Cipher : de0b 7c06 ae5e 0ed5
- *
- * Triple-length key, double-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210 89ab cdef 0123 4567
- * Plain  : 0123 4567 89ab cdef 0123 4567 89ab cdff
- * Cipher : ad0d 1b30 ac17 cf07 0ed1 1c63 81e4 4de5
- *
- * d3des V5.0a rwo 9208.07 18:44 Graven Imagery
- **********************************************************************/
diff --git a/libvncserver/d3des.h b/libvncserver/d3des.h
deleted file mode 100644
index e3761ca..0000000
--- a/libvncserver/d3des.h
+++ /dev/null
@@ -1,56 +0,0 @@
-#ifndef D3DES_H
-#define D3DES_H
-
-/*
- * This is D3DES (V5.09) by Richard Outerbridge with the double and
- * triple-length support removed for use in VNC.
- *
- * These changes are:
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/* d3des.h -
- *
- *	Headers and defines for d3des.c
- *	Graven Imagery, 1992.
- *
- * Copyright (c) 1988,1989,1990,1991,1992 by Richard Outerbridge
- *	(GEnie : OUTER; CIS : [71755,204])
- */
-
-#define EN0	0	/* MODE == encrypt */
-#define DE1	1	/* MODE == decrypt */
-
-extern void rfbDesKey(unsigned char *, int);
-/*		      hexkey[8]     MODE
- * Sets the internal key register according to the hexadecimal
- * key contained in the 8 bytes of hexkey, according to the DES,
- * for encryption or decryption according to MODE.
- */
-
-extern void rfbUseKey(unsigned long *);
-/*		    cookedkey[32]
- * Loads the internal key register with the data in cookedkey.
- */
-
-extern void rfbCPKey(unsigned long *);
-/*		   cookedkey[32]
- * Copies the contents of the internal key register into the storage
- * located at &cookedkey[0].
- */
-
-extern void rfbDes(unsigned char *, unsigned char *);
-/*		    from[8]	      to[8]
- * Encrypts/Decrypts (according to the key currently loaded in the
- * internal key register) one block of eight bytes at address 'from'
- * into the block at address 'to'.  They can be the same.
- */
-
-/* d3des.h V5.09 rwo 9208.04 15:06 Graven Imagery
- ********************************************************************/
-
-#endif
diff --git a/libvncserver/draw.c b/libvncserver/draw.c
deleted file mode 100644
index 14603ee..0000000
--- a/libvncserver/draw.c
+++ /dev/null
@@ -1,61 +0,0 @@
-#include "rfb/rfb.h"
-
-void rfbFillRect(rfbScreenInfoPtr s,int x1,int y1,int x2,int y2,rfbPixel col)
-{
-  int rowstride = s->paddedWidthInBytes, bpp = s->bitsPerPixel>>3;
-  int i,j;
-  char* colour=(char*)&col;
-
-   if(!rfbEndianTest)
-    colour += 4-bpp;
-  for(j=y1;j<y2;j++)
-    for(i=x1;i<x2;i++)
-      memcpy(s->frameBuffer+j*rowstride+i*bpp,colour,bpp);
-  rfbMarkRectAsModified(s,x1,y1,x2,y2);
-}
-
-#define SETPIXEL(x,y) \
-  memcpy(s->frameBuffer+(y)*rowstride+(x)*bpp,colour,bpp)
-
-void rfbDrawPixel(rfbScreenInfoPtr s,int x,int y,rfbPixel col)
-{
-  int rowstride = s->paddedWidthInBytes, bpp = s->bitsPerPixel>>3;
-  char* colour=(char*)&col;
-
-  if(!rfbEndianTest)
-    colour += 4-bpp;
-  SETPIXEL(x,y);
-  rfbMarkRectAsModified(s,x,y,x+1,y+1);
-}
-
-void rfbDrawLine(rfbScreenInfoPtr s,int x1,int y1,int x2,int y2,rfbPixel col)
-{
-  int rowstride = s->paddedWidthInBytes, bpp = s->bitsPerPixel>>3;
-  int i;
-  char* colour=(char*)&col;
-
-  if(!rfbEndianTest)
-    colour += 4-bpp;
-
-#define SWAPPOINTS { i=x1; x1=x2; x2=i; i=y1; y1=y2; y2=i; }
-  if(abs(x1-x2)<abs(y1-y2)) {
-    if(y1>y2)
-      SWAPPOINTS
-    for(i=y1;i<=y2;i++)
-      SETPIXEL(x1+(i-y1)*(x2-x1)/(y2-y1),i);
-    /* TODO: Maybe make this more intelligently? */
-    if(x2<x1) { i=x1; x1=x2; x2=i; }
-    rfbMarkRectAsModified(s,x1,y1,x2+1,y2+1);
-  } else {
-    if(x1>x2)
-      SWAPPOINTS
-    else if(x1==x2) {
-      rfbDrawPixel(s,x1,y1,col);
-      return;
-    }
-    for(i=x1;i<=x2;i++)
-      SETPIXEL(i,y1+(i-x1)*(y2-y1)/(x2-x1));
-    if(y2<y1) { i=y1; y1=y2; y2=i; }
-    rfbMarkRectAsModified(s,x1,y1,x2+1,y2+1);
-  }
-}
diff --git a/libvncserver/font.c b/libvncserver/font.c
deleted file mode 100644
index 76bd057..0000000
--- a/libvncserver/font.c
+++ /dev/null
@@ -1,196 +0,0 @@
-#include "rfb/rfb.h"
-
-int rfbDrawChar(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,
-		 int x,int y,unsigned char c,rfbPixel col)
-{
-  int i,j,width,height;
-  unsigned char* data=font->data+font->metaData[c*5];
-  unsigned char d=*data;
-  int rowstride=rfbScreen->paddedWidthInBytes;
-  int bpp=rfbScreen->serverFormat.bitsPerPixel/8;
-  char *colour=(char*)&col;
-
-  if(!rfbEndianTest)
-    colour += 4-bpp;
-
-  width=font->metaData[c*5+1];
-  height=font->metaData[c*5+2];
-  x+=font->metaData[c*5+3];
-  y+=-font->metaData[c*5+4]-height+1;
-
-  for(j=0;j<height;j++) {
-    for(i=0;i<width;i++) {
-      if((i&7)==0) {
-	d=*data;
-	data++;
-      }
-      if(d&0x80 && y+j >= 0 && y+j < rfbScreen->height &&
-          x+i >= 0 && x+i < rfbScreen->width)
-	memcpy(rfbScreen->frameBuffer+(y+j)*rowstride+(x+i)*bpp,colour,bpp);
-      d<<=1;
-    }
-    /* if((i&7)!=0) data++; */
-  }
-  return(width);
-}
-
-void rfbDrawString(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,
-		   int x,int y,const char* string,rfbPixel colour)
-{
-  while(*string) {
-    x+=rfbDrawChar(rfbScreen,font,x,y,*string,colour);
-    string++;
-  }
-}
-
-/* TODO: these two functions need to be more efficient */
-/* if col==bcol, assume transparent background */
-int rfbDrawCharWithClip(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,
-			int x,int y,unsigned char c,
-			int x1,int y1,int x2,int y2,
-			rfbPixel col,rfbPixel bcol)
-{
-  int i,j,width,height;
-  unsigned char* data=font->data+font->metaData[c*5];
-  unsigned char d;
-  int rowstride=rfbScreen->paddedWidthInBytes;
-  int bpp=rfbScreen->serverFormat.bitsPerPixel/8,extra_bytes=0;
-  char* colour=(char*)&col;
-  char* bcolour=(char*)&bcol;
-
-  if(!rfbEndianTest) {
-    colour+=4-bpp;
-    bcolour+=4-bpp;
-  }
-
-  width=font->metaData[c*5+1];
-  height=font->metaData[c*5+2];
-  x+=font->metaData[c*5+3];
-  y+=-font->metaData[c*5+4]-height+1;
-
-  /* after clipping, x2 will be count of bytes between rows,
-   * x1 start of i, y1 start of j, width and height will be adjusted. */
-  if(y1>y) { y1-=y; data+=(width+7)/8; height-=y1; y+=y1; } else y1=0;
-  if(x1>x) { x1-=x; data+=x1; width-=x1; x+=x1; extra_bytes+=x1/8; } else x1=0;
-  if(y2<y+height) height-=y+height-y2;
-  if(x2<x+width) { extra_bytes+=(x1+width)/8-(x+width-x2+7)/8; width-=x+width-x2; }
-
-  d=*data;
-  for(j=y1;j<height;j++) {
-    if((x1&7)!=0)
-      d=data[-1]; /* TODO: check if in this case extra_bytes is correct! */
-    for(i=x1;i<width;i++) {
-      if((i&7)==0) {
-	d=*data;
-	data++;
-      }
-      /* if(x+i>=x1 && x+i<x2 && y+j>=y1 && y+j<y2) */ {
-	 if(d&0x80) {
-	   memcpy(rfbScreen->frameBuffer+(y+j)*rowstride+(x+i)*bpp,
-		  colour,bpp);
-	 } else if(bcol!=col) {
-	   memcpy(rfbScreen->frameBuffer+(y+j)*rowstride+(x+i)*bpp,
-		  bcolour,bpp);
-	 }
-      }
-      d<<=1;
-    }
-    /* if((i&7)==0) data++; */
-    data += extra_bytes;
-  }
-  return(width);
-}
-
-void rfbDrawStringWithClip(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,
-			   int x,int y,const char* string,
-			   int x1,int y1,int x2,int y2,
-			   rfbPixel colour,rfbPixel backColour)
-{
-  while(*string) {
-    x+=rfbDrawCharWithClip(rfbScreen,font,x,y,*string,x1,y1,x2,y2,
-			   colour,backColour);
-    string++;
-  }
-}
-
-int rfbWidthOfString(rfbFontDataPtr font,const char* string)
-{
-  int i=0;
-  while(*string) {
-    i+=font->metaData[*string*5+1];
-    string++;
-  }
-  return(i);
-}
-
-int rfbWidthOfChar(rfbFontDataPtr font,unsigned char c)
-{
-  return(font->metaData[c*5+1]+font->metaData[c*5+3]);
-}
-
-void rfbFontBBox(rfbFontDataPtr font,unsigned char c,int* x1,int* y1,int* x2,int* y2)
-{
-  *x1+=font->metaData[c*5+3];
-  *y1+=-font->metaData[c*5+4]-font->metaData[c*5+2]+1;
-  *x2=*x1+font->metaData[c*5+1]+1;
-  *y2=*y1+font->metaData[c*5+2]+1;
-}
-
-#ifndef INT_MAX
-#define INT_MAX 0x7fffffff
-#endif
-
-void rfbWholeFontBBox(rfbFontDataPtr font,
-		      int *x1, int *y1, int *x2, int *y2)
-{
-   int i;
-   int* m=font->metaData;
-   
-   (*x1)=(*y1)=INT_MAX; (*x2)=(*y2)=1-(INT_MAX);
-   for(i=0;i<256;i++) {
-      if(m[i*5+1]-m[i*5+3]>(*x2))
-	(*x2)=m[i*5+1]-m[i*5+3];
-      if(-m[i*5+2]+m[i*5+4]<(*y1))
-	(*y1)=-m[i*5+2]+m[i*5+4];
-      if(m[i*5+3]<(*x1))
-	(*x1)=m[i*5+3];
-      if(-m[i*5+4]>(*y2))
-	(*y2)=-m[i*5+4];
-   }
-   (*x2)++;
-   (*y2)++;
-}
-
-rfbFontDataPtr rfbLoadConsoleFont(char *filename)
-{
-  FILE *f=fopen(filename,"rb");
-  rfbFontDataPtr p;
-  int i;
-
-  if(!f) return NULL;
-
-  p=(rfbFontDataPtr)malloc(sizeof(rfbFontData));
-  p->data=(unsigned char*)malloc(4096);
-  if(1!=fread(p->data,4096,1,f)) {
-    free(p->data);
-    free(p);
-    return NULL;
-  }
-  fclose(f);
-  p->metaData=(int*)malloc(256*5*sizeof(int));
-  for(i=0;i<256;i++) {
-    p->metaData[i*5+0]=i*16; /* offset */
-    p->metaData[i*5+1]=8; /* width */
-    p->metaData[i*5+2]=16; /* height */
-    p->metaData[i*5+3]=0; /* xhot */
-    p->metaData[i*5+4]=0; /* yhot */
-  }
-  return(p);
-}
-
-void rfbFreeFont(rfbFontDataPtr f)
-{
-  free(f->data);
-  free(f->metaData);
-  free(f);
-}
diff --git a/libvncserver/hextile.c b/libvncserver/hextile.c
deleted file mode 100644
index 4c2203d..0000000
--- a/libvncserver/hextile.c
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * hextile.c
- *
- * Routines to implement Hextile Encoding
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-static rfbBool sendHextiles8(rfbClientPtr cl, int x, int y, int w, int h);
-static rfbBool sendHextiles16(rfbClientPtr cl, int x, int y, int w, int h);
-static rfbBool sendHextiles32(rfbClientPtr cl, int x, int y, int w, int h);
-
-
-/*
- * rfbSendRectEncodingHextile - send a rectangle using hextile encoding.
- */
-
-rfbBool
-rfbSendRectEncodingHextile(rfbClientPtr cl,
-                           int x,
-                           int y,
-                           int w,
-                           int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.r.x = Swap16IfLE(x);
-    rect.r.y = Swap16IfLE(y);
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-    rect.encoding = Swap32IfLE(rfbEncodingHextile);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-           sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingHextile,
-          sz_rfbFramebufferUpdateRectHeader,
-          sz_rfbFramebufferUpdateRectHeader + w * (cl->format.bitsPerPixel / 8) * h);
-
-    switch (cl->format.bitsPerPixel) {
-    case 8:
-        return sendHextiles8(cl, x, y, w, h);
-    case 16:
-        return sendHextiles16(cl, x, y, w, h);
-    case 32:
-        return sendHextiles32(cl, x, y, w, h);
-    }
-
-    rfbLog("rfbSendRectEncodingHextile: bpp %d?\n", cl->format.bitsPerPixel);
-    return FALSE;
-}
-
-
-#define PUT_PIXEL8(pix) (cl->updateBuf[cl->ublen++] = (pix))
-
-#define PUT_PIXEL16(pix) (cl->updateBuf[cl->ublen++] = ((char*)&(pix))[0], \
-                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[1])
-
-#define PUT_PIXEL32(pix) (cl->updateBuf[cl->ublen++] = ((char*)&(pix))[0], \
-                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[1], \
-                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[2], \
-                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[3])
-
-
-#define DEFINE_SEND_HEXTILES(bpp)                                               \
-                                                                                \
-                                                                                \
-static rfbBool subrectEncode##bpp(rfbClientPtr cli, uint##bpp##_t *data,        \
-		int w, int h, uint##bpp##_t bg, uint##bpp##_t fg, rfbBool mono);\
-static void testColours##bpp(uint##bpp##_t *data, int size, rfbBool *mono,      \
-                  rfbBool *solid, uint##bpp##_t *bg, uint##bpp##_t *fg);        \
-                                                                                \
-                                                                                \
-/*                                                                              \
- * rfbSendHextiles                                                              \
- */                                                                             \
-                                                                                \
-static rfbBool                                                                  \
-sendHextiles##bpp(rfbClientPtr cl, int rx, int ry, int rw, int rh) {            \
-    int x, y, w, h;                                                             \
-    int startUblen;                                                             \
-    char *fbptr;                                                                \
-    uint##bpp##_t bg = 0, fg = 0, newBg, newFg;                                 \
-    rfbBool mono, solid;                                                        \
-    rfbBool validBg = FALSE;                                                    \
-    rfbBool validFg = FALSE;                                                    \
-    uint##bpp##_t clientPixelData[16*16*(bpp/8)];                               \
-                                                                                \
-    for (y = ry; y < ry+rh; y += 16) {                                          \
-        for (x = rx; x < rx+rw; x += 16) {                                      \
-            w = h = 16;                                                         \
-            if (rx+rw - x < 16)                                                 \
-                w = rx+rw - x;                                                  \
-            if (ry+rh - y < 16)                                                 \
-                h = ry+rh - y;                                                  \
-                                                                                \
-            if ((cl->ublen + 1 + (2 + 16 * 16) * (bpp/8)) >                     \
-                UPDATE_BUF_SIZE) {                                              \
-                if (!rfbSendUpdateBuf(cl))                                      \
-                    return FALSE;                                               \
-            }                                                                   \
-                                                                                \
-            fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)   \
-                     + (x * (cl->scaledScreen->bitsPerPixel / 8)));                   \
-                                                                                \
-            (*cl->translateFn)(cl->translateLookupTable, &(cl->screen->serverFormat),      \
-                               &cl->format, fbptr, (char *)clientPixelData,     \
-                               cl->scaledScreen->paddedWidthInBytes, w, h);           \
-                                                                                \
-            startUblen = cl->ublen;                                             \
-            cl->updateBuf[startUblen] = 0;                                      \
-            cl->ublen++;                                                        \
-            rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);            \
-                                                                                \
-            testColours##bpp(clientPixelData, w * h,                            \
-                             &mono, &solid, &newBg, &newFg);                    \
-                                                                                \
-            if (!validBg || (newBg != bg)) {                                    \
-                validBg = TRUE;                                                 \
-                bg = newBg;                                                     \
-                cl->updateBuf[startUblen] |= rfbHextileBackgroundSpecified;     \
-                PUT_PIXEL##bpp(bg);                                             \
-            }                                                                   \
-                                                                                \
-            if (solid) {                                                        \
-                continue;                                                       \
-            }                                                                   \
-                                                                                \
-            cl->updateBuf[startUblen] |= rfbHextileAnySubrects;                 \
-                                                                                \
-            if (mono) {                                                         \
-                if (!validFg || (newFg != fg)) {                                \
-                    validFg = TRUE;                                             \
-                    fg = newFg;                                                 \
-                    cl->updateBuf[startUblen] |= rfbHextileForegroundSpecified; \
-                    PUT_PIXEL##bpp(fg);                                         \
-                }                                                               \
-            } else {                                                            \
-                validFg = FALSE;                                                \
-                cl->updateBuf[startUblen] |= rfbHextileSubrectsColoured;        \
-            }                                                                   \
-                                                                                \
-            if (!subrectEncode##bpp(cl, clientPixelData, w, h, bg, fg, mono)) { \
-                /* encoding was too large, use raw */                           \
-                validBg = FALSE;                                                \
-                validFg = FALSE;                                                \
-                cl->ublen = startUblen;                                         \
-                cl->updateBuf[cl->ublen++] = rfbHextileRaw;                     \
-                (*cl->translateFn)(cl->translateLookupTable,                    \
-                                   &(cl->screen->serverFormat), &cl->format, fbptr,        \
-                                   (char *)clientPixelData,                     \
-                                   cl->scaledScreen->paddedWidthInBytes, w, h); \
-                                                                                \
-                memcpy(&cl->updateBuf[cl->ublen], (char *)clientPixelData,      \
-                       w * h * (bpp/8));                                        \
-                                                                                \
-                cl->ublen += w * h * (bpp/8);                                   \
-                rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile,            \
-                             w * h * (bpp/8));                                  \
-            }                                                                   \
-        }                                                                       \
-    }                                                                           \
-                                                                                \
-    return TRUE;                                                                \
-}                                                                               \
-                                                                                \
-                                                                                \
-static rfbBool                                                                  \
-subrectEncode##bpp(rfbClientPtr cl, uint##bpp##_t *data, int w, int h,          \
-                   uint##bpp##_t bg, uint##bpp##_t fg, rfbBool mono)            \
-{                                                                               \
-    uint##bpp##_t cl2;                                                          \
-    int x,y;                                                                    \
-    int i,j;                                                                    \
-    int hx=0,hy,vx=0,vy;                                                        \
-    int hyflag;                                                                 \
-    uint##bpp##_t *seg;                                                         \
-    uint##bpp##_t *line;                                                        \
-    int hw,hh,vw,vh;                                                            \
-    int thex,they,thew,theh;                                                    \
-    int numsubs = 0;                                                            \
-    int newLen;                                                                 \
-    int nSubrectsUblen;                                                         \
-                                                                                \
-    nSubrectsUblen = cl->ublen;                                                 \
-    cl->ublen++;                                                                \
-    rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);                    \
-                                                                                \
-    for (y=0; y<h; y++) {                                                       \
-        line = data+(y*w);                                                      \
-        for (x=0; x<w; x++) {                                                   \
-            if (line[x] != bg) {                                                \
-                cl2 = line[x];                                                  \
-                hy = y-1;                                                       \
-                hyflag = 1;                                                     \
-                for (j=y; j<h; j++) {                                           \
-                    seg = data+(j*w);                                           \
-                    if (seg[x] != cl2) {break;}                                 \
-                    i = x;                                                      \
-                    while ((seg[i] == cl2) && (i < w)) i += 1;                  \
-                    i -= 1;                                                     \
-                    if (j == y) vx = hx = i;                                    \
-                    if (i < vx) vx = i;                                         \
-                    if ((hyflag > 0) && (i >= hx)) {                            \
-                        hy += 1;                                                \
-                    } else {                                                    \
-                        hyflag = 0;                                             \
-                    }                                                           \
-                }                                                               \
-                vy = j-1;                                                       \
-                                                                                \
-                /* We now have two possible subrects: (x,y,hx,hy) and           \
-                 * (x,y,vx,vy).  We'll choose the bigger of the two.            \
-                 */                                                             \
-                hw = hx-x+1;                                                    \
-                hh = hy-y+1;                                                    \
-                vw = vx-x+1;                                                    \
-                vh = vy-y+1;                                                    \
-                                                                                \
-                thex = x;                                                       \
-                they = y;                                                       \
-                                                                                \
-                if ((hw*hh) > (vw*vh)) {                                        \
-                    thew = hw;                                                  \
-                    theh = hh;                                                  \
-                } else {                                                        \
-                    thew = vw;                                                  \
-                    theh = vh;                                                  \
-                }                                                               \
-                                                                                \
-                if (mono) {                                                     \
-                    newLen = cl->ublen - nSubrectsUblen + 2;                    \
-                } else {                                                        \
-                    newLen = cl->ublen - nSubrectsUblen + bpp/8 + 2;            \
-                }                                                               \
-                                                                                \
-                if (newLen > (w * h * (bpp/8)))                                 \
-                    return FALSE;                                               \
-                                                                                \
-                numsubs += 1;                                                   \
-                                                                                \
-                if (!mono) PUT_PIXEL##bpp(cl2);                                 \
-                                                                                \
-                cl->updateBuf[cl->ublen++] = rfbHextilePackXY(thex,they);       \
-                cl->updateBuf[cl->ublen++] = rfbHextilePackWH(thew,theh);       \
-                rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);        \
-                                                                                \
-                /*                                                              \
-                 * Now mark the subrect as done.                                \
-                 */                                                             \
-                for (j=they; j < (they+theh); j++) {                            \
-                    for (i=thex; i < (thex+thew); i++) {                        \
-                        data[j*w+i] = bg;                                       \
-                    }                                                           \
-                }                                                               \
-            }                                                                   \
-        }                                                                       \
-    }                                                                           \
-                                                                                \
-    cl->updateBuf[nSubrectsUblen] = numsubs;                                    \
-                                                                                \
-    return TRUE;                                                                \
-}                                                                               \
-                                                                                \
-                                                                                \
-/*                                                                              \
- * testColours() tests if there are one (solid), two (mono) or more             \
- * colours in a tile and gets a reasonable guess at the best background         \
- * pixel, and the foreground pixel for mono.                                    \
- */                                                                             \
-                                                                                \
-static void                                                                     \
-testColours##bpp(uint##bpp##_t *data, int size, rfbBool *mono, rfbBool *solid,  \
-                 uint##bpp##_t *bg, uint##bpp##_t *fg) {                        \
-    uint##bpp##_t colour1 = 0, colour2 = 0;                                     \
-    int n1 = 0, n2 = 0;                                                         \
-    *mono = TRUE;                                                               \
-    *solid = TRUE;                                                              \
-                                                                                \
-    for (; size > 0; size--, data++) {                                          \
-                                                                                \
-        if (n1 == 0)                                                            \
-            colour1 = *data;                                                    \
-                                                                                \
-        if (*data == colour1) {                                                 \
-            n1++;                                                               \
-            continue;                                                           \
-        }                                                                       \
-                                                                                \
-        if (n2 == 0) {                                                          \
-            *solid = FALSE;                                                     \
-            colour2 = *data;                                                    \
-        }                                                                       \
-                                                                                \
-        if (*data == colour2) {                                                 \
-            n2++;                                                               \
-            continue;                                                           \
-        }                                                                       \
-                                                                                \
-        *mono = FALSE;                                                          \
-        break;                                                                  \
-    }                                                                           \
-                                                                                \
-    if (n1 > n2) {                                                              \
-        *bg = colour1;                                                          \
-        *fg = colour2;                                                          \
-    } else {                                                                    \
-        *bg = colour2;                                                          \
-        *fg = colour1;                                                          \
-    }                                                                           \
-}
-
-DEFINE_SEND_HEXTILES(8)
-DEFINE_SEND_HEXTILES(16)
-DEFINE_SEND_HEXTILES(32)
diff --git a/libvncserver/httpd.c b/libvncserver/httpd.c
deleted file mode 100644
index 154363c..0000000
--- a/libvncserver/httpd.c
+++ /dev/null
@@ -1,600 +0,0 @@
-/*
- * httpd.c - a simple HTTP server
- */
-
-/*
- *  Copyright (C) 2002 RealVNC Ltd.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-#include <ctype.h>
-#ifdef LIBVNCSERVER_HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_FCNTL_H
-#include <fcntl.h>
-#endif
-#include <errno.h>
-
-#ifdef WIN32
-#include <winsock.h>
-#define close closesocket
-#else
-#ifdef LIBVNCSERVER_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netdb.h>
-#include <arpa/inet.h>
-#endif
-#include <pwd.h>
-#endif
-
-#ifdef USE_LIBWRAP
-#include <tcpd.h>
-#endif
-
-#define connection_close
-#ifndef connection_close
-
-#define NOT_FOUND_STR "HTTP/1.0 404 Not found\r\n\r\n" \
-    "<HEAD><TITLE>File Not Found</TITLE></HEAD>\n" \
-    "<BODY><H1>File Not Found</H1></BODY>\n"
-
-#define INVALID_REQUEST_STR "HTTP/1.0 400 Invalid Request\r\n\r\n" \
-    "<HEAD><TITLE>Invalid Request</TITLE></HEAD>\n" \
-    "<BODY><H1>Invalid request</H1></BODY>\n"
-
-#define OK_STR "HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n"
-
-#else
-
-#define NOT_FOUND_STR "HTTP/1.0 404 Not found\r\nConnection: close\r\n\r\n" \
-    "<HEAD><TITLE>File Not Found</TITLE></HEAD>\n" \
-    "<BODY><H1>File Not Found</H1></BODY>\n"
-
-#define INVALID_REQUEST_STR "HTTP/1.0 400 Invalid Request\r\nConnection: close\r\n\r\n" \
-    "<HEAD><TITLE>Invalid Request</TITLE></HEAD>\n" \
-    "<BODY><H1>Invalid request</H1></BODY>\n"
-
-#define OK_STR "HTTP/1.0 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n"
-
-#endif
-
-static void httpProcessInput(rfbScreenInfoPtr screen);
-static rfbBool compareAndSkip(char **ptr, const char *str);
-static rfbBool parseParams(const char *request, char *result, int max_bytes);
-static rfbBool validateString(char *str);
-
-#define BUF_SIZE 32768
-
-static char buf[BUF_SIZE];
-static size_t buf_filled=0;
-
-/*
- * httpInitSockets sets up the TCP socket to listen for HTTP connections.
- */
-
-void
-rfbHttpInitSockets(rfbScreenInfoPtr rfbScreen)
-{
-    if (rfbScreen->httpInitDone)
-	return;
-
-    rfbScreen->httpInitDone = TRUE;
-
-    if (!rfbScreen->httpDir)
-	return;
-
-    if (rfbScreen->httpPort == 0) {
-	rfbScreen->httpPort = rfbScreen->port-100;
-    }
-
-    rfbLog("Listening for HTTP connections on TCP port %d\n", rfbScreen->httpPort);
-
-    rfbLog("  URL http://%s:%d\n",rfbScreen->thisHost,rfbScreen->httpPort);
-
-    if ((rfbScreen->httpListenSock =
-      rfbListenOnTCPPort(rfbScreen->httpPort, rfbScreen->listenInterface)) < 0) {
-	rfbLogPerror("ListenOnTCPPort");
-	return;
-    }
-
-   /*AddEnabledDevice(httpListenSock);*/
-}
-
-void rfbHttpShutdownSockets(rfbScreenInfoPtr rfbScreen) {
-    if(rfbScreen->httpSock>-1) {
-	close(rfbScreen->httpSock);
-	FD_CLR(rfbScreen->httpSock,&rfbScreen->allFds);
-	rfbScreen->httpSock=-1;
-    }
-}
-
-/*
- * httpCheckFds is called from ProcessInputEvents to check for input on the
- * HTTP socket(s).  If there is input to process, httpProcessInput is called.
- */
-
-void
-rfbHttpCheckFds(rfbScreenInfoPtr rfbScreen)
-{
-    int nfds;
-    fd_set fds;
-    struct timeval tv;
-    struct sockaddr_in addr;
-    socklen_t addrlen = sizeof(addr);
-
-    if (!rfbScreen->httpDir)
-	return;
-
-    if (rfbScreen->httpListenSock < 0)
-	return;
-
-    FD_ZERO(&fds);
-    FD_SET(rfbScreen->httpListenSock, &fds);
-    if (rfbScreen->httpSock >= 0) {
-	FD_SET(rfbScreen->httpSock, &fds);
-    }
-    tv.tv_sec = 0;
-    tv.tv_usec = 0;
-    nfds = select(max(rfbScreen->httpSock,rfbScreen->httpListenSock) + 1, &fds, NULL, NULL, &tv);
-    if (nfds == 0) {
-	return;
-    }
-    if (nfds < 0) {
-#ifdef WIN32
-		errno = WSAGetLastError();
-#endif
-	if (errno != EINTR)
-		rfbLogPerror("httpCheckFds: select");
-	return;
-    }
-
-    if ((rfbScreen->httpSock >= 0) && FD_ISSET(rfbScreen->httpSock, &fds)) {
-	httpProcessInput(rfbScreen);
-    }
-
-    if (FD_ISSET(rfbScreen->httpListenSock, &fds)) {
-	if (rfbScreen->httpSock >= 0) close(rfbScreen->httpSock);
-
-	if ((rfbScreen->httpSock = accept(rfbScreen->httpListenSock,
-			       (struct sockaddr *)&addr, &addrlen)) < 0) {
-	    rfbLogPerror("httpCheckFds: accept");
-	    return;
-	}
-#ifdef USE_LIBWRAP
-	if(!hosts_ctl("vnc",STRING_UNKNOWN,inet_ntoa(addr.sin_addr),
-		      STRING_UNKNOWN)) {
-	  rfbLog("Rejected HTTP connection from client %s\n",
-		 inet_ntoa(addr.sin_addr));
-	  close(rfbScreen->httpSock);
-	  rfbScreen->httpSock=-1;
-	  return;
-	}
-#endif
-        if(!rfbSetNonBlocking(rfbScreen->httpSock)) {
-	    close(rfbScreen->httpSock);
-	    rfbScreen->httpSock=-1;
-	    return;
-	}
-	/*AddEnabledDevice(httpSock);*/
-    }
-}
-
-
-static void
-httpCloseSock(rfbScreenInfoPtr rfbScreen)
-{
-    close(rfbScreen->httpSock);
-    rfbScreen->httpSock = -1;
-    buf_filled = 0;
-}
-
-static rfbClientRec cl;
-
-/*
- * httpProcessInput is called when input is received on the HTTP socket.
- */
-
-static void
-httpProcessInput(rfbScreenInfoPtr rfbScreen)
-{
-    struct sockaddr_in addr;
-    socklen_t addrlen = sizeof(addr);
-    char fullFname[512];
-    char params[1024];
-    char *ptr;
-    char *fname;
-    unsigned int maxFnameLen;
-    FILE* fd;
-    rfbBool performSubstitutions = FALSE;
-    char str[256+32];
-#ifndef WIN32
-    char* user=getenv("USER");
-#endif
-   
-    cl.sock=rfbScreen->httpSock;
-
-    if (strlen(rfbScreen->httpDir) > 255) {
-	rfbErr("-httpd directory too long\n");
-	httpCloseSock(rfbScreen);
-	return;
-    }
-    strcpy(fullFname, rfbScreen->httpDir);
-    fname = &fullFname[strlen(fullFname)];
-    maxFnameLen = 511 - strlen(fullFname);
-
-    buf_filled=0;
-
-    /* Read data from the HTTP client until we get a complete request. */
-    while (1) {
-	ssize_t got;
-
-        if (buf_filled > sizeof (buf)) {
-	    rfbErr("httpProcessInput: HTTP request is too long\n");
-	    httpCloseSock(rfbScreen);
-	    return;
-	}
-
-	got = read (rfbScreen->httpSock, buf + buf_filled,
-			    sizeof (buf) - buf_filled - 1);
-
-	if (got <= 0) {
-	    if (got == 0) {
-		rfbErr("httpd: premature connection close\n");
-	    } else {
-#ifdef WIN32
-	        errno=WSAGetLastError();
-#endif
-		if (errno == EAGAIN) {
-		    return;
-		}
-		rfbLogPerror("httpProcessInput: read");
-	    }
-	    httpCloseSock(rfbScreen);
-	    return;
-	}
-
-	buf_filled += got;
-	buf[buf_filled] = '\0';
-
-	/* Is it complete yet (is there a blank line)? */
-	if (strstr (buf, "\r\r") || strstr (buf, "\n\n") ||
-	    strstr (buf, "\r\n\r\n") || strstr (buf, "\n\r\n\r"))
-	    break;
-    }
-
-
-    /* Process the request. */
-    if(rfbScreen->httpEnableProxyConnect) {
-	const static char* PROXY_OK_STR = "HTTP/1.0 200 OK\r\nContent-Type: octet-stream\r\nPragma: no-cache\r\n\r\n";
-	if(!strncmp(buf, "CONNECT ", 8)) {
-	    if(atoi(strchr(buf, ':')+1)!=rfbScreen->port) {
-		rfbErr("httpd: CONNECT format invalid.\n");
-		rfbWriteExact(&cl,INVALID_REQUEST_STR, strlen(INVALID_REQUEST_STR));
-		httpCloseSock(rfbScreen);
-		return;
-	    }
-	    /* proxy connection */
-	    rfbLog("httpd: client asked for CONNECT\n");
-	    rfbWriteExact(&cl,PROXY_OK_STR,strlen(PROXY_OK_STR));
-	    rfbNewClientConnection(rfbScreen,rfbScreen->httpSock);
-	    rfbScreen->httpSock = -1;
-	    return;
-	}
-	if (!strncmp(buf, "GET ",4) && !strncmp(strchr(buf,'/'),"/proxied.connection HTTP/1.", 27)) {
-	    /* proxy connection */
-	    rfbLog("httpd: client asked for /proxied.connection\n");
-	    rfbWriteExact(&cl,PROXY_OK_STR,strlen(PROXY_OK_STR));
-	    rfbNewClientConnection(rfbScreen,rfbScreen->httpSock);
-	    rfbScreen->httpSock = -1;
-	    return;
-	}	   
-    }
-
-    if (strncmp(buf, "GET ", 4)) {
-	rfbErr("httpd: no GET line\n");
-	httpCloseSock(rfbScreen);
-	return;
-    } else {
-	/* Only use the first line. */
-	buf[strcspn(buf, "\n\r")] = '\0';
-    }
-
-    if (strlen(buf) > maxFnameLen) {
-	rfbErr("httpd: GET line too long\n");
-	httpCloseSock(rfbScreen);
-	return;
-    }
-
-    if (sscanf(buf, "GET %s HTTP/1.", fname) != 1) {
-	rfbErr("httpd: couldn't parse GET line\n");
-	httpCloseSock(rfbScreen);
-	return;
-    }
-
-    if (fname[0] != '/') {
-	rfbErr("httpd: filename didn't begin with '/'\n");
-	rfbWriteExact(&cl, NOT_FOUND_STR, strlen(NOT_FOUND_STR));
-	httpCloseSock(rfbScreen);
-	return;
-    }
-
-    if (strchr(fname+1, '/') != NULL) {
-	rfbErr("httpd: asking for file in other directory\n");
-	rfbWriteExact(&cl, NOT_FOUND_STR, strlen(NOT_FOUND_STR));
-	httpCloseSock(rfbScreen);
-	return;
-    }
-
-    getpeername(rfbScreen->httpSock, (struct sockaddr *)&addr, &addrlen);
-    rfbLog("httpd: get '%s' for %s\n", fname+1,
-	   inet_ntoa(addr.sin_addr));
-
-    /* Extract parameters from the URL string if necessary */
-
-    params[0] = '\0';
-    ptr = strchr(fname, '?');
-    if (ptr != NULL) {
-       *ptr = '\0';
-       if (!parseParams(&ptr[1], params, 1024)) {
-           params[0] = '\0';
-           rfbErr("httpd: bad parameters in the URL\n");
-       }
-    }
-
-
-    /* If we were asked for '/', actually read the file index.vnc */
-
-    if (strcmp(fname, "/") == 0) {
-	strcpy(fname, "/index.vnc");
-	rfbLog("httpd: defaulting to '%s'\n", fname+1);
-    }
-
-    /* Substitutions are performed on files ending .vnc */
-
-    if (strlen(fname) >= 4 && strcmp(&fname[strlen(fname)-4], ".vnc") == 0) {
-	performSubstitutions = TRUE;
-    }
-
-    /* Open the file */
-
-    if ((fd = fopen(fullFname, "r")) == 0) {
-        rfbLogPerror("httpProcessInput: open");
-        rfbWriteExact(&cl, NOT_FOUND_STR, strlen(NOT_FOUND_STR));
-        httpCloseSock(rfbScreen);
-        return;
-    }
-
-    rfbWriteExact(&cl, OK_STR, strlen(OK_STR));
-
-    while (1) {
-	int n = fread(buf, 1, BUF_SIZE-1, fd);
-	if (n < 0) {
-	    rfbLogPerror("httpProcessInput: read");
-	    fclose(fd);
-	    httpCloseSock(rfbScreen);
-	    return;
-	}
-
-	if (n == 0)
-	    break;
-
-	if (performSubstitutions) {
-
-	    /* Substitute $WIDTH, $HEIGHT, etc with the appropriate values.
-	       This won't quite work properly if the .vnc file is longer than
-	       BUF_SIZE, but it's reasonable to assume that .vnc files will
-	       always be short. */
-
-	    char *ptr = buf;
-	    char *dollar;
-	    buf[n] = 0; /* make sure it's null-terminated */
-
-	    while ((dollar = strchr(ptr, '$'))!=NULL) {
-		rfbWriteExact(&cl, ptr, (dollar - ptr));
-
-		ptr = dollar;
-
-		if (compareAndSkip(&ptr, "$WIDTH")) {
-
-		    sprintf(str, "%d", rfbScreen->width);
-		    rfbWriteExact(&cl, str, strlen(str));
-
-		} else if (compareAndSkip(&ptr, "$HEIGHT")) {
-
-		    sprintf(str, "%d", rfbScreen->height);
-		    rfbWriteExact(&cl, str, strlen(str));
-
-		} else if (compareAndSkip(&ptr, "$APPLETWIDTH")) {
-
-		    sprintf(str, "%d", rfbScreen->width);
-		    rfbWriteExact(&cl, str, strlen(str));
-
-		} else if (compareAndSkip(&ptr, "$APPLETHEIGHT")) {
-
-		    sprintf(str, "%d", rfbScreen->height + 32);
-		    rfbWriteExact(&cl, str, strlen(str));
-
-		} else if (compareAndSkip(&ptr, "$PORT")) {
-
-		    sprintf(str, "%d", rfbScreen->port);
-		    rfbWriteExact(&cl, str, strlen(str));
-
-		} else if (compareAndSkip(&ptr, "$DESKTOP")) {
-
-		    rfbWriteExact(&cl, rfbScreen->desktopName, strlen(rfbScreen->desktopName));
-
-		} else if (compareAndSkip(&ptr, "$DISPLAY")) {
-
-		    sprintf(str, "%s:%d", rfbScreen->thisHost, rfbScreen->port-5900);
-		    rfbWriteExact(&cl, str, strlen(str));
-
-		} else if (compareAndSkip(&ptr, "$USER")) {
-#ifndef WIN32
-		    if (user) {
-			rfbWriteExact(&cl, user,
-				   strlen(user));
-		    } else
-#endif
-			rfbWriteExact(&cl, "?", 1);
-		} else if (compareAndSkip(&ptr, "$PARAMS")) {
-		    if (params[0] != '\0')
-			rfbWriteExact(&cl, params, strlen(params));
-		} else {
-		    if (!compareAndSkip(&ptr, "$$"))
-			ptr++;
-
-		    if (rfbWriteExact(&cl, "$", 1) < 0) {
-			fclose(fd);
-			httpCloseSock(rfbScreen);
-			return;
-		    }
-		}
-	    }
-	    if (rfbWriteExact(&cl, ptr, (&buf[n] - ptr)) < 0)
-		break;
-
-	} else {
-
-	    /* For files not ending .vnc, just write out the buffer */
-
-	    if (rfbWriteExact(&cl, buf, n) < 0)
-		break;
-	}
-    }
-
-    fclose(fd);
-    httpCloseSock(rfbScreen);
-}
-
-
-static rfbBool
-compareAndSkip(char **ptr, const char *str)
-{
-    if (strncmp(*ptr, str, strlen(str)) == 0) {
-	*ptr += strlen(str);
-	return TRUE;
-    }
-
-    return FALSE;
-}
-
-/*
- * Parse the request tail after the '?' character, and format a sequence
- * of <param> tags for inclusion into an HTML page with embedded applet.
- */
-
-static rfbBool
-parseParams(const char *request, char *result, int max_bytes)
-{
-    char param_request[128];
-    char param_formatted[196];
-    const char *tail;
-    char *delim_ptr;
-    char *value_str;
-    int cur_bytes, len;
-
-    result[0] = '\0';
-    cur_bytes = 0;
-
-    tail = request;
-    for (;;) {
-	/* Copy individual "name=value" string into a buffer */
-	delim_ptr = strchr((char *)tail, '&');
-	if (delim_ptr == NULL) {
-	    if (strlen(tail) >= sizeof(param_request)) {
-		return FALSE;
-	    }
-	    strcpy(param_request, tail);
-	} else {
-	    len = delim_ptr - tail;
-	    if (len >= sizeof(param_request)) {
-		return FALSE;
-	    }
-	    memcpy(param_request, tail, len);
-	    param_request[len] = '\0';
-	}
-
-	/* Split the request into parameter name and value */
-	value_str = strchr(&param_request[1], '=');
-	if (value_str == NULL) {
-	    return FALSE;
-	}
-	*value_str++ = '\0';
-	if (strlen(value_str) == 0) {
-	    return FALSE;
-	}
-
-	/* Validate both parameter name and value */
-	if (!validateString(param_request) || !validateString(value_str)) {
-	    return FALSE;
-	}
-
-	/* Prepare HTML-formatted representation of the name=value pair */
-	len = sprintf(param_formatted,
-		      "<PARAM NAME=\"%s\" VALUE=\"%s\">\n",
-		      param_request, value_str);
-	if (cur_bytes + len + 1 > max_bytes) {
-	    return FALSE;
-	}
-	strcat(result, param_formatted);
-	cur_bytes += len;
-
-	/* Go to the next parameter */
-	if (delim_ptr == NULL) {
-	    break;
-	}
-	tail = delim_ptr + 1;
-    }
-    return TRUE;
-}
-
-/*
- * Check if the string consists only of alphanumeric characters, '+'
- * signs, underscores, and dots. Replace all '+' signs with spaces.
- */
-
-static rfbBool
-validateString(char *str)
-{
-    char *ptr;
-
-    for (ptr = str; *ptr != '\0'; ptr++) {
-	if (!isalnum(*ptr) && *ptr != '_' && *ptr != '.') {
-	    if (*ptr == '+') {
-		*ptr = ' ';
-	    } else {
-		return FALSE;
-	    }
-	}
-    }
-    return TRUE;
-}
-
diff --git a/libvncserver/libvncserver-config.h.cmake b/libvncserver/libvncserver-config.h.cmake
deleted file mode 100644
index 1ae879c..0000000
--- a/libvncserver/libvncserver-config.h.cmake
+++ /dev/null
@@ -1,95 +0,0 @@
-#ifndef _RFB_RFBCONFIG_H
-#define _RFB_RFBCONFIG_H
-
-/* rfb/rfbconfig.h. Generated automatically by cmake. */
-
-/* Enable 24 bit per pixel in native framebuffer */
-#cmakedefine LIBVNCSERVER_ALLOW24BPP  1
-
-/* work around when write() returns ENOENT but does not mean it */
-#cmakedefine LIBVNCSERVER_ENOENT_WORKAROUND 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_FCNTL_H  1
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#cmakedefine LIBVNCSERVER_HAVE_GETTIMEOFDAY  1
-
-/* Define to 1 if you have the `jpeg' library (-ljpeg). */
-#cmakedefine LIBVNCSERVER_HAVE_LIBJPEG  1
-
-/* Define to 1 if you have the `pthread' library (-lpthread). */
-#cmakedefine LIBVNCSERVER_HAVE_LIBPTHREAD  1
-
-/* Define to 1 if you have the `z' library (-lz). */
-#cmakedefine LIBVNCSERVER_HAVE_LIBZ  1
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_NETINET_IN_H  1
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_SOCKET_H  1
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_STAT_H  1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_TIME_H  1
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_TYPES_H  1
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_WAIT_H  1
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_UNISTD_H  1
-
-/* Need a typedef for in_addr_t */
-#cmakedefine LIBVNCSERVER_NEED_INADDR_T 1
-
-/* Define to the full name and version of this package. */
-#define LIBVNCSERVER_PACKAGE_STRING  "@FULL_PACKAGE_NAME@ @PACKAGE_VERSION@"
-
-/* Define to the version of this package. */
-#define LIBVNCSERVER_PACKAGE_VERSION  "@PACKAGE_VERSION@"
-
-/* Define to 1 if libgcrypt is present */
-#cmakedefine LIBVNCSERVER_WITH_CLIENT_GCRYPT 1
-
-/* Define to 1 if GnuTLS is present */
-#cmakedefine LIBVNCSERVER_WITH_CLIENT_TLS 1
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-#cmakedefine LIBVNCSERVER_WORDS_BIGENDIAN 1
-
-/* Define to empty if `const' does not conform to ANSI C. */
-#cmakedefine const @CMAKE_CONST@
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-#cmakedefine inline @CMAKE_INLINE@
-#endif
-
-/* Define to `int' if <sys/types.h> does not define. */
-#cmakedefine HAVE_LIBVNCSERVER_PID_T 1
-#ifndef HAVE_LIBVNCSERVER_PID_T
-typedef int pid_t;
-#endif
-
-/* The type for size_t */
-#cmakedefine HAVE_LIBVNCSERVER_SIZE_T 1
-#ifndef HAVE_LIBVNCSERVER_SIZE_T
-typedef int size_t;
-#endif
-
-/* The type for socklen */
-#cmakedefine HAVE_LIBVNCSERVER_SOCKLEN_T 1
-#ifndef HAVE_LIBVNCSERVER_SOCKLEN_T
-typedef int socklen_t;
-#endif
-
-/* once: _RFB_RFBCONFIG_H */
-#endif
diff --git a/libvncserver/lzoconf.h b/libvncserver/lzoconf.h
deleted file mode 100644
index d6125e8..0000000
--- a/libvncserver/lzoconf.h
+++ /dev/null
@@ -1,419 +0,0 @@
-/* lzoconf.h -- configuration for the LZO real-time data compression library
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-
-#ifndef __LZOCONF_H_INCLUDED
-#define __LZOCONF_H_INCLUDED 1
-
-#define LZO_VERSION             0x2040
-#define LZO_VERSION_STRING      "2.04"
-#define LZO_VERSION_DATE        "Oct 31 2010"
-
-/* internal Autoconf configuration file - only used when building LZO */
-#if defined(LZO_HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-#include <limits.h>
-#include <stddef.h>
-
-
-/***********************************************************************
-// LZO requires a conforming <limits.h>
-************************************************************************/
-
-#if !defined(CHAR_BIT) || (CHAR_BIT != 8)
-#  error "invalid CHAR_BIT"
-#endif
-#if !defined(UCHAR_MAX) || !defined(UINT_MAX) || !defined(ULONG_MAX)
-#  error "check your compiler installation"
-#endif
-#if (USHRT_MAX < 1) || (UINT_MAX < 1) || (ULONG_MAX < 1)
-#  error "your limits.h macros are broken"
-#endif
-
-/* get OS and architecture defines */
-#ifndef __LZODEFS_H_INCLUDED
-#include "lzodefs.h"
-#endif
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/***********************************************************************
-// some core defines
-************************************************************************/
-
-#if !defined(LZO_UINT32_C)
-#  if (UINT_MAX < LZO_0xffffffffL)
-#    define LZO_UINT32_C(c)     c ## UL
-#  else
-#    define LZO_UINT32_C(c)     ((c) + 0U)
-#  endif
-#endif
-
-/* memory checkers */
-#if !defined(__LZO_CHECKER)
-#  if defined(__BOUNDS_CHECKING_ON)
-#    define __LZO_CHECKER       1
-#  elif defined(__CHECKER__)
-#    define __LZO_CHECKER       1
-#  elif defined(__INSURE__)
-#    define __LZO_CHECKER       1
-#  elif defined(__PURIFY__)
-#    define __LZO_CHECKER       1
-#  endif
-#endif
-
-
-/***********************************************************************
-// integral and pointer types
-************************************************************************/
-
-/* lzo_uint should match size_t */
-#if !defined(LZO_UINT_MAX)
-#  if defined(LZO_ABI_LLP64) /* WIN64 */
-#    if defined(LZO_OS_WIN64)
-     typedef unsigned __int64   lzo_uint;
-     typedef __int64            lzo_int;
-#    else
-     typedef unsigned long long lzo_uint;
-     typedef long long          lzo_int;
-#    endif
-#    define LZO_UINT_MAX        0xffffffffffffffffull
-#    define LZO_INT_MAX         9223372036854775807LL
-#    define LZO_INT_MIN         (-1LL - LZO_INT_MAX)
-#  elif defined(LZO_ABI_IP32L64) /* MIPS R5900 */
-     typedef unsigned int       lzo_uint;
-     typedef int                lzo_int;
-#    define LZO_UINT_MAX        UINT_MAX
-#    define LZO_INT_MAX         INT_MAX
-#    define LZO_INT_MIN         INT_MIN
-#  elif (ULONG_MAX >= LZO_0xffffffffL)
-     typedef unsigned long      lzo_uint;
-     typedef long               lzo_int;
-#    define LZO_UINT_MAX        ULONG_MAX
-#    define LZO_INT_MAX         LONG_MAX
-#    define LZO_INT_MIN         LONG_MIN
-#  else
-#    error "lzo_uint"
-#  endif
-#endif
-
-/* Integral types with 32 bits or more. */
-#if !defined(LZO_UINT32_MAX)
-#  if (UINT_MAX >= LZO_0xffffffffL)
-     typedef unsigned int       lzo_uint32;
-     typedef int                lzo_int32;
-#    define LZO_UINT32_MAX      UINT_MAX
-#    define LZO_INT32_MAX       INT_MAX
-#    define LZO_INT32_MIN       INT_MIN
-#  elif (ULONG_MAX >= LZO_0xffffffffL)
-     typedef unsigned long      lzo_uint32;
-     typedef long               lzo_int32;
-#    define LZO_UINT32_MAX      ULONG_MAX
-#    define LZO_INT32_MAX       LONG_MAX
-#    define LZO_INT32_MIN       LONG_MIN
-#  else
-#    error "lzo_uint32"
-#  endif
-#endif
-
-/* The larger type of lzo_uint and lzo_uint32. */
-#if (LZO_UINT_MAX >= LZO_UINT32_MAX)
-#  define lzo_xint              lzo_uint
-#else
-#  define lzo_xint              lzo_uint32
-#endif
-
-/* Memory model that allows to access memory at offsets of lzo_uint. */
-#if !defined(__LZO_MMODEL)
-#  if (LZO_UINT_MAX <= UINT_MAX)
-#    define __LZO_MMODEL        /*empty*/
-#  elif defined(LZO_HAVE_MM_HUGE_PTR)
-#    define __LZO_MMODEL_HUGE   1
-#    define __LZO_MMODEL        __huge
-#  else
-#    define __LZO_MMODEL        /*empty*/
-#  endif
-#endif
-
-/* no typedef here because of const-pointer issues */
-#define lzo_bytep               unsigned char __LZO_MMODEL *
-#define lzo_charp               char __LZO_MMODEL *
-#define lzo_voidp               void __LZO_MMODEL *
-#define lzo_shortp              short __LZO_MMODEL *
-#define lzo_ushortp             unsigned short __LZO_MMODEL *
-#define lzo_uint32p             lzo_uint32 __LZO_MMODEL *
-#define lzo_int32p              lzo_int32 __LZO_MMODEL *
-#define lzo_uintp               lzo_uint __LZO_MMODEL *
-#define lzo_intp                lzo_int __LZO_MMODEL *
-#define lzo_xintp               lzo_xint __LZO_MMODEL *
-#define lzo_voidpp              lzo_voidp __LZO_MMODEL *
-#define lzo_bytepp              lzo_bytep __LZO_MMODEL *
-/* deprecated - use 'lzo_bytep' instead of 'lzo_byte *' */
-#define lzo_byte                unsigned char __LZO_MMODEL
-
-typedef int lzo_bool;
-
-
-/***********************************************************************
-// function types
-************************************************************************/
-
-/* name mangling */
-#if !defined(__LZO_EXTERN_C)
-#  ifdef __cplusplus
-#    define __LZO_EXTERN_C      extern "C"
-#  else
-#    define __LZO_EXTERN_C      extern
-#  endif
-#endif
-
-/* calling convention */
-#if !defined(__LZO_CDECL)
-#  define __LZO_CDECL           __lzo_cdecl
-#endif
-
-/* DLL export information */
-#if !defined(__LZO_EXPORT1)
-#  define __LZO_EXPORT1         /*empty*/
-#endif
-#if !defined(__LZO_EXPORT2)
-#  define __LZO_EXPORT2         /*empty*/
-#endif
-
-/* __cdecl calling convention for public C and assembly functions */
-#if !defined(LZO_PUBLIC)
-#  define LZO_PUBLIC(_rettype)  __LZO_EXPORT1 _rettype __LZO_EXPORT2 __LZO_CDECL
-#endif
-#if !defined(LZO_EXTERN)
-#  define LZO_EXTERN(_rettype)  __LZO_EXTERN_C LZO_PUBLIC(_rettype)
-#endif
-#if !defined(LZO_PRIVATE)
-#  define LZO_PRIVATE(_rettype) static _rettype __LZO_CDECL
-#endif
-
-/* function types */
-typedef int
-(__LZO_CDECL *lzo_compress_t)   ( const lzo_bytep src, lzo_uint  src_len,
-                                        lzo_bytep dst, lzo_uintp dst_len,
-                                        lzo_voidp wrkmem );
-
-typedef int
-(__LZO_CDECL *lzo_decompress_t) ( const lzo_bytep src, lzo_uint  src_len,
-                                        lzo_bytep dst, lzo_uintp dst_len,
-                                        lzo_voidp wrkmem );
-
-typedef int
-(__LZO_CDECL *lzo_optimize_t)   (       lzo_bytep src, lzo_uint  src_len,
-                                        lzo_bytep dst, lzo_uintp dst_len,
-                                        lzo_voidp wrkmem );
-
-typedef int
-(__LZO_CDECL *lzo_compress_dict_t)(const lzo_bytep src, lzo_uint  src_len,
-                                         lzo_bytep dst, lzo_uintp dst_len,
-                                         lzo_voidp wrkmem,
-                                   const lzo_bytep dict, lzo_uint dict_len );
-
-typedef int
-(__LZO_CDECL *lzo_decompress_dict_t)(const lzo_bytep src, lzo_uint  src_len,
-                                           lzo_bytep dst, lzo_uintp dst_len,
-                                           lzo_voidp wrkmem,
-                                     const lzo_bytep dict, lzo_uint dict_len );
-
-
-/* Callback interface. Currently only the progress indicator ("nprogress")
- * is used, but this may change in a future release. */
-
-struct lzo_callback_t;
-typedef struct lzo_callback_t lzo_callback_t;
-#define lzo_callback_p lzo_callback_t __LZO_MMODEL *
-
-/* malloc & free function types */
-typedef lzo_voidp (__LZO_CDECL *lzo_alloc_func_t)
-    (lzo_callback_p self, lzo_uint items, lzo_uint size);
-typedef void      (__LZO_CDECL *lzo_free_func_t)
-    (lzo_callback_p self, lzo_voidp ptr);
-
-/* a progress indicator callback function */
-typedef void (__LZO_CDECL *lzo_progress_func_t)
-    (lzo_callback_p, lzo_uint, lzo_uint, int);
-
-struct lzo_callback_t
-{
-    /* custom allocators (set to 0 to disable) */
-    lzo_alloc_func_t nalloc;                /* [not used right now] */
-    lzo_free_func_t nfree;                  /* [not used right now] */
-
-    /* a progress indicator callback function (set to 0 to disable) */
-    lzo_progress_func_t nprogress;
-
-    /* NOTE: the first parameter "self" of the nalloc/nfree/nprogress
-     * callbacks points back to this struct, so you are free to store
-     * some extra info in the following variables. */
-    lzo_voidp user1;
-    lzo_xint user2;
-    lzo_xint user3;
-};
-
-
-/***********************************************************************
-// error codes and prototypes
-************************************************************************/
-
-/* Error codes for the compression/decompression functions. Negative
- * values are errors, positive values will be used for special but
- * normal events.
- */
-#define LZO_E_OK                    0
-#define LZO_E_ERROR                 (-1)
-#define LZO_E_OUT_OF_MEMORY         (-2)    /* [not used right now] */
-#define LZO_E_NOT_COMPRESSIBLE      (-3)    /* [not used right now] */
-#define LZO_E_INPUT_OVERRUN         (-4)
-#define LZO_E_OUTPUT_OVERRUN        (-5)
-#define LZO_E_LOOKBEHIND_OVERRUN    (-6)
-#define LZO_E_EOF_NOT_FOUND         (-7)
-#define LZO_E_INPUT_NOT_CONSUMED    (-8)
-#define LZO_E_NOT_YET_IMPLEMENTED   (-9)    /* [not used right now] */
-
-
-#ifndef lzo_sizeof_dict_t
-#  define lzo_sizeof_dict_t     ((unsigned)sizeof(lzo_bytep))
-#endif
-
-/* lzo_init() should be the first function you call.
- * Check the return code !
- *
- * lzo_init() is a macro to allow checking that the library and the
- * compiler's view of various types are consistent.
- */
-#define lzo_init() __lzo_init_v2(LZO_VERSION,(int)sizeof(short),(int)sizeof(int),\
-    (int)sizeof(long),(int)sizeof(lzo_uint32),(int)sizeof(lzo_uint),\
-    (int)lzo_sizeof_dict_t,(int)sizeof(char *),(int)sizeof(lzo_voidp),\
-    (int)sizeof(lzo_callback_t))
-LZO_EXTERN(int) __lzo_init_v2(unsigned,int,int,int,int,int,int,int,int,int);
-
-/* version functions (useful for shared libraries) */
-LZO_EXTERN(unsigned) lzo_version(void);
-LZO_EXTERN(const char *) lzo_version_string(void);
-LZO_EXTERN(const char *) lzo_version_date(void);
-LZO_EXTERN(const lzo_charp) _lzo_version_string(void);
-LZO_EXTERN(const lzo_charp) _lzo_version_date(void);
-
-/* string functions */
-LZO_EXTERN(int)
-    lzo_memcmp(const lzo_voidp a, const lzo_voidp b, lzo_uint len);
-LZO_EXTERN(lzo_voidp)
-    lzo_memcpy(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
-LZO_EXTERN(lzo_voidp)
-    lzo_memmove(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
-LZO_EXTERN(lzo_voidp)
-    lzo_memset(lzo_voidp buf, int c, lzo_uint len);
-
-/* checksum functions */
-LZO_EXTERN(lzo_uint32)
-    lzo_adler32(lzo_uint32 c, const lzo_bytep buf, lzo_uint len);
-LZO_EXTERN(lzo_uint32)
-    lzo_crc32(lzo_uint32 c, const lzo_bytep buf, lzo_uint len);
-LZO_EXTERN(const lzo_uint32p)
-    lzo_get_crc32_table(void);
-
-/* misc. */
-LZO_EXTERN(int) _lzo_config_check(void);
-typedef union { lzo_bytep p; lzo_uint u; } __lzo_pu_u;
-typedef union { lzo_bytep p; lzo_uint32 u32; } __lzo_pu32_u;
-typedef union { void *vp; lzo_bytep bp; lzo_uint u; lzo_uint32 u32; unsigned long l; } lzo_align_t;
-
-/* align a char pointer on a boundary that is a multiple of 'size' */
-LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp p, lzo_uint size);
-#define LZO_PTR_ALIGN_UP(p,size) \
-    ((p) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(p),(lzo_uint)(size)))
-
-
-/***********************************************************************
-// deprecated macros - only for backward compatibility with LZO v1.xx
-************************************************************************/
-
-#if defined(LZO_CFG_COMPAT)
-
-#define __LZOCONF_H 1
-
-#if defined(LZO_ARCH_I086)
-#  define __LZO_i386 1
-#elif defined(LZO_ARCH_I386)
-#  define __LZO_i386 1
-#endif
-
-#if defined(LZO_OS_DOS16)
-#  define __LZO_DOS 1
-#  define __LZO_DOS16 1
-#elif defined(LZO_OS_DOS32)
-#  define __LZO_DOS 1
-#elif defined(LZO_OS_WIN16)
-#  define __LZO_WIN 1
-#  define __LZO_WIN16 1
-#elif defined(LZO_OS_WIN32)
-#  define __LZO_WIN 1
-#endif
-
-#define __LZO_CMODEL            /*empty*/
-#define __LZO_DMODEL            /*empty*/
-#define __LZO_ENTRY             __LZO_CDECL
-#define LZO_EXTERN_CDECL        LZO_EXTERN
-#define LZO_ALIGN               LZO_PTR_ALIGN_UP
-
-#define lzo_compress_asm_t      lzo_compress_t
-#define lzo_decompress_asm_t    lzo_decompress_t
-
-#endif /* LZO_CFG_COMPAT */
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-
-#endif /* already included */
-
-
-/* vim:set ts=4 et: */
diff --git a/libvncserver/lzodefs.h b/libvncserver/lzodefs.h
deleted file mode 100644
index 190013f..0000000
--- a/libvncserver/lzodefs.h
+++ /dev/null
@@ -1,1851 +0,0 @@
-/* lzodefs.h -- architecture, OS and compiler specific defines
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-
-#ifndef __LZODEFS_H_INCLUDED
-#define __LZODEFS_H_INCLUDED 1
-
-#if defined(__CYGWIN32__) && !defined(__CYGWIN__)
-#  define __CYGWIN__ __CYGWIN32__
-#endif
-#if defined(__IBMCPP__) && !defined(__IBMC__)
-#  define __IBMC__ __IBMCPP__
-#endif
-#if defined(__ICL) && defined(_WIN32) && !defined(__INTEL_COMPILER)
-#  define __INTEL_COMPILER __ICL
-#endif
-#if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
-#  define _ALL_SOURCE 1
-#endif
-#if defined(__mips__) && defined(__R5900__)
-#  if !defined(__LONG_MAX__)
-#    define __LONG_MAX__ 9223372036854775807L
-#  endif
-#endif
-#if defined(__INTEL_COMPILER) && defined(__linux__)
-#  pragma warning(disable: 193)
-#endif
-#if defined(__KEIL__) && defined(__C166__)
-#  pragma warning disable = 322
-#elif 0 && defined(__C251__)
-#  pragma warning disable = 322
-#endif
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
-#  if (_MSC_VER >= 1300)
-#    pragma warning(disable: 4668)
-#  endif
-#endif
-#if 0 && defined(__WATCOMC__)
-#  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
-#    pragma warning 203 9
-#  endif
-#endif
-#if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
-#  pragma option -h
-#endif
-#if 0
-#define LZO_0xffffL             0xfffful
-#define LZO_0xffffffffL         0xfffffffful
-#else
-#define LZO_0xffffL             65535ul
-#define LZO_0xffffffffL         4294967295ul
-#endif
-#if (LZO_0xffffL == LZO_0xffffffffL)
-#  error "your preprocessor is broken 1"
-#endif
-#if (16ul * 16384ul != 262144ul)
-#  error "your preprocessor is broken 2"
-#endif
-#if 0
-#if (32767 >= 4294967295ul)
-#  error "your preprocessor is broken 3"
-#endif
-#if (65535u >= 4294967295ul)
-#  error "your preprocessor is broken 4"
-#endif
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
-#  if !defined(MSDOS)
-#    define MSDOS 1
-#  endif
-#  if !defined(_MSDOS)
-#    define _MSDOS 1
-#  endif
-#elif 0 && defined(__VERSION) && defined(MB_LEN_MAX)
-#  if (__VERSION == 520) && (MB_LEN_MAX == 1)
-#    if !defined(__AZTEC_C__)
-#      define __AZTEC_C__ __VERSION
-#    endif
-#    if !defined(__DOS__)
-#      define __DOS__ 1
-#    endif
-#  endif
-#endif
-#endif
-#if defined(_MSC_VER) && defined(M_I86HM) && (UINT_MAX == LZO_0xffffL)
-#  define ptrdiff_t long
-#  define _PTRDIFF_T_DEFINED 1
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#  if defined(__AZTEC_C__) && defined(__DOS__)
-#    define __LZO_RENAME_A 1
-#  elif defined(_MSC_VER) && defined(MSDOS)
-#    if (_MSC_VER < 600)
-#      define __LZO_RENAME_A 1
-#    elif (_MSC_VER < 700)
-#      define __LZO_RENAME_B 1
-#    endif
-#  elif defined(__TSC__) && defined(__OS2__)
-#    define __LZO_RENAME_A 1
-#  elif defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0410)
-#    define __LZO_RENAME_A 1
-#  elif defined(__PACIFIC__) && defined(DOS)
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#  endif
-#  if defined(__LZO_RENAME_A)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#  elif defined(__LZO_RENAME_B)
-#    if !defined(__cdecl)
-#      define __cdecl _cdecl
-#    endif
-#    if !defined(__far)
-#      define __far _far
-#    endif
-#    if !defined(__huge)
-#      define __huge _huge
-#    endif
-#    if !defined(__near)
-#      define __near _near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal _pascal
-#    endif
-#  elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#  endif
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__AZTEC_C__) && defined(__DOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#elif defined(_MSC_VER) && defined(MSDOS)
-#  if (_MSC_VER < 600)
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#  endif
-#  if (_MSC_VER < 700)
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#elif defined(__PACIFIC__) && defined(DOS)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#elif defined(__TURBOC__) && defined(__MSDOS__)
-#  if (__TURBOC__ < 0x0150)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#  endif
-#  if (__TURBOC__ < 0x0200)
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#  if (__TURBOC__ < 0x0400) && defined(__cplusplus)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  endif
-#elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  define LZO_BROKEN_SIZEOF 1
-#endif
-#endif
-#if defined(__WATCOMC__) && (__WATCOMC__ < 900)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#endif
-#if defined(_CRAY) && defined(_CRAY1)
-#  define LZO_BROKEN_SIGNED_RIGHT_SHIFT 1
-#endif
-#define LZO_PP_STRINGIZE(x)             #x
-#define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
-#define LZO_PP_CONCAT2(a,b)             a ## b
-#define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
-#define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
-#define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
-#define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
-#define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
-#define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
-#define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
-#if 1
-#define LZO_CPP_STRINGIZE(x)            #x
-#define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
-#define LZO_CPP_CONCAT2(a,b)            a ## b
-#define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
-#define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
-#define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
-#define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
-#define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
-#define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
-#define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
-#endif
-#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-1)) - (o)) << 1) + (o))
-#if 1 && defined(__cplusplus)
-#  if !defined(__STDC_CONSTANT_MACROS)
-#    define __STDC_CONSTANT_MACROS 1
-#  endif
-#  if !defined(__STDC_LIMIT_MACROS)
-#    define __STDC_LIMIT_MACROS 1
-#  endif
-#endif
-#if defined(__cplusplus)
-#  define LZO_EXTERN_C extern "C"
-#else
-#  define LZO_EXTERN_C extern
-#endif
-#if !defined(__LZO_OS_OVERRIDE)
-#if (LZO_OS_FREESTANDING)
-#  define LZO_INFO_OS           "freestanding"
-#elif (LZO_OS_EMBEDDED)
-#  define LZO_INFO_OS           "embedded"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_OS_EMBEDDED       1
-#  define LZO_INFO_OS           "embedded"
-#elif defined(__CYGWIN__) && defined(__GNUC__)
-#  define LZO_OS_CYGWIN         1
-#  define LZO_INFO_OS           "cygwin"
-#elif defined(__EMX__) && defined(__GNUC__)
-#  define LZO_OS_EMX            1
-#  define LZO_INFO_OS           "emx"
-#elif defined(__BEOS__)
-#  define LZO_OS_BEOS           1
-#  define LZO_INFO_OS           "beos"
-#elif defined(__Lynx__)
-#  define LZO_OS_LYNXOS         1
-#  define LZO_INFO_OS           "lynxos"
-#elif defined(__OS400__)
-#  define LZO_OS_OS400          1
-#  define LZO_INFO_OS           "os400"
-#elif defined(__QNX__)
-#  define LZO_OS_QNX            1
-#  define LZO_INFO_OS           "qnx"
-#elif defined(__BORLANDC__) && defined(__DPMI32__) && (__BORLANDC__ >= 0x0460)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__BORLANDC__) && defined(__DPMI16__)
-#  define LZO_OS_DOS16          1
-#  define LZO_INFO_OS           "dos16"
-#elif defined(__ZTC__) && defined(DOS386)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__OS2__) || defined(__OS2V2__)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_OS216        1
-#    define LZO_INFO_OS         "os216"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_OS2          1
-#    define LZO_INFO_OS         "os2"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WIN64__) || defined(_WIN64) || defined(WIN64)
-#  define LZO_OS_WIN64          1
-#  define LZO_INFO_OS           "win64"
-#elif defined(__WIN32__) || defined(_WIN32) || defined(WIN32) || defined(__WINDOWS_386__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__MWERKS__) && defined(__INTEL__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__WINDOWS__) || defined(_WINDOWS) || defined(_Windows)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_WIN16        1
-#    define LZO_INFO_OS         "win16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__DOS__) || defined(__MSDOS__) || defined(_MSDOS) || defined(MSDOS) || (defined(__PACIFIC__) && defined(DOS))
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_DOS32        1
-#    define LZO_INFO_OS         "dos32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WATCOMC__)
-#  if defined(__NT__) && (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif defined(__NT__) && (__WATCOMC__ < 1100)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  elif defined(__linux__) || defined(__LINUX__)
-#    define LZO_OS_POSIX        1
-#    define LZO_INFO_OS         "posix"
-#  else
-#    error "please specify a target using the -bt compiler option"
-#  endif
-#elif defined(__palmos__)
-#  define LZO_OS_PALMOS         1
-#  define LZO_INFO_OS           "palmos"
-#elif defined(__TOS__) || defined(__atarist__)
-#  define LZO_OS_TOS            1
-#  define LZO_INFO_OS           "tos"
-#elif defined(macintosh) && !defined(__ppc__)
-#  define LZO_OS_MACCLASSIC     1
-#  define LZO_INFO_OS           "macclassic"
-#elif defined(__VMS)
-#  define LZO_OS_VMS            1
-#  define LZO_INFO_OS           "vms"
-#elif ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PS2    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "ps2"
-#elif (defined(__mips__) && defined(__psp__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PSP    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "psp"
-#else
-#  define LZO_OS_POSIX          1
-#  define LZO_INFO_OS           "posix"
-#endif
-#if (LZO_OS_POSIX)
-#  if defined(_AIX) || defined(__AIX__) || defined(__aix__)
-#    define LZO_OS_POSIX_AIX        1
-#    define LZO_INFO_OS_POSIX       "aix"
-#  elif defined(__FreeBSD__)
-#    define LZO_OS_POSIX_FREEBSD    1
-#    define LZO_INFO_OS_POSIX       "freebsd"
-#  elif defined(__hpux__) || defined(__hpux)
-#    define LZO_OS_POSIX_HPUX       1
-#    define LZO_INFO_OS_POSIX       "hpux"
-#  elif defined(__INTERIX)
-#    define LZO_OS_POSIX_INTERIX    1
-#    define LZO_INFO_OS_POSIX       "interix"
-#  elif defined(__IRIX__) || defined(__irix__)
-#    define LZO_OS_POSIX_IRIX       1
-#    define LZO_INFO_OS_POSIX       "irix"
-#  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
-#    define LZO_OS_POSIX_LINUX      1
-#    define LZO_INFO_OS_POSIX       "linux"
-#  elif defined(__APPLE__) || defined(__MACOS__)
-#    define LZO_OS_POSIX_MACOSX     1
-#    define LZO_INFO_OS_POSIX       "macosx"
-#  elif defined(__minix__) || defined(__minix)
-#    define LZO_OS_POSIX_MINIX      1
-#    define LZO_INFO_OS_POSIX       "minix"
-#  elif defined(__NetBSD__)
-#    define LZO_OS_POSIX_NETBSD     1
-#    define LZO_INFO_OS_POSIX       "netbsd"
-#  elif defined(__OpenBSD__)
-#    define LZO_OS_POSIX_OPENBSD    1
-#    define LZO_INFO_OS_POSIX       "openbsd"
-#  elif defined(__osf__)
-#    define LZO_OS_POSIX_OSF        1
-#    define LZO_INFO_OS_POSIX       "osf"
-#  elif defined(__solaris__) || defined(__sun)
-#    if defined(__SVR4) || defined(__svr4__)
-#      define LZO_OS_POSIX_SOLARIS  1
-#      define LZO_INFO_OS_POSIX     "solaris"
-#    else
-#      define LZO_OS_POSIX_SUNOS    1
-#      define LZO_INFO_OS_POSIX     "sunos"
-#    endif
-#  elif defined(__ultrix__) || defined(__ultrix)
-#    define LZO_OS_POSIX_ULTRIX     1
-#    define LZO_INFO_OS_POSIX       "ultrix"
-#  elif defined(_UNICOS)
-#    define LZO_OS_POSIX_UNICOS     1
-#    define LZO_INFO_OS_POSIX       "unicos"
-#  else
-#    define LZO_OS_POSIX_UNKNOWN    1
-#    define LZO_INFO_OS_POSIX       "unknown"
-#  endif
-#endif
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (UINT_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
-#  define LZO_CC_CILLY          1
-#  define LZO_INFO_CC           "Cilly"
-#  if defined(__CILLY__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__CILLY__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif 0 && defined(SDCC) && defined(__VERSION__) && !defined(__GNUC__)
-#  define LZO_CC_SDCC           1
-#  define LZO_INFO_CC           "sdcc"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
-#elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
-#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + __PATHCC_MINOR__ * 0x100 + __PATHCC_PATCHLEVEL__)
-#  define LZO_INFO_CC           "Pathscale C"
-#  define LZO_INFO_CCVER        __PATHSCALE__
-#elif defined(__INTEL_COMPILER)
-#  define LZO_CC_INTELC         1
-#  define LZO_INFO_CC           "Intel C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
-#  if defined(_WIN32) || defined(_WIN64)
-#    define LZO_CC_SYNTAX_MSC 1
-#  else
-#    define LZO_CC_SYNTAX_GNUC 1
-#  endif
-#elif defined(__POCC__) && defined(_WIN32)
-#  define LZO_CC_PELLESC        1
-#  define LZO_INFO_CC           "Pelles C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
-#elif defined(__clang__) && defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
-#    define LZO_CC_CLANG_CLANG  (__clang_major__ * 0x10000L + __clang_minor__ * 0x100 + __clang_patchlevel__)
-#  else
-#    define LZO_CC_CLANG_CLANG  0x020700L
-#  endif
-#  define LZO_CC_CLANG          LZO_CC_CLANG_GNUC
-#  define LZO_INFO_CC           "clang"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
-#  define LZO_INFO_CC           "llvm-gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  elif defined(__GNUC_MINOR__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  else
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
-#  endif
-#  define LZO_INFO_CC           "gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__ACK__) && defined(_ACK)
-#  define LZO_CC_ACK            1
-#  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__AZTEC_C__)
-#  define LZO_CC_AZTECC         1
-#  define LZO_INFO_CC           "Aztec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
-#elif defined(__CODEGEARC__)
-#  define LZO_CC_CODEGEARC      1
-#  define LZO_INFO_CC           "CodeGear C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
-#elif defined(__BORLANDC__)
-#  define LZO_CC_BORLANDC       1
-#  define LZO_INFO_CC           "Borland C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__BORLANDC__)
-#elif defined(_CRAYC) && defined(_RELEASE)
-#  define LZO_CC_CRAYC          1
-#  define LZO_INFO_CC           "Cray C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(_RELEASE)
-#elif defined(__DMC__) && defined(__SC__)
-#  define LZO_CC_DMC            1
-#  define LZO_INFO_CC           "Digital Mars C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DMC__)
-#elif defined(__DECC)
-#  define LZO_CC_DECC           1
-#  define LZO_INFO_CC           "DEC C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
-#elif defined(__HIGHC__)
-#  define LZO_CC_HIGHC          1
-#  define LZO_INFO_CC           "MetaWare High C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_CC_IARC           1
-#  define LZO_INFO_CC           "IAR C"
-#  if defined(__VER__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__VER__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__IBMC__)
-#  define LZO_CC_IBMC           1
-#  define LZO_INFO_CC           "IBM C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
-#elif defined(__KEIL__) && defined(__C166__)
-#  define LZO_CC_KEILC          1
-#  define LZO_INFO_CC           "Keil C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__C166__)
-#elif defined(__LCC__) && defined(_WIN32) && defined(__LCCOPTIMLEVEL)
-#  define LZO_CC_LCCWIN32       1
-#  define LZO_INFO_CC           "lcc-win32"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__LCC__)
-#  define LZO_CC_LCC            1
-#  define LZO_INFO_CC           "lcc"
-#  if defined(__LCC_VERSION__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__LCC_VERSION__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(_MSC_VER)
-#  define LZO_CC_MSC            1
-#  define LZO_INFO_CC           "Microsoft C"
-#  if defined(_MSC_FULL_VER)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
-#  endif
-#elif defined(__MWERKS__)
-#  define LZO_CC_MWERKS         1
-#  define LZO_INFO_CC           "Metrowerks C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
-#elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
-#  define LZO_CC_NDPC           1
-#  define LZO_INFO_CC           "Microway NDP C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PACIFIC__)
-#  define LZO_CC_PACIFICC       1
-#  define LZO_INFO_CC           "Pacific C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
-#elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
-#  define LZO_CC_PGI            1
-#  define LZO_INFO_CC           "Portland Group PGI C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PUREC__) && defined(__TOS__)
-#  define LZO_CC_PUREC          1
-#  define LZO_INFO_CC           "Pure C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PUREC__)
-#elif defined(__SC__) && defined(__ZTC__)
-#  define LZO_CC_SYMANTECC      1
-#  define LZO_INFO_CC           "Symantec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
-#elif defined(__SUNPRO_C)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_C)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_C
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__SUNPRO_CC)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_CC)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_CC
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__TINYC__)
-#  define LZO_CC_TINYC          1
-#  define LZO_INFO_CC           "Tiny C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TINYC__)
-#elif defined(__TSC__)
-#  define LZO_CC_TOPSPEEDC      1
-#  define LZO_INFO_CC           "TopSpeed C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TSC__)
-#elif defined(__WATCOMC__)
-#  define LZO_CC_WATCOMC        1
-#  define LZO_INFO_CC           "Watcom C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__WATCOMC__)
-#elif defined(__TURBOC__)
-#  define LZO_CC_TURBOC         1
-#  define LZO_INFO_CC           "Turbo C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TURBOC__)
-#elif defined(__ZTC__)
-#  define LZO_CC_ZORTECHC       1
-#  define LZO_INFO_CC           "Zortech C"
-#  if (__ZTC__ == 0x310)
-#    define LZO_INFO_CCVER      "0x310"
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
-#  endif
-#else
-#  define LZO_CC_UNKNOWN        1
-#  define LZO_INFO_CC           "unknown"
-#  define LZO_INFO_CCVER        "unknown"
-#endif
-#if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
-#  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
-#  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
-#    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
-#      define LZO_ARCH_CRAY_MPP     1
-#    elif defined(_CRAY1)
-#      define LZO_ARCH_CRAY_PVP     1
-#    endif
-#  endif
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE)
-#if (LZO_ARCH_GENERIC)
-#  define LZO_INFO_ARCH             "generic"
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086             1
-#  define LZO_ARCH_IA16             1
-#  define LZO_INFO_ARCH             "i086"
-#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif (LZO_ARCH_CRAY_MPP) && (defined(_CRAYT3D) || defined(_CRAYT3E))
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif defined(__amd64__) || defined(__x86_64__) || defined(_M_AMD64)
-#  define LZO_ARCH_AMD64            1
-#  define LZO_INFO_ARCH             "amd64"
-#elif defined(__thumb__) || (defined(_M_ARM) && defined(_M_THUMB))
-#  define LZO_ARCH_ARM              1
-#  define LZO_ARCH_ARM_THUMB        1
-#  define LZO_INFO_ARCH             "arm_thumb"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
-#  define LZO_ARCH_ARM              1
-#  if defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 1)
-#    define LZO_ARCH_ARM_THUMB      1
-#    define LZO_INFO_ARCH           "arm_thumb"
-#  elif defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 2)
-#    define LZO_INFO_ARCH           "arm"
-#  else
-#    define LZO_INFO_ARCH           "arm"
-#  endif
-#elif defined(__arm__) || defined(_M_ARM)
-#  define LZO_ARCH_ARM              1
-#  define LZO_INFO_ARCH             "arm"
-#elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
-#  define LZO_ARCH_AVR              1
-#  define LZO_INFO_ARCH             "avr"
-#elif defined(__avr32__) || defined(__AVR32__)
-#  define LZO_ARCH_AVR32            1
-#  define LZO_INFO_ARCH             "avr32"
-#elif defined(__bfin__)
-#  define LZO_ARCH_BLACKFIN         1
-#  define LZO_INFO_ARCH             "blackfin"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C166__)
-#  define LZO_ARCH_C166             1
-#  define LZO_INFO_ARCH             "c166"
-#elif defined(__cris__)
-#  define LZO_ARCH_CRIS             1
-#  define LZO_INFO_ARCH             "cris"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCEZ80__)
-#  define LZO_ARCH_EZ80             1
-#  define LZO_INFO_ARCH             "ez80"
-#elif defined(__H8300__) || defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#  define LZO_ARCH_H8300            1
-#  define LZO_INFO_ARCH             "h8300"
-#elif defined(__hppa__) || defined(__hppa)
-#  define LZO_ARCH_HPPA             1
-#  define LZO_INFO_ARCH             "hppa"
-#elif defined(__386__) || defined(__i386__) || defined(__i386) || defined(_M_IX86) || defined(_M_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_CC_ZORTECHC && defined(__I86__))
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_OS_DOS32 && LZO_CC_HIGHC) && defined(_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif defined(__ia64__) || defined(__ia64) || defined(_M_IA64)
-#  define LZO_ARCH_IA64             1
-#  define LZO_INFO_ARCH             "ia64"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__m32c__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCM16C__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__m32r__)
-#  define LZO_ARCH_M32R             1
-#  define LZO_INFO_ARCH             "m32r"
-#elif (LZO_OS_TOS) || defined(__m68k__) || defined(__m68000__) || defined(__mc68000__) || defined(__mc68020__) || defined(_M_M68K)
-#  define LZO_ARCH_M68K             1
-#  define LZO_INFO_ARCH             "m68k"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C251__)
-#  define LZO_ARCH_MCS251           1
-#  define LZO_INFO_ARCH             "mcs251"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C51__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC8051__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__mips__) || defined(__mips) || defined(_MIPS_ARCH) || defined(_M_MRX000)
-#  define LZO_ARCH_MIPS             1
-#  define LZO_INFO_ARCH             "mips"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__MSP430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__powerpc__) || defined(__powerpc) || defined(__ppc__) || defined(__PPC__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PWR)
-#  define LZO_ARCH_POWERPC          1
-#  define LZO_INFO_ARCH             "powerpc"
-#elif defined(__s390__) || defined(__s390) || defined(__s390x__) || defined(__s390x)
-#  define LZO_ARCH_S390             1
-#  define LZO_INFO_ARCH             "s390"
-#elif defined(__sh__) || defined(_M_SH)
-#  define LZO_ARCH_SH               1
-#  define LZO_INFO_ARCH             "sh"
-#elif defined(__sparc__) || defined(__sparc) || defined(__sparcv8)
-#  define LZO_ARCH_SPARC            1
-#  define LZO_INFO_ARCH             "sparc"
-#elif defined(__SPU__)
-#  define LZO_ARCH_SPU              1
-#  define LZO_INFO_ARCH             "spu"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__z80)
-#  define LZO_ARCH_Z80              1
-#  define LZO_INFO_ARCH             "z80"
-#elif (LZO_ARCH_CRAY_PVP)
-#  if defined(_CRAYSV1)
-#    define LZO_ARCH_CRAY_SV1       1
-#    define LZO_INFO_ARCH           "cray_sv1"
-#  elif (_ADDR64)
-#    define LZO_ARCH_CRAY_T90       1
-#    define LZO_INFO_ARCH           "cray_t90"
-#  elif (_ADDR32)
-#    define LZO_ARCH_CRAY_YMP       1
-#    define LZO_INFO_ARCH           "cray_ymp"
-#  else
-#    define LZO_ARCH_CRAY_XMP       1
-#    define LZO_INFO_ARCH           "cray_xmp"
-#  endif
-#else
-#  define LZO_ARCH_UNKNOWN          1
-#  define LZO_INFO_ARCH             "unknown"
-#endif
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_DOS32 || LZO_OS_OS2)
-#  error "FIXME - missing define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
-#  error "FIXME - missing WIN32 define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
-#  error "FIXME - missing WIN64 define for CPU architecture"
-#endif
-#if (LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(BLX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#endif
-#if (LZO_ARCH_ARM_THUMB) && !(LZO_ARCH_ARM)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_ARCH_I086)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_ARCH_I386)
-#  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if !defined(__LZO_MM_OVERRIDE)
-#if (LZO_ARCH_I086)
-#if (UINT_MAX != LZO_0xffffL)
-#  error "this should not happen"
-#endif
-#if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
-#  define LZO_MM_TINY           1
-#elif defined(__HUGE__) || defined(_HUGE_) || defined(M_I86HM) || defined(_M_I86HM)
-#  define LZO_MM_HUGE           1
-#elif defined(__SMALL__) || defined(M_I86SM) || defined(_M_I86SM) || defined(SMALL_MODEL)
-#  define LZO_MM_SMALL          1
-#elif defined(__MEDIUM__) || defined(M_I86MM) || defined(_M_I86MM)
-#  define LZO_MM_MEDIUM         1
-#elif defined(__COMPACT__) || defined(M_I86CM) || defined(_M_I86CM)
-#  define LZO_MM_COMPACT        1
-#elif defined(__LARGE__) || defined(M_I86LM) || defined(_M_I86LM) || defined(LARGE_MODEL)
-#  define LZO_MM_LARGE          1
-#elif (LZO_CC_AZTECC)
-#  if defined(_LARGE_CODE) && defined(_LARGE_DATA)
-#    define LZO_MM_LARGE        1
-#  elif defined(_LARGE_CODE)
-#    define LZO_MM_MEDIUM       1
-#  elif defined(_LARGE_DATA)
-#    define LZO_MM_COMPACT      1
-#  else
-#    define LZO_MM_SMALL        1
-#  endif
-#elif (LZO_CC_ZORTECHC && defined(__VCM__))
-#  define LZO_MM_LARGE          1
-#else
-#  error "unknown memory model"
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#define LZO_HAVE_MM_HUGE_PTR        1
-#define LZO_HAVE_MM_HUGE_ARRAY      1
-#if (LZO_MM_TINY)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_ZORTECHC)
-#  undef LZO_HAVE_MM_HUGE_PTR
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_MSC && defined(_QC))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#  if (_MSC_VER < 600)
-#    undef LZO_HAVE_MM_HUGE_PTR
-#  endif
-#elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
-#  if (LZO_OS_DOS16)
-#    error "this should not happen"
-#  elif (LZO_CC_ZORTECHC)
-#  else
-#    error "this should not happen"
-#  endif
-#endif
-#ifdef __cplusplus
-extern "C" {
-#endif
-#if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0200))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_MSC || LZO_CC_TOPSPEEDC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_TURBOC && (__TURBOC__ >= 0x0295))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif ((LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_TURBOC) && LZO_OS_DOS16)
-#  define LZO_MM_AHSHIFT      12
-#elif (LZO_CC_WATCOMC)
-   extern unsigned char _HShift;
-#  define LZO_MM_AHSHIFT      ((unsigned) _HShift)
-#else
-#  error "FIXME - implement LZO_MM_AHSHIFT"
-#endif
-#ifdef __cplusplus
-}
-#endif
-#endif
-#elif (LZO_ARCH_C166)
-#if !defined(__MODEL__)
-#  error "FIXME - C166 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - C166 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS251)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS251 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS251 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS51)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS51 __MODEL__"
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS51 __MODEL__"
-#endif
-#elif (LZO_ARCH_CRAY_PVP)
-#  define LZO_MM_PVP            1
-#else
-#  define LZO_MM_FLAT           1
-#endif
-#if (LZO_MM_COMPACT)
-#  define LZO_INFO_MM           "compact"
-#elif (LZO_MM_FLAT)
-#  define LZO_INFO_MM           "flat"
-#elif (LZO_MM_HUGE)
-#  define LZO_INFO_MM           "huge"
-#elif (LZO_MM_LARGE)
-#  define LZO_INFO_MM           "large"
-#elif (LZO_MM_MEDIUM)
-#  define LZO_INFO_MM           "medium"
-#elif (LZO_MM_PVP)
-#  define LZO_INFO_MM           "pvp"
-#elif (LZO_MM_SMALL)
-#  define LZO_INFO_MM           "small"
-#elif (LZO_MM_TINY)
-#  define LZO_INFO_MM           "tiny"
-#else
-#  error "unknown memory model"
-#endif
-#endif
-#if defined(SIZEOF_SHORT)
-#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
-#endif
-#if defined(SIZEOF_INT)
-#  define LZO_SIZEOF_INT            (SIZEOF_INT)
-#endif
-#if defined(SIZEOF_LONG)
-#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
-#endif
-#if defined(SIZEOF_LONG_LONG)
-#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
-#endif
-#if defined(SIZEOF___INT16)
-#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
-#endif
-#if defined(SIZEOF___INT32)
-#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
-#endif
-#if defined(SIZEOF___INT64)
-#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
-#endif
-#if defined(SIZEOF_VOID_P)
-#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
-#endif
-#if defined(SIZEOF_SIZE_T)
-#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
-#endif
-#if defined(SIZEOF_PTRDIFF_T)
-#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
-#endif
-#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
-#if !defined(LZO_SIZEOF_SHORT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (USHRT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
-#    define LZO_SIZEOF_SHORT        1
-#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
-#    define LZO_SIZEOF_SHORT        4
-#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
-#    define LZO_SIZEOF_SHORT        16
-#  else
-#    error "LZO_SIZEOF_SHORT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_INT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_INT          8
-#  elif (UINT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_INT          2
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,7) == 1)
-#    define LZO_SIZEOF_INT          1
-#  elif (__LZO_LSR(UINT_MAX,15) == 1)
-#    define LZO_SIZEOF_INT          2
-#  elif (__LZO_LSR(UINT_MAX,31) == 1)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,63) == 1)
-#    define LZO_SIZEOF_INT          8
-#  elif (__LZO_LSR(UINT_MAX,127) == 1)
-#    define LZO_SIZEOF_INT          16
-#  else
-#    error "LZO_SIZEOF_INT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG)
-#  if (ULONG_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
-#    define LZO_SIZEOF_LONG         1
-#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
-#    define LZO_SIZEOF_LONG         2
-#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
-#    define LZO_SIZEOF_LONG         8
-#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
-#    define LZO_SIZEOF_LONG         16
-#  else
-#    error "LZO_SIZEOF_LONG"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
-#    if (LZO_CC_GNUC >= 0x030300ul)
-#      if ((__LONG_MAX__)+0 == (__LONG_LONG_MAX__)+0)
-#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
-#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
-#        define LZO_SIZEOF_LONG_LONG      4
-#      endif
-#    endif
-#  endif
-#endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#if (LZO_ARCH_I086 && LZO_CC_DMC)
-#elif (LZO_CC_CILLY) && defined(__GNUC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_OS_WIN64 || defined(_WIN64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && (_INTEGRAL_MAX_BITS == 64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
-#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define LZO_SIZEOF_LONG_LONG      8
-#endif
-#endif
-#endif
-#if defined(__cplusplus) && (LZO_CC_GNUC)
-#  if (LZO_CC_GNUC < 0x020800ul)
-#    undef LZO_SIZEOF_LONG_LONG
-#  endif
-#endif
-#if (LZO_CFG_NO_LONG_LONG) || defined(__NO_LONG_LONG)
-#  undef LZO_SIZEOF_LONG_LONG
-#endif
-#if !defined(LZO_SIZEOF_VOID_P)
-#if (LZO_ARCH_I086)
-#  define __LZO_WORDSIZE            2
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
-#    define LZO_SIZEOF_VOID_P       2
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    error "LZO_MM"
-#  endif
-#elif (LZO_ARCH_AVR || LZO_ARCH_Z80)
-#  define __LZO_WORDSIZE            1
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_H8300)
-#  if defined(__NORMAL_MODE__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       2
-#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define __LZO_WORDSIZE          2
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
-#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
-#  endif
-#elif (LZO_ARCH_M16C)
-#  define __LZO_WORDSIZE            2
-#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         4
-#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_OS_OS400 || defined(__OS400__))
-#  define __LZO_WORDSIZE            LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_VOID_P         16
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_VOID_P         8
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_ARCH_SPU)
-# if 0
-#  define __LZO_WORDSIZE            16
-# endif
-#  define LZO_SIZEOF_VOID_P         4
-#else
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#endif
-#endif
-#if !defined(LZO_WORDSIZE)
-#  if defined(__LZO_WORDSIZE)
-#    define LZO_WORDSIZE            __LZO_WORDSIZE
-#  else
-#    define LZO_WORDSIZE            LZO_SIZEOF_VOID_P
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_SIZE_T)
-#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
-#  define LZO_SIZEOF_SIZE_T         2
-#else
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
-#endif
-#endif
-#if !defined(LZO_SIZEOF_PTRDIFF_T)
-#if (LZO_ARCH_I086)
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
-#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
-#      define LZO_SIZEOF_PTRDIFF_T  4
-#    else
-#      define LZO_SIZEOF_PTRDIFF_T  2
-#    endif
-#  else
-#    error "LZO_MM"
-#  endif
-#else
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
-#endif
-#endif
-#if (LZO_ABI_NEUTRAL_ENDIAN)
-#  undef LZO_ABI_BIG_ENDIAN
-#  undef LZO_ABI_LITTLE_ENDIAN
-#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
-#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
-#  if (__LITTLE_ENDIAN__ == 1)
-#    define LZO_ABI_LITTLE_ENDIAN   1
-#  else
-#    define LZO_ABI_BIG_ENDIAN      1
-#  endif
-#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#endif
-#endif
-#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
-#  error "this should not happen"
-#endif
-#if (LZO_ABI_BIG_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "be"
-#elif (LZO_ABI_LITTLE_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "le"
-#elif (LZO_ABI_NEUTRAL_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "neutral"
-#endif
-#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_I8LP16         1
-#  define LZO_INFO_ABI_PM       "i8lp16"
-#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_ILP16         1
-#  define LZO_INFO_ABI_PM       "ilp16"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_ILP32         1
-#  define LZO_INFO_ABI_PM       "ilp32"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
-#  define LZO_ABI_LLP64         1
-#  define LZO_INFO_ABI_PM       "llp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_LP64          1
-#  define LZO_INFO_ABI_PM       "lp64"
-#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_ILP64         1
-#  define LZO_INFO_ABI_PM       "ilp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_IP32L64       1
-#  define LZO_INFO_ABI_PM       "ip32l64"
-#endif
-#if !defined(__LZO_LIBC_OVERRIDE)
-#if (LZO_LIBC_NAKED)
-#  define LZO_INFO_LIBC         "naked"
-#elif (LZO_LIBC_FREESTANDING)
-#  define LZO_INFO_LIBC         "freestanding"
-#elif (LZO_LIBC_MOSTLY_FREESTANDING)
-#  define LZO_INFO_LIBC         "mfreestanding"
-#elif (LZO_LIBC_ISOC90)
-#  define LZO_INFO_LIBC         "isoc90"
-#elif (LZO_LIBC_ISOC99)
-#  define LZO_INFO_LIBC         "isoc99"
-#elif defined(__dietlibc__)
-#  define LZO_LIBC_DIETLIBC     1
-#  define LZO_INFO_LIBC         "dietlibc"
-#elif defined(_NEWLIB_VERSION)
-#  define LZO_LIBC_NEWLIB       1
-#  define LZO_INFO_LIBC         "newlib"
-#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
-#  if defined(__UCLIBC_SUBLEVEL__)
-#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + __UCLIBC_MINOR__ * 0x100 + __UCLIBC_SUBLEVEL__)
-#  else
-#    define LZO_LIBC_UCLIBC     0x00090bL
-#  endif
-#  define LZO_INFO_LIBC         "uclibc"
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + __GLIBC_MINOR__ * 0x100)
-#  define LZO_INFO_LIBC         "glibc"
-#elif (LZO_CC_MWERKS) && defined(__MSL__)
-#  define LZO_LIBC_MSL          __MSL__
-#  define LZO_INFO_LIBC         "msl"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_LIBC_ISOC90       1
-#  define LZO_INFO_LIBC         "isoc90"
-#else
-#  define LZO_LIBC_DEFAULT      1
-#  define LZO_INFO_LIBC         "default"
-#endif
-#endif
-#if !defined(__lzo_gnuc_extension__)
-#if (LZO_CC_GNUC >= 0x020800ul)
-#  define __lzo_gnuc_extension__    __extension__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_gnuc_extension__    __extension__
-#else
-#  define __lzo_gnuc_extension__    /*empty*/
-#endif
-#endif
-#if !defined(__lzo_ua_volatile)
-#  define __lzo_ua_volatile     volatile
-#endif
-#if !defined(__lzo_alignof)
-#if (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_alignof(e)      __alignof(e)
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_alignof(e)      __alignof__(e)
-#endif
-#endif
-#if defined(__lzo_alignof)
-#  define __lzo_HAVE_alignof 1
-#endif
-#if !defined(__lzo_constructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_constructor     __attribute__((__constructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#endif
-#endif
-#if defined(__lzo_constructor)
-#  define __lzo_HAVE_constructor 1
-#endif
-#if !defined(__lzo_destructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_destructor      __attribute__((__destructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#endif
-#endif
-#if defined(__lzo_destructor)
-#  define __lzo_HAVE_destructor 1
-#endif
-#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_inline)
-#if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
-#elif defined(__cplusplus)
-#  define __lzo_inline          inline
-#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_inline          __inline__
-#elif (LZO_CC_DMC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_INTELC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MSC && (_MSC_VER >= 900))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_inline          __inline__
-#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define __lzo_inline          inline
-#endif
-#endif
-#if defined(__lzo_inline)
-#  define __lzo_HAVE_inline 1
-#else
-#  define __lzo_inline          /*empty*/
-#endif
-#if !defined(__lzo_forceinline)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#endif
-#endif
-#if defined(__lzo_forceinline)
-#  define __lzo_HAVE_forceinline 1
-#else
-#  define __lzo_forceinline     /*empty*/
-#endif
-#if !defined(__lzo_noinline)
-#if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
-#  define __lzo_noinline        __attribute__((__noinline__,__used__))
-#elif (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x3200) && (LZO_OS_WIN32 || LZO_OS_WIN64))
-#  if defined(__cplusplus)
-#  else
-#    define __lzo_noinline      __declspec(noinline)
-#  endif
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_noinline        __attribute__((__noinline__))
-#endif
-#endif
-#if defined(__lzo_noinline)
-#  define __lzo_HAVE_noinline 1
-#else
-#  define __lzo_noinline        /*empty*/
-#endif
-#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_noreturn)
-#if (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noreturn        __declspec(noreturn)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_noreturn        __declspec(noreturn)
-#endif
-#endif
-#if defined(__lzo_noreturn)
-#  define __lzo_HAVE_noreturn 1
-#else
-#  define __lzo_noreturn        /*empty*/
-#endif
-#if !defined(__lzo_nothrow)
-#if (LZO_CC_GNUC >= 0x030300ul)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 900) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#endif
-#endif
-#if defined(__lzo_nothrow)
-#  define __lzo_HAVE_nothrow 1
-#else
-#  define __lzo_nothrow         /*empty*/
-#endif
-#if !defined(__lzo_restrict)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define __lzo_restrict        __restrict
-#endif
-#endif
-#if defined(__lzo_restrict)
-#  define __lzo_HAVE_restrict 1
-#else
-#  define __lzo_restrict        /*empty*/
-#endif
-#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#endif
-#endif
-#if defined(__lzo_likely)
-#  define __lzo_HAVE_likely 1
-#else
-#  define __lzo_likely(e)       (e)
-#endif
-#if defined(__lzo_unlikely)
-#  define __lzo_HAVE_unlikely 1
-#else
-#  define __lzo_unlikely(e)     (e)
-#endif
-#if !defined(LZO_UNUSED)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED(var)         ((void) &var)
-#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNUSED(var)         ((void) var)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_KEILC)
-#    define LZO_UNUSED(var)         {extern int __lzo_unused[1-2*!(sizeof(var)>0)];}
-#  elif (LZO_CC_PACIFICC)
-#    define LZO_UNUSED(var)         ((void) sizeof(var))
-#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED(var)         ((void) var)
-#  else
-#    define LZO_UNUSED(var)         ((void) &var)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_FUNC)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_MSC)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
-#    define LZO_UNUSED_FUNC(func)   {extern int __lzo_unused[1-2*!(sizeof((int)func)>0)];}
-#  else
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_LABEL)
-#  if (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  elif (LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
-#    define LZO_UNUSED_LABEL(l)     if (0) goto l
-#  else
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  endif
-#endif
-#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
-#  if 0
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
-#  elif 0 && (LZO_CC_GNUC)
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
-#  else
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
-#  endif
-#endif
-#if !defined(LZO_UNCONST_CAST)
-#  if 0 && defined(__cplusplus)
-#    define LZO_UNCONST_CAST(t,e)   (const_cast<t> (e))
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((lzo_uintptr_t) ((const void *) (e))))))
-#  else
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((const void *) (e)))))
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
-#  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1u-2*!(e)];
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  else
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-2*!(e)];
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT)
-#  if (LZO_CC_AZTECC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-!(e)];}
-#  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  else
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-2*!(e)];}
-#  endif
-#endif
-#if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          /*empty*/
-#    define __lzo_cdecl_main            __cdecl
-#    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#      define __lzo_cdecl_qsort         __pascal
-#    elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#      define __lzo_cdecl_qsort         _stdcall
-#    else
-#      define __lzo_cdecl_qsort         __cdecl
-#    endif
-#  elif (LZO_CC_WATCOMC)
-#    define __lzo_cdecl                 __cdecl
-#  else
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          __cdecl
-#    define __lzo_cdecl_main            __cdecl
-#    define __lzo_cdecl_qsort           __cdecl
-#  endif
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC || LZO_CC_WATCOMC)
-#  elif (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#    define __lzo_cdecl_sighandler      __pascal
-#  elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#    define __lzo_cdecl_sighandler      _stdcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 1400)) && defined(_M_CEE_PURE)
-#    define __lzo_cdecl_sighandler      __clrcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 600 && _MSC_VER < 700))
-#    if defined(_DLL)
-#      define __lzo_cdecl_sighandler    _far _cdecl _loadds
-#    elif defined(_MT)
-#      define __lzo_cdecl_sighandler    _far _cdecl
-#    else
-#      define __lzo_cdecl_sighandler    _cdecl
-#    endif
-#  else
-#    define __lzo_cdecl_sighandler      __cdecl
-#  endif
-#elif (LZO_ARCH_I386) && (LZO_CC_WATCOMC)
-#  define __lzo_cdecl                   __cdecl
-#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
-#  define __lzo_cdecl                   cdecl
-#endif
-#if !defined(__lzo_cdecl)
-#  define __lzo_cdecl                   /*empty*/
-#endif
-#if !defined(__lzo_cdecl_atexit)
-#  define __lzo_cdecl_atexit            /*empty*/
-#endif
-#if !defined(__lzo_cdecl_main)
-#  define __lzo_cdecl_main              /*empty*/
-#endif
-#if !defined(__lzo_cdecl_qsort)
-#  define __lzo_cdecl_qsort             /*empty*/
-#endif
-#if !defined(__lzo_cdecl_sighandler)
-#  define __lzo_cdecl_sighandler        /*empty*/
-#endif
-#if !defined(__lzo_cdecl_va)
-#  define __lzo_cdecl_va                __lzo_cdecl
-#endif
-#if !(LZO_CFG_NO_WINDOWS_H)
-#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
-#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
-#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
-#  else
-#    define LZO_HAVE_WINDOWS_H 1
-#  endif
-#endif
-#endif
-#if (LZO_ARCH_ALPHA)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_AMD64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  define LZO_OPT_UNALIGNED64       1
-#elif (LZO_ARCH_ARM && LZO_ARCH_ARM_THUMB)
-#elif (LZO_ARCH_ARM)
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_CRIS)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_I386)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_IA64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_PREFER_POSTINC    1
-#elif (LZO_ARCH_M68K)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(__mc68020__) && !defined(__mcoldfire__)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_MIPS)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#elif (LZO_ARCH_POWERPC)
-#  define LZO_OPT_PREFER_PREINC     1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if (LZO_ABI_BIG_ENDIAN)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_S390)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  if (LZO_SIZEOF_SIZE_T == 8)
-#    define LZO_OPT_UNALIGNED64     1
-#  endif
-#elif (LZO_ARCH_SH)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#endif
-#ifndef LZO_CFG_NO_INLINE_ASM
-#if (LZO_CC_LLVM)
-#  define LZO_CFG_NO_INLINE_ASM 1
-#endif
-#endif
-#ifndef LZO_CFG_NO_UNALIGNED
-#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
-#  define LZO_CFG_NO_UNALIGNED 1
-#endif
-#endif
-#if (LZO_CFG_NO_UNALIGNED)
-#  undef LZO_OPT_UNALIGNED16
-#  undef LZO_OPT_UNALIGNED32
-#  undef LZO_OPT_UNALIGNED64
-#endif
-#if (LZO_CFG_NO_INLINE_ASM)
-#elif (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#  define LZO_ASM_SYNTAX_MSC 1
-#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
-#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#endif
-#if (LZO_ASM_SYNTAX_GNUC)
-#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
-#  define __LZO_ASM_CLOBBER         "ax"
-#elif (LZO_CC_INTELC)
-#  define __LZO_ASM_CLOBBER         "memory"
-#else
-#  define __LZO_ASM_CLOBBER         "cc", "memory"
-#endif
-#endif
-#if defined(__LZO_INFOSTR_MM)
-#elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
-#  define __LZO_INFOSTR_MM          ""
-#elif defined(LZO_INFO_MM)
-#  define __LZO_INFOSTR_MM          "." LZO_INFO_MM
-#else
-#  define __LZO_INFOSTR_MM          ""
-#endif
-#if defined(__LZO_INFOSTR_PM)
-#elif defined(LZO_INFO_ABI_PM)
-#  define __LZO_INFOSTR_PM          "." LZO_INFO_ABI_PM
-#else
-#  define __LZO_INFOSTR_PM          ""
-#endif
-#if defined(__LZO_INFOSTR_ENDIAN)
-#elif defined(LZO_INFO_ABI_ENDIAN)
-#  define __LZO_INFOSTR_ENDIAN      "." LZO_INFO_ABI_ENDIAN
-#else
-#  define __LZO_INFOSTR_ENDIAN      ""
-#endif
-#if defined(__LZO_INFOSTR_OSNAME)
-#elif defined(LZO_INFO_OS_CONSOLE)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_CONSOLE
-#elif defined(LZO_INFO_OS_POSIX)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_POSIX
-#else
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS
-#endif
-#if defined(__LZO_INFOSTR_LIBC)
-#elif defined(LZO_INFO_LIBC)
-#  define __LZO_INFOSTR_LIBC        "." LZO_INFO_LIBC
-#else
-#  define __LZO_INFOSTR_LIBC        ""
-#endif
-#if defined(__LZO_INFOSTR_CCVER)
-#elif defined(LZO_INFO_CCVER)
-#  define __LZO_INFOSTR_CCVER       " " LZO_INFO_CCVER
-#else
-#  define __LZO_INFOSTR_CCVER       ""
-#endif
-#define LZO_INFO_STRING \
-    LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
-    " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
-
-#endif /* already included */
-
-/* vim:set ts=4 et: */
diff --git a/libvncserver/main.c b/libvncserver/main.c
deleted file mode 100644
index b47e873..0000000
--- a/libvncserver/main.c
+++ /dev/null
@@ -1,1178 +0,0 @@
-/*
- *  This file is called main.c, because it contains most of the new functions
- *  for use with LibVNCServer.
- *
- *  LibVNCServer (C) 2001 Johannes E. Schindelin <Johannes.Schindelin@gmx.de>
- *  Original OSXvnc (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  see GPL (latest version) for full details
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#endif
-#include "rfb/rfb.h"
-#include "rfb/rfbregion.h"
-#include "private.h"
-
-#include <stdarg.h>
-#include <errno.h>
-
-#ifndef false
-#define false 0
-#define true -1
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#ifndef WIN32
-#include <sys/socket.h>
-#include <sys/time.h>
-#include <netinet/in.h>
-#include <unistd.h>
-#endif
-
-#include <signal.h>
-#include <time.h>
-
-static int extMutex_initialized = 0;
-static int logMutex_initialized = 0;
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-static MUTEX(logMutex);
-static MUTEX(extMutex);
-#endif
-
-static int rfbEnableLogging=1;
-
-#ifdef LIBVNCSERVER_WORDS_BIGENDIAN
-char rfbEndianTest = (1==0);
-#else
-char rfbEndianTest = (1==1);
-#endif
-
-/*
- * Protocol extensions
- */
-
-static rfbProtocolExtension* rfbExtensionHead = NULL;
-
-/*
- * This method registers a list of new extensions.  
- * It avoids same extension getting registered multiple times. 
- * The order is not preserved if multiple extensions are
- * registered at one-go.
- */
-void
-rfbRegisterProtocolExtension(rfbProtocolExtension* extension)
-{
-	rfbProtocolExtension *head = rfbExtensionHead, *next = NULL;
-
-	if(extension == NULL)
-		return;
-
-	next = extension->next;
-
-	if (! extMutex_initialized) {
-		INIT_MUTEX(extMutex);
-		extMutex_initialized = 1;
-	}
-
-	LOCK(extMutex);
-
-	while(head != NULL) {
-		if(head == extension) {
-			UNLOCK(extMutex);
-			rfbRegisterProtocolExtension(next);
-			return;
-		}
-
-		head = head->next;
-	}
-
-	extension->next = rfbExtensionHead;
-	rfbExtensionHead = extension;
-
-	UNLOCK(extMutex);
-	rfbRegisterProtocolExtension(next);
-}
-
-/*
- * This method unregisters a list of extensions.  
- * These extensions won't be available for any new
- * client connection. 
- */
-void
-rfbUnregisterProtocolExtension(rfbProtocolExtension* extension)
-{
-
-	rfbProtocolExtension *cur = NULL, *pre = NULL;
-
-	if(extension == NULL)
-		return;
-
-	if (! extMutex_initialized) {
-		INIT_MUTEX(extMutex);
-		extMutex_initialized = 1;
-	}
-
-	LOCK(extMutex);
-
-	if(rfbExtensionHead == extension) {
-		rfbExtensionHead = rfbExtensionHead->next;
-		UNLOCK(extMutex);
-		rfbUnregisterProtocolExtension(extension->next);
-		return;
-	}
-
-	cur = pre = rfbExtensionHead;
-
-	while(cur) {
-		if(cur == extension) {
-			pre->next = cur->next;
-			break;
-		}
-		pre = cur;
-		cur = cur->next;
-	}
-
-	UNLOCK(extMutex);
-
-	rfbUnregisterProtocolExtension(extension->next);
-}
-
-rfbProtocolExtension* rfbGetExtensionIterator()
-{
-	if (! extMutex_initialized) {
-		INIT_MUTEX(extMutex);
-		extMutex_initialized = 1;
-	}
-
-	LOCK(extMutex);
-	return rfbExtensionHead;
-}
-
-void rfbReleaseExtensionIterator()
-{
-	UNLOCK(extMutex);
-}
-
-rfbBool rfbEnableExtension(rfbClientPtr cl, rfbProtocolExtension* extension,
-	void* data)
-{
-	rfbExtensionData* extData;
-
-	/* make sure extension is not yet enabled. */
-	for(extData = cl->extensions; extData; extData = extData->next)
-		if(extData->extension == extension)
-			return FALSE;
-
-	extData = calloc(sizeof(rfbExtensionData),1);
-	extData->extension = extension;
-	extData->data = data;
-	extData->next = cl->extensions;
-	cl->extensions = extData;
-
-	return TRUE;
-}
-
-rfbBool rfbDisableExtension(rfbClientPtr cl, rfbProtocolExtension* extension)
-{
-	rfbExtensionData* extData;
-	rfbExtensionData* prevData = NULL;
-
-	for(extData = cl->extensions; extData; extData = extData->next) {
-		if(extData->extension == extension) {
-			if(extData->data)
-				free(extData->data);
-			if(prevData == NULL)
-				cl->extensions = extData->next;
-			else
-				prevData->next = extData->next;
-			return TRUE;
-		}
-		prevData = extData;
-	}
-
-	return FALSE;
-}
-
-void* rfbGetExtensionClientData(rfbClientPtr cl, rfbProtocolExtension* extension)
-{
-    rfbExtensionData* data = cl->extensions;
-
-    while(data && data->extension != extension)
-	data = data->next;
-
-    if(data == NULL) {
-	rfbLog("Extension is not enabled !\n");
-	/* rfbCloseClient(cl); */
-	return NULL;
-    }
-
-    return data->data;
-}
-
-/*
- * Logging
- */
-
-void rfbLogEnable(int enabled) {
-  rfbEnableLogging=enabled;
-}
-
-/*
- * rfbLog prints a time-stamped message to the log file (stderr).
- */
-
-static void
-rfbDefaultLog(const char *format, ...)
-{
-    va_list args;
-    char buf[256];
-    time_t log_clock;
-
-    if(!rfbEnableLogging)
-      return;
-
-    if (! logMutex_initialized) {
-      INIT_MUTEX(logMutex);
-      logMutex_initialized = 1;
-    }
-
-    LOCK(logMutex);
-    va_start(args, format);
-
-    time(&log_clock);
-    strftime(buf, 255, "%d/%m/%Y %X ", localtime(&log_clock));
-    fprintf(stderr, "%s", buf);
-
-    vfprintf(stderr, format, args);
-    fflush(stderr);
-
-    va_end(args);
-    UNLOCK(logMutex);
-}
-
-rfbLogProc rfbLog=rfbDefaultLog;
-rfbLogProc rfbErr=rfbDefaultLog;
-
-void rfbLogPerror(const char *str)
-{
-    rfbErr("%s: %s\n", str, strerror(errno));
-}
-
-void rfbScheduleCopyRegion(rfbScreenInfoPtr rfbScreen,sraRegionPtr copyRegion,int dx,int dy)
-{  
-   rfbClientIteratorPtr iterator;
-   rfbClientPtr cl;
-
-   iterator=rfbGetClientIterator(rfbScreen);
-   while((cl=rfbClientIteratorNext(iterator))) {
-     LOCK(cl->updateMutex);
-     if(cl->useCopyRect) {
-       sraRegionPtr modifiedRegionBackup;
-       if(!sraRgnEmpty(cl->copyRegion)) {
-	  if(cl->copyDX!=dx || cl->copyDY!=dy) {
-	     /* if a copyRegion was not yet executed, treat it as a
-	      * modifiedRegion. The idea: in this case it could be
-	      * source of the new copyRect or modified anyway. */
-	     sraRgnOr(cl->modifiedRegion,cl->copyRegion);
-	     sraRgnMakeEmpty(cl->copyRegion);
-	  } else {
-	     /* we have to set the intersection of the source of the copy
-	      * and the old copy to modified. */
-	     modifiedRegionBackup=sraRgnCreateRgn(copyRegion);
-	     sraRgnOffset(modifiedRegionBackup,-dx,-dy);
-	     sraRgnAnd(modifiedRegionBackup,cl->copyRegion);
-	     sraRgnOr(cl->modifiedRegion,modifiedRegionBackup);
-	     sraRgnDestroy(modifiedRegionBackup);
-	  }
-       }
-	  
-       sraRgnOr(cl->copyRegion,copyRegion);
-       cl->copyDX = dx;
-       cl->copyDY = dy;
-
-       /* if there were modified regions, which are now copied,
-	* mark them as modified, because the source of these can be overlapped
-	* either by new modified or now copied regions. */
-       modifiedRegionBackup=sraRgnCreateRgn(cl->modifiedRegion);
-       sraRgnOffset(modifiedRegionBackup,dx,dy);
-       sraRgnAnd(modifiedRegionBackup,cl->copyRegion);
-       sraRgnOr(cl->modifiedRegion,modifiedRegionBackup);
-       sraRgnDestroy(modifiedRegionBackup);
-
-       if(!cl->enableCursorShapeUpdates) {
-          /*
-           * n.b. (dx, dy) is the vector pointing in the direction the
-           * copyrect displacement will take place.  copyRegion is the
-           * destination rectangle (say), not the source rectangle.
-           */
-          sraRegionPtr cursorRegion;
-          int x = cl->cursorX - cl->screen->cursor->xhot;
-          int y = cl->cursorY - cl->screen->cursor->yhot;
-          int w = cl->screen->cursor->width;
-          int h = cl->screen->cursor->height;
-
-          cursorRegion = sraRgnCreateRect(x, y, x + w, y + h);
-          sraRgnAnd(cursorRegion, cl->copyRegion);
-          if(!sraRgnEmpty(cursorRegion)) {
-             /*
-              * current cursor rect overlaps with the copy region *dest*,
-              * mark it as modified since we won't copy-rect stuff to it.
-              */
-             sraRgnOr(cl->modifiedRegion, cursorRegion);
-          }
-          sraRgnDestroy(cursorRegion);
-
-          cursorRegion = sraRgnCreateRect(x, y, x + w, y + h);
-          /* displace it to check for overlap with copy region source: */
-          sraRgnOffset(cursorRegion, dx, dy);
-          sraRgnAnd(cursorRegion, cl->copyRegion);
-          if(!sraRgnEmpty(cursorRegion)) {
-             /*
-              * current cursor rect overlaps with the copy region *source*,
-              * mark the *displaced* cursorRegion as modified since we
-              * won't copyrect stuff to it.
-              */
-             sraRgnOr(cl->modifiedRegion, cursorRegion);
-          }
-          sraRgnDestroy(cursorRegion);
-       }
-
-     } else {
-       sraRgnOr(cl->modifiedRegion,copyRegion);
-     }
-     TSIGNAL(cl->updateCond);
-     UNLOCK(cl->updateMutex);
-   }
-
-   rfbReleaseClientIterator(iterator);
-}
-
-void rfbDoCopyRegion(rfbScreenInfoPtr screen,sraRegionPtr copyRegion,int dx,int dy)
-{
-   sraRectangleIterator* i;
-   sraRect rect;
-   int j,widthInBytes,bpp=screen->serverFormat.bitsPerPixel/8,
-    rowstride=screen->paddedWidthInBytes;
-   char *in,*out;
-
-   /* copy it, really */
-   i = sraRgnGetReverseIterator(copyRegion,dx<0,dy<0);
-   while(sraRgnIteratorNext(i,&rect)) {
-     widthInBytes = (rect.x2-rect.x1)*bpp;
-     out = screen->frameBuffer+rect.x1*bpp+rect.y1*rowstride;
-     in = screen->frameBuffer+(rect.x1-dx)*bpp+(rect.y1-dy)*rowstride;
-     if(dy<0)
-       for(j=rect.y1;j<rect.y2;j++,out+=rowstride,in+=rowstride)
-	 memmove(out,in,widthInBytes);
-     else {
-       out += rowstride*(rect.y2-rect.y1-1);
-       in += rowstride*(rect.y2-rect.y1-1);
-       for(j=rect.y2-1;j>=rect.y1;j--,out-=rowstride,in-=rowstride)
-	 memmove(out,in,widthInBytes);
-     }
-   }
-   sraRgnReleaseIterator(i);
-  
-   rfbScheduleCopyRegion(screen,copyRegion,dx,dy);
-}
-
-void rfbDoCopyRect(rfbScreenInfoPtr screen,int x1,int y1,int x2,int y2,int dx,int dy)
-{
-  sraRegionPtr region = sraRgnCreateRect(x1,y1,x2,y2);
-  rfbDoCopyRegion(screen,region,dx,dy);
-  sraRgnDestroy(region);
-}
-
-void rfbScheduleCopyRect(rfbScreenInfoPtr screen,int x1,int y1,int x2,int y2,int dx,int dy)
-{
-  sraRegionPtr region = sraRgnCreateRect(x1,y1,x2,y2);
-  rfbScheduleCopyRegion(screen,region,dx,dy);
-  sraRgnDestroy(region);
-}
-
-void rfbMarkRegionAsModified(rfbScreenInfoPtr screen,sraRegionPtr modRegion)
-{
-   rfbClientIteratorPtr iterator;
-   rfbClientPtr cl;
-
-   iterator=rfbGetClientIterator(screen);
-   while((cl=rfbClientIteratorNext(iterator))) {
-     LOCK(cl->updateMutex);
-     sraRgnOr(cl->modifiedRegion,modRegion);
-     TSIGNAL(cl->updateCond);
-     UNLOCK(cl->updateMutex);
-   }
-
-   rfbReleaseClientIterator(iterator);
-}
-
-void rfbScaledScreenUpdate(rfbScreenInfoPtr screen, int x1, int y1, int x2, int y2);
-void rfbMarkRectAsModified(rfbScreenInfoPtr screen,int x1,int y1,int x2,int y2)
-{
-   sraRegionPtr region;
-   int i;
-
-   if(x1>x2) { i=x1; x1=x2; x2=i; }
-   if(x1<0) x1=0;
-   if(x2>screen->width) x2=screen->width;
-   if(x1==x2) return;
-   
-   if(y1>y2) { i=y1; y1=y2; y2=i; }
-   if(y1<0) y1=0;
-   if(y2>screen->height) y2=screen->height;
-   if(y1==y2) return;
-
-   /* update scaled copies for this rectangle */
-   rfbScaledScreenUpdate(screen,x1,y1,x2,y2);
-
-   region = sraRgnCreateRect(x1,y1,x2,y2);
-   rfbMarkRegionAsModified(screen,region);
-   sraRgnDestroy(region);
-}
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-#include <unistd.h>
-
-static void *
-clientOutput(void *data)
-{
-    rfbClientPtr cl = (rfbClientPtr)data;
-    rfbBool haveUpdate;
-    sraRegion* updateRegion;
-
-    while (1) {
-        haveUpdate = false;
-        while (!haveUpdate) {
-		if (cl->sock == -1) {
-			/* Client has disconnected. */
-			return NULL;
-		}
-		if (cl->state != RFB_NORMAL || cl->onHold) {
-			/* just sleep until things get normal */
-			usleep(cl->screen->deferUpdateTime * 1000);
-			continue;
-		}
-
-		LOCK(cl->updateMutex);
-
-		if (sraRgnEmpty(cl->requestedRegion)) {
-			; /* always require a FB Update Request (otherwise can crash.) */
-		} else {
-			haveUpdate = FB_UPDATE_PENDING(cl);
-			if(!haveUpdate) {
-				updateRegion = sraRgnCreateRgn(cl->modifiedRegion);
-				haveUpdate   = sraRgnAnd(updateRegion,cl->requestedRegion);
-				sraRgnDestroy(updateRegion);
-			}
-		}
-
-		if (!haveUpdate) {
-			WAIT(cl->updateCond, cl->updateMutex);
-		}
-
-		UNLOCK(cl->updateMutex);
-        }
-        
-        /* OK, now, to save bandwidth, wait a little while for more
-           updates to come along. */
-        usleep(cl->screen->deferUpdateTime * 1000);
-
-        /* Now, get the region we're going to update, and remove
-           it from cl->modifiedRegion _before_ we send the update.
-           That way, if anything that overlaps the region we're sending
-           is updated, we'll be sure to do another update later. */
-        LOCK(cl->updateMutex);
-	updateRegion = sraRgnCreateRgn(cl->modifiedRegion);
-        UNLOCK(cl->updateMutex);
-
-        /* Now actually send the update. */
-	rfbIncrClientRef(cl);
-        LOCK(cl->sendMutex);
-        rfbSendFramebufferUpdate(cl, updateRegion);
-        UNLOCK(cl->sendMutex);
-	rfbDecrClientRef(cl);
-
-	sraRgnDestroy(updateRegion);
-    }
-
-    /* Not reached. */
-    return NULL;
-}
-
-static void *
-clientInput(void *data)
-{
-    rfbClientPtr cl = (rfbClientPtr)data;
-    pthread_t output_thread;
-    pthread_create(&output_thread, NULL, clientOutput, (void *)cl);
-
-    while (1) {
-	fd_set rfds, wfds, efds;
-	struct timeval tv;
-	int n;
-
-	if (cl->sock == -1) {
-	  /* Client has disconnected. */
-            break;
-        }
-
-	FD_ZERO(&rfds);
-	FD_SET(cl->sock, &rfds);
-	FD_ZERO(&efds);
-	FD_SET(cl->sock, &efds);
-
-	/* Are we transferring a file in the background? */
-	FD_ZERO(&wfds);
-	if ((cl->fileTransfer.fd!=-1) && (cl->fileTransfer.sending==1))
-	    FD_SET(cl->sock, &wfds);
-
-	tv.tv_sec = 60; /* 1 minute */
-	tv.tv_usec = 0;
-	n = select(cl->sock + 1, &rfds, &wfds, &efds, &tv);
-	if (n < 0) {
-	    rfbLogPerror("ReadExact: select");
-	    break;
-	}
-	if (n == 0) /* timeout */
-	{
-            rfbSendFileTransferChunk(cl);
-	    continue;
-        }
-        
-        /* We have some space on the transmit queue, send some data */
-        if (FD_ISSET(cl->sock, &wfds))
-            rfbSendFileTransferChunk(cl);
-
-        if (FD_ISSET(cl->sock, &rfds) || FD_ISSET(cl->sock, &efds))
-            rfbProcessClientMessage(cl);
-    }
-
-    /* Get rid of the output thread. */
-    LOCK(cl->updateMutex);
-    TSIGNAL(cl->updateCond);
-    UNLOCK(cl->updateMutex);
-    IF_PTHREADS(pthread_join(output_thread, NULL));
-
-    rfbClientConnectionGone(cl);
-
-    return NULL;
-}
-
-static void*
-listenerRun(void *data)
-{
-    rfbScreenInfoPtr screen=(rfbScreenInfoPtr)data;
-    int client_fd;
-    struct sockaddr_in peer;
-    rfbClientPtr cl;
-    socklen_t len;
-
-    len = sizeof(peer);
-
-    /* TODO: this thread wont die by restarting the server */
-    /* TODO: HTTP is not handled */
-    while ((client_fd = accept(screen->listenSock, 
-                               (struct sockaddr*)&peer, &len)) >= 0) {
-        cl = rfbNewClient(screen,client_fd);
-        len = sizeof(peer);
-
-	if (cl && !cl->onHold )
-		rfbStartOnHoldClient(cl);
-    }
-    return(NULL);
-}
-
-void 
-rfbStartOnHoldClient(rfbClientPtr cl)
-{
-    pthread_create(&cl->client_thread, NULL, clientInput, (void *)cl);
-}
-
-#else
-
-void 
-rfbStartOnHoldClient(rfbClientPtr cl)
-{
-	cl->onHold = FALSE;
-}
-
-#endif
-
-void 
-rfbRefuseOnHoldClient(rfbClientPtr cl)
-{
-    rfbCloseClient(cl);
-    rfbClientConnectionGone(cl);
-}
-
-static void
-rfbDefaultKbdAddEvent(rfbBool down, rfbKeySym keySym, rfbClientPtr cl)
-{
-}
-
-void
-rfbDefaultPtrAddEvent(int buttonMask, int x, int y, rfbClientPtr cl)
-{
-  rfbClientIteratorPtr iterator;
-  rfbClientPtr other_client;
-  rfbScreenInfoPtr s = cl->screen;
-
-  if (x != s->cursorX || y != s->cursorY) {
-    LOCK(s->cursorMutex);
-    s->cursorX = x;
-    s->cursorY = y;
-    UNLOCK(s->cursorMutex);
-
-    /* The cursor was moved by this client, so don't send CursorPos. */
-    if (cl->enableCursorPosUpdates)
-      cl->cursorWasMoved = FALSE;
-
-    /* But inform all remaining clients about this cursor movement. */
-    iterator = rfbGetClientIterator(s);
-    while ((other_client = rfbClientIteratorNext(iterator)) != NULL) {
-      if (other_client != cl && other_client->enableCursorPosUpdates) {
-	other_client->cursorWasMoved = TRUE;
-      }
-    }
-    rfbReleaseClientIterator(iterator);
-  }
-}
-
-static void rfbDefaultSetXCutText(char* text, int len, rfbClientPtr cl)
-{
-}
-
-/* TODO: add a nice VNC or RFB cursor */
-
-#if defined(WIN32) || defined(sparc) || !defined(NO_STRICT_ANSI)
-static rfbCursor myCursor = 
-{
-   FALSE, FALSE, FALSE, FALSE,
-   (unsigned char*)"\000\102\044\030\044\102\000",
-   (unsigned char*)"\347\347\176\074\176\347\347",
-   8, 7, 3, 3,
-   0, 0, 0,
-   0xffff, 0xffff, 0xffff,
-   NULL
-};
-#else
-static rfbCursor myCursor = 
-{
-   cleanup: FALSE,
-   cleanupSource: FALSE,
-   cleanupMask: FALSE,
-   cleanupRichSource: FALSE,
-   source: "\000\102\044\030\044\102\000",
-   mask:   "\347\347\176\074\176\347\347",
-   width: 8, height: 7, xhot: 3, yhot: 3,
-   foreRed: 0, foreGreen: 0, foreBlue: 0,
-   backRed: 0xffff, backGreen: 0xffff, backBlue: 0xffff,
-   richSource: NULL
-};
-#endif
-
-static rfbCursorPtr rfbDefaultGetCursorPtr(rfbClientPtr cl)
-{
-   return(cl->screen->cursor);
-}
-
-/* response is cl->authChallenge vncEncrypted with passwd */
-static rfbBool rfbDefaultPasswordCheck(rfbClientPtr cl,const char* response,int len)
-{
-  int i;
-  char *passwd=rfbDecryptPasswdFromFile(cl->screen->authPasswdData);
-
-  if(!passwd) {
-    rfbErr("Couldn't read password file: %s\n",cl->screen->authPasswdData);
-    return(FALSE);
-  }
-
-  rfbEncryptBytes(cl->authChallenge, passwd);
-
-  /* Lose the password from memory */
-  for (i = strlen(passwd); i >= 0; i--) {
-    passwd[i] = '\0';
-  }
-
-  free(passwd);
-
-  if (memcmp(cl->authChallenge, response, len) != 0) {
-    rfbErr("authProcessClientMessage: authentication failed from %s\n",
-	   cl->host);
-    return(FALSE);
-  }
-
-  return(TRUE);
-}
-
-/* for this method, authPasswdData is really a pointer to an array
-   of char*'s, where the last pointer is 0. */
-rfbBool rfbCheckPasswordByList(rfbClientPtr cl,const char* response,int len)
-{
-  char **passwds;
-  int i=0;
-
-  for(passwds=(char**)cl->screen->authPasswdData;*passwds;passwds++,i++) {
-    uint8_t auth_tmp[CHALLENGESIZE];
-    memcpy((char *)auth_tmp, (char *)cl->authChallenge, CHALLENGESIZE);
-    rfbEncryptBytes(auth_tmp, *passwds);
-
-    if (memcmp(auth_tmp, response, len) == 0) {
-      if(i>=cl->screen->authPasswdFirstViewOnly)
-	cl->viewOnly=TRUE;
-      return(TRUE);
-    }
-  }
-
-  rfbErr("authProcessClientMessage: authentication failed from %s\n",
-	 cl->host);
-  return(FALSE);
-}
-
-void rfbDoNothingWithClient(rfbClientPtr cl)
-{
-}
-
-static enum rfbNewClientAction rfbDefaultNewClientHook(rfbClientPtr cl)
-{
-	return RFB_CLIENT_ACCEPT;
-}
-
-/*
- * Update server's pixel format in screenInfo structure. This
- * function is called from rfbGetScreen() and rfbNewFramebuffer().
- */
-
-static void rfbInitServerFormat(rfbScreenInfoPtr screen, int bitsPerSample)
-{
-   rfbPixelFormat* format=&screen->serverFormat;
-
-   format->bitsPerPixel = screen->bitsPerPixel;
-   format->depth = screen->depth;
-   format->bigEndian = rfbEndianTest?FALSE:TRUE;
-   format->trueColour = TRUE;
-   screen->colourMap.count = 0;
-   screen->colourMap.is16 = 0;
-   screen->colourMap.data.bytes = NULL;
-
-   if (format->bitsPerPixel == 8) {
-     format->redMax = 7;
-     format->greenMax = 7;
-     format->blueMax = 3;
-     format->redShift = 0;
-     format->greenShift = 3;
-     format->blueShift = 6;
-   } else {
-     format->redMax = (1 << bitsPerSample) - 1;
-     format->greenMax = (1 << bitsPerSample) - 1;
-     format->blueMax = (1 << bitsPerSample) - 1;
-     if(rfbEndianTest) {
-       format->redShift = 0;
-       format->greenShift = bitsPerSample;
-       format->blueShift = bitsPerSample * 2;
-     } else {
-       if(format->bitsPerPixel==8*3) {
-	 format->redShift = bitsPerSample*2;
-	 format->greenShift = bitsPerSample*1;
-	 format->blueShift = 0;
-       } else {
-	 format->redShift = bitsPerSample*3;
-	 format->greenShift = bitsPerSample*2;
-	 format->blueShift = bitsPerSample;
-       }
-     }
-   }
-}
-
-rfbScreenInfoPtr rfbGetScreen(int* argc,char** argv,
- int width,int height,int bitsPerSample,int samplesPerPixel,
- int bytesPerPixel)
-{
-   rfbScreenInfoPtr screen=calloc(sizeof(rfbScreenInfo),1);
-
-   if (! logMutex_initialized) {
-     INIT_MUTEX(logMutex);
-     logMutex_initialized = 1;
-   }
-
-
-   if(width&3)
-     rfbErr("WARNING: Width (%d) is not a multiple of 4. VncViewer has problems with that.\n",width);
-
-   screen->autoPort=FALSE;
-   screen->clientHead=NULL;
-   screen->pointerClient=NULL;
-   screen->port=5900;
-   screen->socketState=RFB_SOCKET_INIT;
-
-   screen->inetdInitDone = FALSE;
-   screen->inetdSock=-1;
-
-   screen->udpSock=-1;
-   screen->udpSockConnected=FALSE;
-   screen->udpPort=0;
-   screen->udpClient=NULL;
-
-   screen->maxFd=0;
-   screen->listenSock=-1;
-
-   screen->httpInitDone=FALSE;
-   screen->httpEnableProxyConnect=FALSE;
-   screen->httpPort=0;
-   screen->httpDir=NULL;
-   screen->httpListenSock=-1;
-   screen->httpSock=-1;
-
-   screen->desktopName = "LibVNCServer";
-   screen->alwaysShared = FALSE;
-   screen->neverShared = FALSE;
-   screen->dontDisconnect = FALSE;
-   screen->authPasswdData = NULL;
-   screen->authPasswdFirstViewOnly = 1;
-   
-   screen->width = width;
-   screen->height = height;
-   screen->bitsPerPixel = screen->depth = 8*bytesPerPixel;
-
-   screen->passwordCheck = rfbDefaultPasswordCheck;
-
-   screen->ignoreSIGPIPE = TRUE;
-
-   /* disable progressive updating per default */
-   screen->progressiveSliceHeight = 0;
-
-   screen->listenInterface = htonl(INADDR_ANY);
-
-   screen->deferUpdateTime=5;
-   screen->maxRectsPerUpdate=50;
-
-   screen->handleEventsEagerly = FALSE;
-
-   screen->protocolMajorVersion = rfbProtocolMajorVersion;
-   screen->protocolMinorVersion = rfbProtocolMinorVersion;
-
-   screen->permitFileTransfer = FALSE;
-
-   if(!rfbProcessArguments(screen,argc,argv)) {
-     free(screen);
-     return NULL;
-   }
-
-#ifdef WIN32
-   {
-	   DWORD dummy=255;
-	   GetComputerName(screen->thisHost,&dummy);
-   }
-#else
-   gethostname(screen->thisHost, 255);
-#endif
-
-   screen->paddedWidthInBytes = width*bytesPerPixel;
-
-   /* format */
-
-   rfbInitServerFormat(screen, bitsPerSample);
-
-   /* cursor */
-
-   screen->cursorX=screen->cursorY=screen->underCursorBufferLen=0;
-   screen->underCursorBuffer=NULL;
-   screen->dontConvertRichCursorToXCursor = FALSE;
-   screen->cursor = &myCursor;
-   INIT_MUTEX(screen->cursorMutex);
-
-   IF_PTHREADS(screen->backgroundLoop = FALSE);
-
-   /* proc's and hook's */
-
-   screen->kbdAddEvent = rfbDefaultKbdAddEvent;
-   screen->kbdReleaseAllKeys = rfbDoNothingWithClient;
-   screen->ptrAddEvent = rfbDefaultPtrAddEvent;
-   screen->setXCutText = rfbDefaultSetXCutText;
-   screen->getCursorPtr = rfbDefaultGetCursorPtr;
-   screen->setTranslateFunction = rfbSetTranslateFunction;
-   screen->newClientHook = rfbDefaultNewClientHook;
-   screen->displayHook = NULL;
-   screen->displayFinishedHook = NULL;
-   screen->getKeyboardLedStateHook = NULL;
-   screen->xvpHook = NULL;
-
-   /* initialize client list and iterator mutex */
-   rfbClientListInit(screen);
-
-   return(screen);
-}
-
-/*
- * Switch to another framebuffer (maybe of different size and color
- * format). Clients supporting NewFBSize pseudo-encoding will change
- * their local framebuffer dimensions if necessary.
- * NOTE: Rich cursor data should be converted to new pixel format by
- * the caller.
- */
-
-void rfbNewFramebuffer(rfbScreenInfoPtr screen, char *framebuffer,
-                       int width, int height,
-                       int bitsPerSample, int samplesPerPixel,
-                       int bytesPerPixel)
-{
-  rfbPixelFormat old_format;
-  rfbBool format_changed = FALSE;
-  rfbClientIteratorPtr iterator;
-  rfbClientPtr cl;
-
-  /* Update information in the screenInfo structure */
-
-  old_format = screen->serverFormat;
-
-  if (width & 3)
-    rfbErr("WARNING: New width (%d) is not a multiple of 4.\n", width);
-
-  screen->width = width;
-  screen->height = height;
-  screen->bitsPerPixel = screen->depth = 8*bytesPerPixel;
-  screen->paddedWidthInBytes = width*bytesPerPixel;
-
-  rfbInitServerFormat(screen, bitsPerSample);
-
-  if (memcmp(&screen->serverFormat, &old_format,
-             sizeof(rfbPixelFormat)) != 0) {
-    format_changed = TRUE;
-  }
-
-  screen->frameBuffer = framebuffer;
-
-  /* Adjust pointer position if necessary */
-
-  if (screen->cursorX >= width)
-    screen->cursorX = width - 1;
-  if (screen->cursorY >= height)
-    screen->cursorY = height - 1;
-
-  /* For each client: */
-  iterator = rfbGetClientIterator(screen);
-  while ((cl = rfbClientIteratorNext(iterator)) != NULL) {
-
-    /* Re-install color translation tables if necessary */
-
-    if (format_changed)
-      screen->setTranslateFunction(cl);
-
-    /* Mark the screen contents as changed, and schedule sending
-       NewFBSize message if supported by this client. */
-
-    LOCK(cl->updateMutex);
-    sraRgnDestroy(cl->modifiedRegion);
-    cl->modifiedRegion = sraRgnCreateRect(0, 0, width, height);
-    sraRgnMakeEmpty(cl->copyRegion);
-    cl->copyDX = 0;
-    cl->copyDY = 0;
-
-    if (cl->useNewFBSize)
-      cl->newFBSizePending = TRUE;
-
-    TSIGNAL(cl->updateCond);
-    UNLOCK(cl->updateMutex);
-  }
-  rfbReleaseClientIterator(iterator);
-}
-
-/* hang up on all clients and free all reserved memory */
-
-void rfbScreenCleanup(rfbScreenInfoPtr screen)
-{
-  rfbClientIteratorPtr i=rfbGetClientIterator(screen);
-  rfbClientPtr cl,cl1=rfbClientIteratorNext(i);
-  while(cl1) {
-    cl=rfbClientIteratorNext(i);
-    rfbClientConnectionGone(cl1);
-    cl1=cl;
-  }
-  rfbReleaseClientIterator(i);
-    
-#define FREE_IF(x) if(screen->x) free(screen->x)
-  FREE_IF(colourMap.data.bytes);
-  FREE_IF(underCursorBuffer);
-  TINI_MUTEX(screen->cursorMutex);
-  if(screen->cursor && screen->cursor->cleanup)
-    rfbFreeCursor(screen->cursor);
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-  rfbZlibCleanup(screen);
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-  rfbTightCleanup(screen);
-#endif
-
-  /* free all 'scaled' versions of this screen */
-  while (screen->scaledScreenNext!=NULL)
-  {
-      rfbScreenInfoPtr ptr;
-      ptr = screen->scaledScreenNext;
-      screen->scaledScreenNext = ptr->scaledScreenNext;
-      free(ptr->frameBuffer);
-      free(ptr);
-  }
-
-#endif
-  free(screen);
-}
-
-void rfbInitServer(rfbScreenInfoPtr screen)
-{
-#ifdef WIN32
-  WSADATA trash;
-  WSAStartup(MAKEWORD(2,2),&trash);
-#endif
-  rfbInitSockets(screen);
-  rfbHttpInitSockets(screen);
-#ifndef __MINGW32__
-  if(screen->ignoreSIGPIPE)
-    signal(SIGPIPE,SIG_IGN);
-#endif
-}
-
-void rfbShutdownServer(rfbScreenInfoPtr screen,rfbBool disconnectClients) {
-  if(disconnectClients) {
-    rfbClientPtr cl;
-    rfbClientIteratorPtr iter = rfbGetClientIterator(screen);
-    while( (cl = rfbClientIteratorNext(iter)) )
-      if (cl->sock > -1)
-	/* we don't care about maxfd here, because the server goes away */
-	rfbCloseClient(cl);
-    rfbReleaseClientIterator(iter);
-  }
-
-  rfbShutdownSockets(screen);
-  rfbHttpShutdownSockets(screen);
-}
-
-#ifndef LIBVNCSERVER_HAVE_GETTIMEOFDAY
-#include <fcntl.h>
-#include <conio.h>
-#include <sys/timeb.h>
-
-void gettimeofday(struct timeval* tv,char* dummy)
-{
-   SYSTEMTIME t;
-   GetSystemTime(&t);
-   tv->tv_sec=t.wHour*3600+t.wMinute*60+t.wSecond;
-   tv->tv_usec=t.wMilliseconds*1000;
-}
-#endif
-
-rfbBool
-rfbProcessEvents(rfbScreenInfoPtr screen,long usec)
-{
-  rfbClientIteratorPtr i;
-  rfbClientPtr cl,clPrev;
-  rfbBool result=FALSE;
-  extern rfbClientIteratorPtr
-    rfbGetClientIteratorWithClosed(rfbScreenInfoPtr rfbScreen);
-
-  if(usec<0)
-    usec=screen->deferUpdateTime*1000;
-
-  rfbCheckFds(screen,usec);
-  rfbHttpCheckFds(screen);
-
-  i = rfbGetClientIteratorWithClosed(screen);
-  cl=rfbClientIteratorHead(i);
-  while(cl) {
-    result = rfbUpdateClient(cl);
-    clPrev=cl;
-    cl=rfbClientIteratorNext(i);
-    if(clPrev->sock==-1) {
-      rfbClientConnectionGone(clPrev);
-      result=TRUE;
-    }
-  }
-  rfbReleaseClientIterator(i);
-
-  return result;
-}
-
-rfbBool
-rfbUpdateClient(rfbClientPtr cl)
-{
-  struct timeval tv;
-  rfbBool result=FALSE;
-  rfbScreenInfoPtr screen = cl->screen;
-
-  if (cl->sock >= 0 && !cl->onHold && FB_UPDATE_PENDING(cl) &&
-        !sraRgnEmpty(cl->requestedRegion)) {
-      result=TRUE;
-      if(screen->deferUpdateTime == 0) {
-          rfbSendFramebufferUpdate(cl,cl->modifiedRegion);
-      } else if(cl->startDeferring.tv_usec == 0) {
-        gettimeofday(&cl->startDeferring,NULL);
-        if(cl->startDeferring.tv_usec == 0)
-          cl->startDeferring.tv_usec++;
-      } else {
-        gettimeofday(&tv,NULL);
-        if(tv.tv_sec < cl->startDeferring.tv_sec /* at midnight */
-           || ((tv.tv_sec-cl->startDeferring.tv_sec)*1000
-               +(tv.tv_usec-cl->startDeferring.tv_usec)/1000)
-             > screen->deferUpdateTime) {
-          cl->startDeferring.tv_usec = 0;
-          rfbSendFramebufferUpdate(cl,cl->modifiedRegion);
-        }
-      }
-    }
-
-    if (!cl->viewOnly && cl->lastPtrX >= 0) {
-      if(cl->startPtrDeferring.tv_usec == 0) {
-        gettimeofday(&cl->startPtrDeferring,NULL);
-        if(cl->startPtrDeferring.tv_usec == 0)
-          cl->startPtrDeferring.tv_usec++;
-      } else {
-        struct timeval tv;
-        gettimeofday(&tv,NULL);
-        if(tv.tv_sec < cl->startPtrDeferring.tv_sec /* at midnight */
-           || ((tv.tv_sec-cl->startPtrDeferring.tv_sec)*1000
-           +(tv.tv_usec-cl->startPtrDeferring.tv_usec)/1000)
-           > cl->screen->deferPtrUpdateTime) {
-          cl->startPtrDeferring.tv_usec = 0;
-          cl->screen->ptrAddEvent(cl->lastPtrButtons,
-                                  cl->lastPtrX,
-                                  cl->lastPtrY, cl);
-          cl->lastPtrX = -1;
-        }
-      }
-    }
-
-    return result;
-}
-
-rfbBool rfbIsActive(rfbScreenInfoPtr screenInfo) {
-  return screenInfo->socketState!=RFB_SOCKET_SHUTDOWN || screenInfo->clientHead!=NULL;
-}
-
-void rfbRunEventLoop(rfbScreenInfoPtr screen, long usec, rfbBool runInBackground)
-{
-  if(runInBackground) {
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-       pthread_t listener_thread;
-
-       screen->backgroundLoop = TRUE;
-
-       pthread_create(&listener_thread, NULL, listenerRun, screen);
-    return;
-#else
-    rfbErr("Can't run in background, because I don't have PThreads!\n");
-    return;
-#endif
-  }
-
-  if(usec<0)
-    usec=screen->deferUpdateTime*1000;
-
-  while(rfbIsActive(screen))
-    rfbProcessEvents(screen,usec);
-}
diff --git a/libvncserver/minilzo.c b/libvncserver/minilzo.c
deleted file mode 100644
index 6ae8d73..0000000
--- a/libvncserver/minilzo.c
+++ /dev/null
@@ -1,4192 +0,0 @@
-/* minilzo.c -- mini subset of the LZO real-time data compression library
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-/*
- * NOTE:
- *   the full LZO package can be found at
- *   http://www.oberhumer.com/opensource/lzo/
- */
-
-#define __LZO_IN_MINILZO 1
-
-#if defined(LZO_CFG_FREESTANDING)
-#  undef MINILZO_HAVE_CONFIG_H
-#  define LZO_LIBC_FREESTANDING 1
-#  define LZO_OS_FREESTANDING 1
-#endif
-
-#ifdef MINILZO_HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <limits.h>
-#include <stddef.h>
-#if defined(MINILZO_CFG_USE_INTERNAL_LZODEFS)
-
-#ifndef __LZODEFS_H_INCLUDED
-#define __LZODEFS_H_INCLUDED 1
-
-#if defined(__CYGWIN32__) && !defined(__CYGWIN__)
-#  define __CYGWIN__ __CYGWIN32__
-#endif
-#if defined(__IBMCPP__) && !defined(__IBMC__)
-#  define __IBMC__ __IBMCPP__
-#endif
-#if defined(__ICL) && defined(_WIN32) && !defined(__INTEL_COMPILER)
-#  define __INTEL_COMPILER __ICL
-#endif
-#if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
-#  define _ALL_SOURCE 1
-#endif
-#if defined(__mips__) && defined(__R5900__)
-#  if !defined(__LONG_MAX__)
-#    define __LONG_MAX__ 9223372036854775807L
-#  endif
-#endif
-#if defined(__INTEL_COMPILER) && defined(__linux__)
-#  pragma warning(disable: 193)
-#endif
-#if defined(__KEIL__) && defined(__C166__)
-#  pragma warning disable = 322
-#elif 0 && defined(__C251__)
-#  pragma warning disable = 322
-#endif
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
-#  if (_MSC_VER >= 1300)
-#    pragma warning(disable: 4668)
-#  endif
-#endif
-#if 0 && defined(__WATCOMC__)
-#  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
-#    pragma warning 203 9
-#  endif
-#endif
-#if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
-#  pragma option -h
-#endif
-#if 0
-#define LZO_0xffffL             0xfffful
-#define LZO_0xffffffffL         0xfffffffful
-#else
-#define LZO_0xffffL             65535ul
-#define LZO_0xffffffffL         4294967295ul
-#endif
-#if (LZO_0xffffL == LZO_0xffffffffL)
-#  error "your preprocessor is broken 1"
-#endif
-#if (16ul * 16384ul != 262144ul)
-#  error "your preprocessor is broken 2"
-#endif
-#if 0
-#if (32767 >= 4294967295ul)
-#  error "your preprocessor is broken 3"
-#endif
-#if (65535u >= 4294967295ul)
-#  error "your preprocessor is broken 4"
-#endif
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
-#  if !defined(MSDOS)
-#    define MSDOS 1
-#  endif
-#  if !defined(_MSDOS)
-#    define _MSDOS 1
-#  endif
-#elif 0 && defined(__VERSION) && defined(MB_LEN_MAX)
-#  if (__VERSION == 520) && (MB_LEN_MAX == 1)
-#    if !defined(__AZTEC_C__)
-#      define __AZTEC_C__ __VERSION
-#    endif
-#    if !defined(__DOS__)
-#      define __DOS__ 1
-#    endif
-#  endif
-#endif
-#endif
-#if defined(_MSC_VER) && defined(M_I86HM) && (UINT_MAX == LZO_0xffffL)
-#  define ptrdiff_t long
-#  define _PTRDIFF_T_DEFINED 1
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#  if defined(__AZTEC_C__) && defined(__DOS__)
-#    define __LZO_RENAME_A 1
-#  elif defined(_MSC_VER) && defined(MSDOS)
-#    if (_MSC_VER < 600)
-#      define __LZO_RENAME_A 1
-#    elif (_MSC_VER < 700)
-#      define __LZO_RENAME_B 1
-#    endif
-#  elif defined(__TSC__) && defined(__OS2__)
-#    define __LZO_RENAME_A 1
-#  elif defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0410)
-#    define __LZO_RENAME_A 1
-#  elif defined(__PACIFIC__) && defined(DOS)
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#  endif
-#  if defined(__LZO_RENAME_A)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#  elif defined(__LZO_RENAME_B)
-#    if !defined(__cdecl)
-#      define __cdecl _cdecl
-#    endif
-#    if !defined(__far)
-#      define __far _far
-#    endif
-#    if !defined(__huge)
-#      define __huge _huge
-#    endif
-#    if !defined(__near)
-#      define __near _near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal _pascal
-#    endif
-#  elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#  endif
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__AZTEC_C__) && defined(__DOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#elif defined(_MSC_VER) && defined(MSDOS)
-#  if (_MSC_VER < 600)
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#  endif
-#  if (_MSC_VER < 700)
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#elif defined(__PACIFIC__) && defined(DOS)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#elif defined(__TURBOC__) && defined(__MSDOS__)
-#  if (__TURBOC__ < 0x0150)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#  endif
-#  if (__TURBOC__ < 0x0200)
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#  if (__TURBOC__ < 0x0400) && defined(__cplusplus)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  endif
-#elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  define LZO_BROKEN_SIZEOF 1
-#endif
-#endif
-#if defined(__WATCOMC__) && (__WATCOMC__ < 900)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#endif
-#if defined(_CRAY) && defined(_CRAY1)
-#  define LZO_BROKEN_SIGNED_RIGHT_SHIFT 1
-#endif
-#define LZO_PP_STRINGIZE(x)             #x
-#define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
-#define LZO_PP_CONCAT2(a,b)             a ## b
-#define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
-#define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
-#define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
-#define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
-#define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
-#define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
-#define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
-#if 1
-#define LZO_CPP_STRINGIZE(x)            #x
-#define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
-#define LZO_CPP_CONCAT2(a,b)            a ## b
-#define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
-#define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
-#define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
-#define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
-#define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
-#define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
-#define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
-#endif
-#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-1)) - (o)) << 1) + (o))
-#if 1 && defined(__cplusplus)
-#  if !defined(__STDC_CONSTANT_MACROS)
-#    define __STDC_CONSTANT_MACROS 1
-#  endif
-#  if !defined(__STDC_LIMIT_MACROS)
-#    define __STDC_LIMIT_MACROS 1
-#  endif
-#endif
-#if defined(__cplusplus)
-#  define LZO_EXTERN_C extern "C"
-#else
-#  define LZO_EXTERN_C extern
-#endif
-#if !defined(__LZO_OS_OVERRIDE)
-#if (LZO_OS_FREESTANDING)
-#  define LZO_INFO_OS           "freestanding"
-#elif (LZO_OS_EMBEDDED)
-#  define LZO_INFO_OS           "embedded"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_OS_EMBEDDED       1
-#  define LZO_INFO_OS           "embedded"
-#elif defined(__CYGWIN__) && defined(__GNUC__)
-#  define LZO_OS_CYGWIN         1
-#  define LZO_INFO_OS           "cygwin"
-#elif defined(__EMX__) && defined(__GNUC__)
-#  define LZO_OS_EMX            1
-#  define LZO_INFO_OS           "emx"
-#elif defined(__BEOS__)
-#  define LZO_OS_BEOS           1
-#  define LZO_INFO_OS           "beos"
-#elif defined(__Lynx__)
-#  define LZO_OS_LYNXOS         1
-#  define LZO_INFO_OS           "lynxos"
-#elif defined(__OS400__)
-#  define LZO_OS_OS400          1
-#  define LZO_INFO_OS           "os400"
-#elif defined(__QNX__)
-#  define LZO_OS_QNX            1
-#  define LZO_INFO_OS           "qnx"
-#elif defined(__BORLANDC__) && defined(__DPMI32__) && (__BORLANDC__ >= 0x0460)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__BORLANDC__) && defined(__DPMI16__)
-#  define LZO_OS_DOS16          1
-#  define LZO_INFO_OS           "dos16"
-#elif defined(__ZTC__) && defined(DOS386)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__OS2__) || defined(__OS2V2__)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_OS216        1
-#    define LZO_INFO_OS         "os216"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_OS2          1
-#    define LZO_INFO_OS         "os2"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WIN64__) || defined(_WIN64) || defined(WIN64)
-#  define LZO_OS_WIN64          1
-#  define LZO_INFO_OS           "win64"
-#elif defined(__WIN32__) || defined(_WIN32) || defined(WIN32) || defined(__WINDOWS_386__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__MWERKS__) && defined(__INTEL__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__WINDOWS__) || defined(_WINDOWS) || defined(_Windows)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_WIN16        1
-#    define LZO_INFO_OS         "win16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__DOS__) || defined(__MSDOS__) || defined(_MSDOS) || defined(MSDOS) || (defined(__PACIFIC__) && defined(DOS))
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_DOS32        1
-#    define LZO_INFO_OS         "dos32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WATCOMC__)
-#  if defined(__NT__) && (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif defined(__NT__) && (__WATCOMC__ < 1100)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  elif defined(__linux__) || defined(__LINUX__)
-#    define LZO_OS_POSIX        1
-#    define LZO_INFO_OS         "posix"
-#  else
-#    error "please specify a target using the -bt compiler option"
-#  endif
-#elif defined(__palmos__)
-#  define LZO_OS_PALMOS         1
-#  define LZO_INFO_OS           "palmos"
-#elif defined(__TOS__) || defined(__atarist__)
-#  define LZO_OS_TOS            1
-#  define LZO_INFO_OS           "tos"
-#elif defined(macintosh) && !defined(__ppc__)
-#  define LZO_OS_MACCLASSIC     1
-#  define LZO_INFO_OS           "macclassic"
-#elif defined(__VMS)
-#  define LZO_OS_VMS            1
-#  define LZO_INFO_OS           "vms"
-#elif ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PS2    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "ps2"
-#elif (defined(__mips__) && defined(__psp__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PSP    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "psp"
-#else
-#  define LZO_OS_POSIX          1
-#  define LZO_INFO_OS           "posix"
-#endif
-#if (LZO_OS_POSIX)
-#  if defined(_AIX) || defined(__AIX__) || defined(__aix__)
-#    define LZO_OS_POSIX_AIX        1
-#    define LZO_INFO_OS_POSIX       "aix"
-#  elif defined(__FreeBSD__)
-#    define LZO_OS_POSIX_FREEBSD    1
-#    define LZO_INFO_OS_POSIX       "freebsd"
-#  elif defined(__hpux__) || defined(__hpux)
-#    define LZO_OS_POSIX_HPUX       1
-#    define LZO_INFO_OS_POSIX       "hpux"
-#  elif defined(__INTERIX)
-#    define LZO_OS_POSIX_INTERIX    1
-#    define LZO_INFO_OS_POSIX       "interix"
-#  elif defined(__IRIX__) || defined(__irix__)
-#    define LZO_OS_POSIX_IRIX       1
-#    define LZO_INFO_OS_POSIX       "irix"
-#  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
-#    define LZO_OS_POSIX_LINUX      1
-#    define LZO_INFO_OS_POSIX       "linux"
-#  elif defined(__APPLE__) || defined(__MACOS__)
-#    define LZO_OS_POSIX_MACOSX     1
-#    define LZO_INFO_OS_POSIX       "macosx"
-#  elif defined(__minix__) || defined(__minix)
-#    define LZO_OS_POSIX_MINIX      1
-#    define LZO_INFO_OS_POSIX       "minix"
-#  elif defined(__NetBSD__)
-#    define LZO_OS_POSIX_NETBSD     1
-#    define LZO_INFO_OS_POSIX       "netbsd"
-#  elif defined(__OpenBSD__)
-#    define LZO_OS_POSIX_OPENBSD    1
-#    define LZO_INFO_OS_POSIX       "openbsd"
-#  elif defined(__osf__)
-#    define LZO_OS_POSIX_OSF        1
-#    define LZO_INFO_OS_POSIX       "osf"
-#  elif defined(__solaris__) || defined(__sun)
-#    if defined(__SVR4) || defined(__svr4__)
-#      define LZO_OS_POSIX_SOLARIS  1
-#      define LZO_INFO_OS_POSIX     "solaris"
-#    else
-#      define LZO_OS_POSIX_SUNOS    1
-#      define LZO_INFO_OS_POSIX     "sunos"
-#    endif
-#  elif defined(__ultrix__) || defined(__ultrix)
-#    define LZO_OS_POSIX_ULTRIX     1
-#    define LZO_INFO_OS_POSIX       "ultrix"
-#  elif defined(_UNICOS)
-#    define LZO_OS_POSIX_UNICOS     1
-#    define LZO_INFO_OS_POSIX       "unicos"
-#  else
-#    define LZO_OS_POSIX_UNKNOWN    1
-#    define LZO_INFO_OS_POSIX       "unknown"
-#  endif
-#endif
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (UINT_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
-#  define LZO_CC_CILLY          1
-#  define LZO_INFO_CC           "Cilly"
-#  if defined(__CILLY__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__CILLY__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif 0 && defined(SDCC) && defined(__VERSION__) && !defined(__GNUC__)
-#  define LZO_CC_SDCC           1
-#  define LZO_INFO_CC           "sdcc"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
-#elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
-#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + __PATHCC_MINOR__ * 0x100 + __PATHCC_PATCHLEVEL__)
-#  define LZO_INFO_CC           "Pathscale C"
-#  define LZO_INFO_CCVER        __PATHSCALE__
-#elif defined(__INTEL_COMPILER)
-#  define LZO_CC_INTELC         1
-#  define LZO_INFO_CC           "Intel C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
-#  if defined(_WIN32) || defined(_WIN64)
-#    define LZO_CC_SYNTAX_MSC 1
-#  else
-#    define LZO_CC_SYNTAX_GNUC 1
-#  endif
-#elif defined(__POCC__) && defined(_WIN32)
-#  define LZO_CC_PELLESC        1
-#  define LZO_INFO_CC           "Pelles C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
-#elif defined(__clang__) && defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
-#    define LZO_CC_CLANG_CLANG  (__clang_major__ * 0x10000L + __clang_minor__ * 0x100 + __clang_patchlevel__)
-#  else
-#    define LZO_CC_CLANG_CLANG  0x020700L
-#  endif
-#  define LZO_CC_CLANG          LZO_CC_CLANG_GNUC
-#  define LZO_INFO_CC           "clang"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
-#  define LZO_INFO_CC           "llvm-gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  elif defined(__GNUC_MINOR__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  else
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
-#  endif
-#  define LZO_INFO_CC           "gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__ACK__) && defined(_ACK)
-#  define LZO_CC_ACK            1
-#  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__AZTEC_C__)
-#  define LZO_CC_AZTECC         1
-#  define LZO_INFO_CC           "Aztec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
-#elif defined(__CODEGEARC__)
-#  define LZO_CC_CODEGEARC      1
-#  define LZO_INFO_CC           "CodeGear C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
-#elif defined(__BORLANDC__)
-#  define LZO_CC_BORLANDC       1
-#  define LZO_INFO_CC           "Borland C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__BORLANDC__)
-#elif defined(_CRAYC) && defined(_RELEASE)
-#  define LZO_CC_CRAYC          1
-#  define LZO_INFO_CC           "Cray C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(_RELEASE)
-#elif defined(__DMC__) && defined(__SC__)
-#  define LZO_CC_DMC            1
-#  define LZO_INFO_CC           "Digital Mars C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DMC__)
-#elif defined(__DECC)
-#  define LZO_CC_DECC           1
-#  define LZO_INFO_CC           "DEC C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
-#elif defined(__HIGHC__)
-#  define LZO_CC_HIGHC          1
-#  define LZO_INFO_CC           "MetaWare High C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_CC_IARC           1
-#  define LZO_INFO_CC           "IAR C"
-#  if defined(__VER__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__VER__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__IBMC__)
-#  define LZO_CC_IBMC           1
-#  define LZO_INFO_CC           "IBM C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
-#elif defined(__KEIL__) && defined(__C166__)
-#  define LZO_CC_KEILC          1
-#  define LZO_INFO_CC           "Keil C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__C166__)
-#elif defined(__LCC__) && defined(_WIN32) && defined(__LCCOPTIMLEVEL)
-#  define LZO_CC_LCCWIN32       1
-#  define LZO_INFO_CC           "lcc-win32"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__LCC__)
-#  define LZO_CC_LCC            1
-#  define LZO_INFO_CC           "lcc"
-#  if defined(__LCC_VERSION__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__LCC_VERSION__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(_MSC_VER)
-#  define LZO_CC_MSC            1
-#  define LZO_INFO_CC           "Microsoft C"
-#  if defined(_MSC_FULL_VER)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
-#  endif
-#elif defined(__MWERKS__)
-#  define LZO_CC_MWERKS         1
-#  define LZO_INFO_CC           "Metrowerks C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
-#elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
-#  define LZO_CC_NDPC           1
-#  define LZO_INFO_CC           "Microway NDP C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PACIFIC__)
-#  define LZO_CC_PACIFICC       1
-#  define LZO_INFO_CC           "Pacific C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
-#elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
-#  define LZO_CC_PGI            1
-#  define LZO_INFO_CC           "Portland Group PGI C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PUREC__) && defined(__TOS__)
-#  define LZO_CC_PUREC          1
-#  define LZO_INFO_CC           "Pure C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PUREC__)
-#elif defined(__SC__) && defined(__ZTC__)
-#  define LZO_CC_SYMANTECC      1
-#  define LZO_INFO_CC           "Symantec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
-#elif defined(__SUNPRO_C)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_C)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_C
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__SUNPRO_CC)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_CC)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_CC
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__TINYC__)
-#  define LZO_CC_TINYC          1
-#  define LZO_INFO_CC           "Tiny C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TINYC__)
-#elif defined(__TSC__)
-#  define LZO_CC_TOPSPEEDC      1
-#  define LZO_INFO_CC           "TopSpeed C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TSC__)
-#elif defined(__WATCOMC__)
-#  define LZO_CC_WATCOMC        1
-#  define LZO_INFO_CC           "Watcom C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__WATCOMC__)
-#elif defined(__TURBOC__)
-#  define LZO_CC_TURBOC         1
-#  define LZO_INFO_CC           "Turbo C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TURBOC__)
-#elif defined(__ZTC__)
-#  define LZO_CC_ZORTECHC       1
-#  define LZO_INFO_CC           "Zortech C"
-#  if (__ZTC__ == 0x310)
-#    define LZO_INFO_CCVER      "0x310"
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
-#  endif
-#else
-#  define LZO_CC_UNKNOWN        1
-#  define LZO_INFO_CC           "unknown"
-#  define LZO_INFO_CCVER        "unknown"
-#endif
-#if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
-#  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
-#  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
-#    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
-#      define LZO_ARCH_CRAY_MPP     1
-#    elif defined(_CRAY1)
-#      define LZO_ARCH_CRAY_PVP     1
-#    endif
-#  endif
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE)
-#if (LZO_ARCH_GENERIC)
-#  define LZO_INFO_ARCH             "generic"
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086             1
-#  define LZO_ARCH_IA16             1
-#  define LZO_INFO_ARCH             "i086"
-#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif (LZO_ARCH_CRAY_MPP) && (defined(_CRAYT3D) || defined(_CRAYT3E))
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif defined(__amd64__) || defined(__x86_64__) || defined(_M_AMD64)
-#  define LZO_ARCH_AMD64            1
-#  define LZO_INFO_ARCH             "amd64"
-#elif defined(__thumb__) || (defined(_M_ARM) && defined(_M_THUMB))
-#  define LZO_ARCH_ARM              1
-#  define LZO_ARCH_ARM_THUMB        1
-#  define LZO_INFO_ARCH             "arm_thumb"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
-#  define LZO_ARCH_ARM              1
-#  if defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 1)
-#    define LZO_ARCH_ARM_THUMB      1
-#    define LZO_INFO_ARCH           "arm_thumb"
-#  elif defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 2)
-#    define LZO_INFO_ARCH           "arm"
-#  else
-#    define LZO_INFO_ARCH           "arm"
-#  endif
-#elif defined(__arm__) || defined(_M_ARM)
-#  define LZO_ARCH_ARM              1
-#  define LZO_INFO_ARCH             "arm"
-#elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
-#  define LZO_ARCH_AVR              1
-#  define LZO_INFO_ARCH             "avr"
-#elif defined(__avr32__) || defined(__AVR32__)
-#  define LZO_ARCH_AVR32            1
-#  define LZO_INFO_ARCH             "avr32"
-#elif defined(__bfin__)
-#  define LZO_ARCH_BLACKFIN         1
-#  define LZO_INFO_ARCH             "blackfin"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C166__)
-#  define LZO_ARCH_C166             1
-#  define LZO_INFO_ARCH             "c166"
-#elif defined(__cris__)
-#  define LZO_ARCH_CRIS             1
-#  define LZO_INFO_ARCH             "cris"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCEZ80__)
-#  define LZO_ARCH_EZ80             1
-#  define LZO_INFO_ARCH             "ez80"
-#elif defined(__H8300__) || defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#  define LZO_ARCH_H8300            1
-#  define LZO_INFO_ARCH             "h8300"
-#elif defined(__hppa__) || defined(__hppa)
-#  define LZO_ARCH_HPPA             1
-#  define LZO_INFO_ARCH             "hppa"
-#elif defined(__386__) || defined(__i386__) || defined(__i386) || defined(_M_IX86) || defined(_M_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_CC_ZORTECHC && defined(__I86__))
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_OS_DOS32 && LZO_CC_HIGHC) && defined(_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif defined(__ia64__) || defined(__ia64) || defined(_M_IA64)
-#  define LZO_ARCH_IA64             1
-#  define LZO_INFO_ARCH             "ia64"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__m32c__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCM16C__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__m32r__)
-#  define LZO_ARCH_M32R             1
-#  define LZO_INFO_ARCH             "m32r"
-#elif (LZO_OS_TOS) || defined(__m68k__) || defined(__m68000__) || defined(__mc68000__) || defined(__mc68020__) || defined(_M_M68K)
-#  define LZO_ARCH_M68K             1
-#  define LZO_INFO_ARCH             "m68k"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C251__)
-#  define LZO_ARCH_MCS251           1
-#  define LZO_INFO_ARCH             "mcs251"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C51__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC8051__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__mips__) || defined(__mips) || defined(_MIPS_ARCH) || defined(_M_MRX000)
-#  define LZO_ARCH_MIPS             1
-#  define LZO_INFO_ARCH             "mips"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__MSP430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__powerpc__) || defined(__powerpc) || defined(__ppc__) || defined(__PPC__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PWR)
-#  define LZO_ARCH_POWERPC          1
-#  define LZO_INFO_ARCH             "powerpc"
-#elif defined(__s390__) || defined(__s390) || defined(__s390x__) || defined(__s390x)
-#  define LZO_ARCH_S390             1
-#  define LZO_INFO_ARCH             "s390"
-#elif defined(__sh__) || defined(_M_SH)
-#  define LZO_ARCH_SH               1
-#  define LZO_INFO_ARCH             "sh"
-#elif defined(__sparc__) || defined(__sparc) || defined(__sparcv8)
-#  define LZO_ARCH_SPARC            1
-#  define LZO_INFO_ARCH             "sparc"
-#elif defined(__SPU__)
-#  define LZO_ARCH_SPU              1
-#  define LZO_INFO_ARCH             "spu"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__z80)
-#  define LZO_ARCH_Z80              1
-#  define LZO_INFO_ARCH             "z80"
-#elif (LZO_ARCH_CRAY_PVP)
-#  if defined(_CRAYSV1)
-#    define LZO_ARCH_CRAY_SV1       1
-#    define LZO_INFO_ARCH           "cray_sv1"
-#  elif (_ADDR64)
-#    define LZO_ARCH_CRAY_T90       1
-#    define LZO_INFO_ARCH           "cray_t90"
-#  elif (_ADDR32)
-#    define LZO_ARCH_CRAY_YMP       1
-#    define LZO_INFO_ARCH           "cray_ymp"
-#  else
-#    define LZO_ARCH_CRAY_XMP       1
-#    define LZO_INFO_ARCH           "cray_xmp"
-#  endif
-#else
-#  define LZO_ARCH_UNKNOWN          1
-#  define LZO_INFO_ARCH             "unknown"
-#endif
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_DOS32 || LZO_OS_OS2)
-#  error "FIXME - missing define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
-#  error "FIXME - missing WIN32 define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
-#  error "FIXME - missing WIN64 define for CPU architecture"
-#endif
-#if (LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(BLX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#endif
-#if (LZO_ARCH_ARM_THUMB) && !(LZO_ARCH_ARM)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_ARCH_I086)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_ARCH_I386)
-#  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if !defined(__LZO_MM_OVERRIDE)
-#if (LZO_ARCH_I086)
-#if (UINT_MAX != LZO_0xffffL)
-#  error "this should not happen"
-#endif
-#if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
-#  define LZO_MM_TINY           1
-#elif defined(__HUGE__) || defined(_HUGE_) || defined(M_I86HM) || defined(_M_I86HM)
-#  define LZO_MM_HUGE           1
-#elif defined(__SMALL__) || defined(M_I86SM) || defined(_M_I86SM) || defined(SMALL_MODEL)
-#  define LZO_MM_SMALL          1
-#elif defined(__MEDIUM__) || defined(M_I86MM) || defined(_M_I86MM)
-#  define LZO_MM_MEDIUM         1
-#elif defined(__COMPACT__) || defined(M_I86CM) || defined(_M_I86CM)
-#  define LZO_MM_COMPACT        1
-#elif defined(__LARGE__) || defined(M_I86LM) || defined(_M_I86LM) || defined(LARGE_MODEL)
-#  define LZO_MM_LARGE          1
-#elif (LZO_CC_AZTECC)
-#  if defined(_LARGE_CODE) && defined(_LARGE_DATA)
-#    define LZO_MM_LARGE        1
-#  elif defined(_LARGE_CODE)
-#    define LZO_MM_MEDIUM       1
-#  elif defined(_LARGE_DATA)
-#    define LZO_MM_COMPACT      1
-#  else
-#    define LZO_MM_SMALL        1
-#  endif
-#elif (LZO_CC_ZORTECHC && defined(__VCM__))
-#  define LZO_MM_LARGE          1
-#else
-#  error "unknown memory model"
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#define LZO_HAVE_MM_HUGE_PTR        1
-#define LZO_HAVE_MM_HUGE_ARRAY      1
-#if (LZO_MM_TINY)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_ZORTECHC)
-#  undef LZO_HAVE_MM_HUGE_PTR
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_MSC && defined(_QC))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#  if (_MSC_VER < 600)
-#    undef LZO_HAVE_MM_HUGE_PTR
-#  endif
-#elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
-#  if (LZO_OS_DOS16)
-#    error "this should not happen"
-#  elif (LZO_CC_ZORTECHC)
-#  else
-#    error "this should not happen"
-#  endif
-#endif
-#ifdef __cplusplus
-extern "C" {
-#endif
-#if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0200))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_MSC || LZO_CC_TOPSPEEDC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_TURBOC && (__TURBOC__ >= 0x0295))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif ((LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_TURBOC) && LZO_OS_DOS16)
-#  define LZO_MM_AHSHIFT      12
-#elif (LZO_CC_WATCOMC)
-   extern unsigned char _HShift;
-#  define LZO_MM_AHSHIFT      ((unsigned) _HShift)
-#else
-#  error "FIXME - implement LZO_MM_AHSHIFT"
-#endif
-#ifdef __cplusplus
-}
-#endif
-#endif
-#elif (LZO_ARCH_C166)
-#if !defined(__MODEL__)
-#  error "FIXME - C166 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - C166 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS251)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS251 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS251 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS51)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS51 __MODEL__"
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS51 __MODEL__"
-#endif
-#elif (LZO_ARCH_CRAY_PVP)
-#  define LZO_MM_PVP            1
-#else
-#  define LZO_MM_FLAT           1
-#endif
-#if (LZO_MM_COMPACT)
-#  define LZO_INFO_MM           "compact"
-#elif (LZO_MM_FLAT)
-#  define LZO_INFO_MM           "flat"
-#elif (LZO_MM_HUGE)
-#  define LZO_INFO_MM           "huge"
-#elif (LZO_MM_LARGE)
-#  define LZO_INFO_MM           "large"
-#elif (LZO_MM_MEDIUM)
-#  define LZO_INFO_MM           "medium"
-#elif (LZO_MM_PVP)
-#  define LZO_INFO_MM           "pvp"
-#elif (LZO_MM_SMALL)
-#  define LZO_INFO_MM           "small"
-#elif (LZO_MM_TINY)
-#  define LZO_INFO_MM           "tiny"
-#else
-#  error "unknown memory model"
-#endif
-#endif
-#if defined(SIZEOF_SHORT)
-#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
-#endif
-#if defined(SIZEOF_INT)
-#  define LZO_SIZEOF_INT            (SIZEOF_INT)
-#endif
-#if defined(SIZEOF_LONG)
-#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
-#endif
-#if defined(SIZEOF_LONG_LONG)
-#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
-#endif
-#if defined(SIZEOF___INT16)
-#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
-#endif
-#if defined(SIZEOF___INT32)
-#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
-#endif
-#if defined(SIZEOF___INT64)
-#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
-#endif
-#if defined(SIZEOF_VOID_P)
-#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
-#endif
-#if defined(SIZEOF_SIZE_T)
-#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
-#endif
-#if defined(SIZEOF_PTRDIFF_T)
-#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
-#endif
-#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
-#if !defined(LZO_SIZEOF_SHORT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (USHRT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
-#    define LZO_SIZEOF_SHORT        1
-#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
-#    define LZO_SIZEOF_SHORT        4
-#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
-#    define LZO_SIZEOF_SHORT        16
-#  else
-#    error "LZO_SIZEOF_SHORT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_INT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_INT          8
-#  elif (UINT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_INT          2
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,7) == 1)
-#    define LZO_SIZEOF_INT          1
-#  elif (__LZO_LSR(UINT_MAX,15) == 1)
-#    define LZO_SIZEOF_INT          2
-#  elif (__LZO_LSR(UINT_MAX,31) == 1)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,63) == 1)
-#    define LZO_SIZEOF_INT          8
-#  elif (__LZO_LSR(UINT_MAX,127) == 1)
-#    define LZO_SIZEOF_INT          16
-#  else
-#    error "LZO_SIZEOF_INT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG)
-#  if (ULONG_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
-#    define LZO_SIZEOF_LONG         1
-#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
-#    define LZO_SIZEOF_LONG         2
-#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
-#    define LZO_SIZEOF_LONG         8
-#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
-#    define LZO_SIZEOF_LONG         16
-#  else
-#    error "LZO_SIZEOF_LONG"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
-#    if (LZO_CC_GNUC >= 0x030300ul)
-#      if ((__LONG_MAX__)+0 == (__LONG_LONG_MAX__)+0)
-#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
-#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
-#        define LZO_SIZEOF_LONG_LONG      4
-#      endif
-#    endif
-#  endif
-#endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#if (LZO_ARCH_I086 && LZO_CC_DMC)
-#elif (LZO_CC_CILLY) && defined(__GNUC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_OS_WIN64 || defined(_WIN64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && (_INTEGRAL_MAX_BITS == 64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
-#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define LZO_SIZEOF_LONG_LONG      8
-#endif
-#endif
-#endif
-#if defined(__cplusplus) && (LZO_CC_GNUC)
-#  if (LZO_CC_GNUC < 0x020800ul)
-#    undef LZO_SIZEOF_LONG_LONG
-#  endif
-#endif
-#if (LZO_CFG_NO_LONG_LONG) || defined(__NO_LONG_LONG)
-#  undef LZO_SIZEOF_LONG_LONG
-#endif
-#if !defined(LZO_SIZEOF_VOID_P)
-#if (LZO_ARCH_I086)
-#  define __LZO_WORDSIZE            2
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
-#    define LZO_SIZEOF_VOID_P       2
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    error "LZO_MM"
-#  endif
-#elif (LZO_ARCH_AVR || LZO_ARCH_Z80)
-#  define __LZO_WORDSIZE            1
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_H8300)
-#  if defined(__NORMAL_MODE__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       2
-#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define __LZO_WORDSIZE          2
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
-#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
-#  endif
-#elif (LZO_ARCH_M16C)
-#  define __LZO_WORDSIZE            2
-#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         4
-#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_OS_OS400 || defined(__OS400__))
-#  define __LZO_WORDSIZE            LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_VOID_P         16
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_VOID_P         8
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_ARCH_SPU)
-# if 0
-#  define __LZO_WORDSIZE            16
-# endif
-#  define LZO_SIZEOF_VOID_P         4
-#else
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#endif
-#endif
-#if !defined(LZO_WORDSIZE)
-#  if defined(__LZO_WORDSIZE)
-#    define LZO_WORDSIZE            __LZO_WORDSIZE
-#  else
-#    define LZO_WORDSIZE            LZO_SIZEOF_VOID_P
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_SIZE_T)
-#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
-#  define LZO_SIZEOF_SIZE_T         2
-#else
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
-#endif
-#endif
-#if !defined(LZO_SIZEOF_PTRDIFF_T)
-#if (LZO_ARCH_I086)
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
-#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
-#      define LZO_SIZEOF_PTRDIFF_T  4
-#    else
-#      define LZO_SIZEOF_PTRDIFF_T  2
-#    endif
-#  else
-#    error "LZO_MM"
-#  endif
-#else
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
-#endif
-#endif
-#if (LZO_ABI_NEUTRAL_ENDIAN)
-#  undef LZO_ABI_BIG_ENDIAN
-#  undef LZO_ABI_LITTLE_ENDIAN
-#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
-#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
-#  if (__LITTLE_ENDIAN__ == 1)
-#    define LZO_ABI_LITTLE_ENDIAN   1
-#  else
-#    define LZO_ABI_BIG_ENDIAN      1
-#  endif
-#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#endif
-#endif
-#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
-#  error "this should not happen"
-#endif
-#if (LZO_ABI_BIG_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "be"
-#elif (LZO_ABI_LITTLE_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "le"
-#elif (LZO_ABI_NEUTRAL_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "neutral"
-#endif
-#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_I8LP16         1
-#  define LZO_INFO_ABI_PM       "i8lp16"
-#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_ILP16         1
-#  define LZO_INFO_ABI_PM       "ilp16"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_ILP32         1
-#  define LZO_INFO_ABI_PM       "ilp32"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
-#  define LZO_ABI_LLP64         1
-#  define LZO_INFO_ABI_PM       "llp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_LP64          1
-#  define LZO_INFO_ABI_PM       "lp64"
-#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_ILP64         1
-#  define LZO_INFO_ABI_PM       "ilp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_IP32L64       1
-#  define LZO_INFO_ABI_PM       "ip32l64"
-#endif
-#if !defined(__LZO_LIBC_OVERRIDE)
-#if (LZO_LIBC_NAKED)
-#  define LZO_INFO_LIBC         "naked"
-#elif (LZO_LIBC_FREESTANDING)
-#  define LZO_INFO_LIBC         "freestanding"
-#elif (LZO_LIBC_MOSTLY_FREESTANDING)
-#  define LZO_INFO_LIBC         "mfreestanding"
-#elif (LZO_LIBC_ISOC90)
-#  define LZO_INFO_LIBC         "isoc90"
-#elif (LZO_LIBC_ISOC99)
-#  define LZO_INFO_LIBC         "isoc99"
-#elif defined(__dietlibc__)
-#  define LZO_LIBC_DIETLIBC     1
-#  define LZO_INFO_LIBC         "dietlibc"
-#elif defined(_NEWLIB_VERSION)
-#  define LZO_LIBC_NEWLIB       1
-#  define LZO_INFO_LIBC         "newlib"
-#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
-#  if defined(__UCLIBC_SUBLEVEL__)
-#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + __UCLIBC_MINOR__ * 0x100 + __UCLIBC_SUBLEVEL__)
-#  else
-#    define LZO_LIBC_UCLIBC     0x00090bL
-#  endif
-#  define LZO_INFO_LIBC         "uclibc"
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + __GLIBC_MINOR__ * 0x100)
-#  define LZO_INFO_LIBC         "glibc"
-#elif (LZO_CC_MWERKS) && defined(__MSL__)
-#  define LZO_LIBC_MSL          __MSL__
-#  define LZO_INFO_LIBC         "msl"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_LIBC_ISOC90       1
-#  define LZO_INFO_LIBC         "isoc90"
-#else
-#  define LZO_LIBC_DEFAULT      1
-#  define LZO_INFO_LIBC         "default"
-#endif
-#endif
-#if !defined(__lzo_gnuc_extension__)
-#if (LZO_CC_GNUC >= 0x020800ul)
-#  define __lzo_gnuc_extension__    __extension__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_gnuc_extension__    __extension__
-#else
-#  define __lzo_gnuc_extension__    /*empty*/
-#endif
-#endif
-#if !defined(__lzo_ua_volatile)
-#  define __lzo_ua_volatile     volatile
-#endif
-#if !defined(__lzo_alignof)
-#if (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_alignof(e)      __alignof(e)
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_alignof(e)      __alignof__(e)
-#endif
-#endif
-#if defined(__lzo_alignof)
-#  define __lzo_HAVE_alignof 1
-#endif
-#if !defined(__lzo_constructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_constructor     __attribute__((__constructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#endif
-#endif
-#if defined(__lzo_constructor)
-#  define __lzo_HAVE_constructor 1
-#endif
-#if !defined(__lzo_destructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_destructor      __attribute__((__destructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#endif
-#endif
-#if defined(__lzo_destructor)
-#  define __lzo_HAVE_destructor 1
-#endif
-#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_inline)
-#if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
-#elif defined(__cplusplus)
-#  define __lzo_inline          inline
-#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_inline          __inline__
-#elif (LZO_CC_DMC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_INTELC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MSC && (_MSC_VER >= 900))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_inline          __inline__
-#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define __lzo_inline          inline
-#endif
-#endif
-#if defined(__lzo_inline)
-#  define __lzo_HAVE_inline 1
-#else
-#  define __lzo_inline          /*empty*/
-#endif
-#if !defined(__lzo_forceinline)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#endif
-#endif
-#if defined(__lzo_forceinline)
-#  define __lzo_HAVE_forceinline 1
-#else
-#  define __lzo_forceinline     /*empty*/
-#endif
-#if !defined(__lzo_noinline)
-#if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
-#  define __lzo_noinline        __attribute__((__noinline__,__used__))
-#elif (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x3200) && (LZO_OS_WIN32 || LZO_OS_WIN64))
-#  if defined(__cplusplus)
-#  else
-#    define __lzo_noinline      __declspec(noinline)
-#  endif
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_noinline        __attribute__((__noinline__))
-#endif
-#endif
-#if defined(__lzo_noinline)
-#  define __lzo_HAVE_noinline 1
-#else
-#  define __lzo_noinline        /*empty*/
-#endif
-#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_noreturn)
-#if (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noreturn        __declspec(noreturn)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_noreturn        __declspec(noreturn)
-#endif
-#endif
-#if defined(__lzo_noreturn)
-#  define __lzo_HAVE_noreturn 1
-#else
-#  define __lzo_noreturn        /*empty*/
-#endif
-#if !defined(__lzo_nothrow)
-#if (LZO_CC_GNUC >= 0x030300ul)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 900) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#endif
-#endif
-#if defined(__lzo_nothrow)
-#  define __lzo_HAVE_nothrow 1
-#else
-#  define __lzo_nothrow         /*empty*/
-#endif
-#if !defined(__lzo_restrict)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define __lzo_restrict        __restrict
-#endif
-#endif
-#if defined(__lzo_restrict)
-#  define __lzo_HAVE_restrict 1
-#else
-#  define __lzo_restrict        /*empty*/
-#endif
-#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#endif
-#endif
-#if defined(__lzo_likely)
-#  define __lzo_HAVE_likely 1
-#else
-#  define __lzo_likely(e)       (e)
-#endif
-#if defined(__lzo_unlikely)
-#  define __lzo_HAVE_unlikely 1
-#else
-#  define __lzo_unlikely(e)     (e)
-#endif
-#if !defined(LZO_UNUSED)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED(var)         ((void) &var)
-#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNUSED(var)         ((void) var)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_KEILC)
-#    define LZO_UNUSED(var)         {extern int __lzo_unused[1-2*!(sizeof(var)>0)];}
-#  elif (LZO_CC_PACIFICC)
-#    define LZO_UNUSED(var)         ((void) sizeof(var))
-#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED(var)         ((void) var)
-#  else
-#    define LZO_UNUSED(var)         ((void) &var)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_FUNC)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_MSC)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
-#    define LZO_UNUSED_FUNC(func)   {extern int __lzo_unused[1-2*!(sizeof((int)func)>0)];}
-#  else
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_LABEL)
-#  if (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  elif (LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
-#    define LZO_UNUSED_LABEL(l)     if (0) goto l
-#  else
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  endif
-#endif
-#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
-#  if 0
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
-#  elif 0 && (LZO_CC_GNUC)
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
-#  else
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
-#  endif
-#endif
-#if !defined(LZO_UNCONST_CAST)
-#  if 0 && defined(__cplusplus)
-#    define LZO_UNCONST_CAST(t,e)   (const_cast<t> (e))
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((lzo_uintptr_t) ((const void *) (e))))))
-#  else
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((const void *) (e)))))
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
-#  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1u-2*!(e)];
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  else
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-2*!(e)];
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT)
-#  if (LZO_CC_AZTECC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-!(e)];}
-#  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  else
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-2*!(e)];}
-#  endif
-#endif
-#if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          /*empty*/
-#    define __lzo_cdecl_main            __cdecl
-#    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#      define __lzo_cdecl_qsort         __pascal
-#    elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#      define __lzo_cdecl_qsort         _stdcall
-#    else
-#      define __lzo_cdecl_qsort         __cdecl
-#    endif
-#  elif (LZO_CC_WATCOMC)
-#    define __lzo_cdecl                 __cdecl
-#  else
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          __cdecl
-#    define __lzo_cdecl_main            __cdecl
-#    define __lzo_cdecl_qsort           __cdecl
-#  endif
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC || LZO_CC_WATCOMC)
-#  elif (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#    define __lzo_cdecl_sighandler      __pascal
-#  elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#    define __lzo_cdecl_sighandler      _stdcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 1400)) && defined(_M_CEE_PURE)
-#    define __lzo_cdecl_sighandler      __clrcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 600 && _MSC_VER < 700))
-#    if defined(_DLL)
-#      define __lzo_cdecl_sighandler    _far _cdecl _loadds
-#    elif defined(_MT)
-#      define __lzo_cdecl_sighandler    _far _cdecl
-#    else
-#      define __lzo_cdecl_sighandler    _cdecl
-#    endif
-#  else
-#    define __lzo_cdecl_sighandler      __cdecl
-#  endif
-#elif (LZO_ARCH_I386) && (LZO_CC_WATCOMC)
-#  define __lzo_cdecl                   __cdecl
-#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
-#  define __lzo_cdecl                   cdecl
-#endif
-#if !defined(__lzo_cdecl)
-#  define __lzo_cdecl                   /*empty*/
-#endif
-#if !defined(__lzo_cdecl_atexit)
-#  define __lzo_cdecl_atexit            /*empty*/
-#endif
-#if !defined(__lzo_cdecl_main)
-#  define __lzo_cdecl_main              /*empty*/
-#endif
-#if !defined(__lzo_cdecl_qsort)
-#  define __lzo_cdecl_qsort             /*empty*/
-#endif
-#if !defined(__lzo_cdecl_sighandler)
-#  define __lzo_cdecl_sighandler        /*empty*/
-#endif
-#if !defined(__lzo_cdecl_va)
-#  define __lzo_cdecl_va                __lzo_cdecl
-#endif
-#if !(LZO_CFG_NO_WINDOWS_H)
-#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
-#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
-#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
-#  else
-#    define LZO_HAVE_WINDOWS_H 1
-#  endif
-#endif
-#endif
-#if (LZO_ARCH_ALPHA)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_AMD64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  define LZO_OPT_UNALIGNED64       1
-#elif (LZO_ARCH_ARM && LZO_ARCH_ARM_THUMB)
-#elif (LZO_ARCH_ARM)
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_CRIS)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_I386)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_IA64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_PREFER_POSTINC    1
-#elif (LZO_ARCH_M68K)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(__mc68020__) && !defined(__mcoldfire__)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_MIPS)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#elif (LZO_ARCH_POWERPC)
-#  define LZO_OPT_PREFER_PREINC     1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if (LZO_ABI_BIG_ENDIAN)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_S390)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  if (LZO_SIZEOF_SIZE_T == 8)
-#    define LZO_OPT_UNALIGNED64     1
-#  endif
-#elif (LZO_ARCH_SH)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#endif
-#ifndef LZO_CFG_NO_INLINE_ASM
-#if (LZO_CC_LLVM)
-#  define LZO_CFG_NO_INLINE_ASM 1
-#endif
-#endif
-#ifndef LZO_CFG_NO_UNALIGNED
-#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
-#  define LZO_CFG_NO_UNALIGNED 1
-#endif
-#endif
-#if (LZO_CFG_NO_UNALIGNED)
-#  undef LZO_OPT_UNALIGNED16
-#  undef LZO_OPT_UNALIGNED32
-#  undef LZO_OPT_UNALIGNED64
-#endif
-#if (LZO_CFG_NO_INLINE_ASM)
-#elif (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#  define LZO_ASM_SYNTAX_MSC 1
-#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
-#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#endif
-#if (LZO_ASM_SYNTAX_GNUC)
-#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
-#  define __LZO_ASM_CLOBBER         "ax"
-#elif (LZO_CC_INTELC)
-#  define __LZO_ASM_CLOBBER         "memory"
-#else
-#  define __LZO_ASM_CLOBBER         "cc", "memory"
-#endif
-#endif
-#if defined(__LZO_INFOSTR_MM)
-#elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
-#  define __LZO_INFOSTR_MM          ""
-#elif defined(LZO_INFO_MM)
-#  define __LZO_INFOSTR_MM          "." LZO_INFO_MM
-#else
-#  define __LZO_INFOSTR_MM          ""
-#endif
-#if defined(__LZO_INFOSTR_PM)
-#elif defined(LZO_INFO_ABI_PM)
-#  define __LZO_INFOSTR_PM          "." LZO_INFO_ABI_PM
-#else
-#  define __LZO_INFOSTR_PM          ""
-#endif
-#if defined(__LZO_INFOSTR_ENDIAN)
-#elif defined(LZO_INFO_ABI_ENDIAN)
-#  define __LZO_INFOSTR_ENDIAN      "." LZO_INFO_ABI_ENDIAN
-#else
-#  define __LZO_INFOSTR_ENDIAN      ""
-#endif
-#if defined(__LZO_INFOSTR_OSNAME)
-#elif defined(LZO_INFO_OS_CONSOLE)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_CONSOLE
-#elif defined(LZO_INFO_OS_POSIX)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_POSIX
-#else
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS
-#endif
-#if defined(__LZO_INFOSTR_LIBC)
-#elif defined(LZO_INFO_LIBC)
-#  define __LZO_INFOSTR_LIBC        "." LZO_INFO_LIBC
-#else
-#  define __LZO_INFOSTR_LIBC        ""
-#endif
-#if defined(__LZO_INFOSTR_CCVER)
-#elif defined(LZO_INFO_CCVER)
-#  define __LZO_INFOSTR_CCVER       " " LZO_INFO_CCVER
-#else
-#  define __LZO_INFOSTR_CCVER       ""
-#endif
-#define LZO_INFO_STRING \
-    LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
-    " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
-
-#endif
-
-#endif
-
-#undef LZO_HAVE_CONFIG_H
-#include "minilzo.h"
-
-#if !defined(MINILZO_VERSION) || (MINILZO_VERSION != 0x2040)
-#  error "version mismatch in miniLZO source files"
-#endif
-
-#ifdef MINILZO_HAVE_CONFIG_H
-#  define LZO_HAVE_CONFIG_H 1
-#endif
-
-#ifndef __LZO_CONF_H
-#define __LZO_CONF_H 1
-
-#if !defined(__LZO_IN_MINILZO)
-#if (LZO_CFG_FREESTANDING)
-#  define LZO_LIBC_FREESTANDING 1
-#  define LZO_OS_FREESTANDING 1
-#  define ACC_LIBC_FREESTANDING 1
-#  define ACC_OS_FREESTANDING 1
-#endif
-#if (LZO_CFG_NO_UNALIGNED)
-#  define ACC_CFG_NO_UNALIGNED 1
-#endif
-#if (LZO_ARCH_GENERIC)
-#  define ACC_ARCH_GENERIC 1
-#endif
-#if (LZO_ABI_NEUTRAL_ENDIAN)
-#  define ACC_ABI_NEUTRAL_ENDIAN 1
-#endif
-#if (LZO_HAVE_CONFIG_H)
-#  define ACC_CONFIG_NO_HEADER 1
-#endif
-#if defined(LZO_CFG_EXTRA_CONFIG_HEADER)
-#  include LZO_CFG_EXTRA_CONFIG_HEADER
-#endif
-#if defined(__LZOCONF_H) || defined(__LZOCONF_H_INCLUDED)
-#  error "include this file first"
-#endif
-#include "lzo/lzoconf.h"
-#endif
-
-#if (LZO_VERSION < 0x02000) || !defined(__LZOCONF_H_INCLUDED)
-#  error "version mismatch"
-#endif
-
-#if (LZO_CC_BORLANDC && LZO_ARCH_I086)
-#  pragma option -h
-#endif
-
-#if (LZO_CC_MSC && (_MSC_VER >= 1000))
-#  pragma warning(disable: 4127 4701)
-#endif
-#if (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  pragma warning(disable: 4820)
-#  pragma warning(disable: 4514 4710 4711)
-#endif
-
-#if (LZO_CC_SUNPROC)
-#if !defined(__cplusplus)
-#  pragma error_messages(off,E_END_OF_LOOP_CODE_NOT_REACHED)
-#  pragma error_messages(off,E_LOOP_NOT_ENTERED_AT_TOP)
-#  pragma error_messages(off,E_STATEMENT_NOT_REACHED)
-#endif
-#endif
-
-#if (__LZO_MMODEL_HUGE) && !(LZO_HAVE_MM_HUGE_PTR)
-#  error "this should not happen - check defines for __huge"
-#endif
-
-#if defined(__LZO_IN_MINILZO) || defined(LZO_CFG_FREESTANDING)
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define ACC_WANT_ACC_INCD_H 1
-#  define ACC_WANT_ACC_INCE_H 1
-#  define ACC_WANT_ACC_INCI_H 1
-#elif 1
-#  include <string.h>
-#else
-#  define ACC_WANT_ACC_INCD_H 1
-#endif
-
-#if (LZO_ARCH_I086)
-#  define ACC_MM_AHSHIFT        LZO_MM_AHSHIFT
-#  define ACC_PTR_FP_OFF(x)     (((const unsigned __far*)&(x))[0])
-#  define ACC_PTR_FP_SEG(x)     (((const unsigned __far*)&(x))[1])
-#  define ACC_PTR_MK_FP(s,o)    ((void __far*)(((unsigned long)(s)<<16)+(unsigned)(o)))
-#endif
-
-#if !defined(lzo_uintptr_t)
-#  if defined(__LZO_MMODEL_HUGE)
-#    define lzo_uintptr_t       unsigned long
-#  elif 1 && defined(LZO_OS_OS400) && (LZO_SIZEOF_VOID_P == 16)
-#    define __LZO_UINTPTR_T_IS_POINTER 1
-     typedef char*              lzo_uintptr_t;
-#    define lzo_uintptr_t       lzo_uintptr_t
-#  elif (LZO_SIZEOF_SIZE_T == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       size_t
-#  elif (LZO_SIZEOF_LONG == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned long
-#  elif (LZO_SIZEOF_INT == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned int
-#  elif (LZO_SIZEOF_LONG_LONG == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned long long
-#  else
-#    define lzo_uintptr_t       size_t
-#  endif
-#endif
-LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
-
-#if 1 && !defined(LZO_CFG_FREESTANDING)
-#if 1 && !defined(HAVE_STRING_H)
-#define HAVE_STRING_H 1
-#endif
-#if 1 && !defined(HAVE_MEMCMP)
-#define HAVE_MEMCMP 1
-#endif
-#if 1 && !defined(HAVE_MEMCPY)
-#define HAVE_MEMCPY 1
-#endif
-#if 1 && !defined(HAVE_MEMMOVE)
-#define HAVE_MEMMOVE 1
-#endif
-#if 1 && !defined(HAVE_MEMSET)
-#define HAVE_MEMSET 1
-#endif
-#endif
-
-#if 1 && defined(HAVE_STRING_H)
-#include <string.h>
-#endif
-
-#if (LZO_CFG_FREESTANDING)
-#  undef HAVE_MEMCMP
-#  undef HAVE_MEMCPY
-#  undef HAVE_MEMMOVE
-#  undef HAVE_MEMSET
-#endif
-
-#if !(HAVE_MEMCMP)
-#  undef memcmp
-#  define memcmp(a,b,c)         lzo_memcmp(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memcmp
-#  define lzo_memcmp(a,b,c)     memcmp(a,b,c)
-#endif
-#if !(HAVE_MEMCPY)
-#  undef memcpy
-#  define memcpy(a,b,c)         lzo_memcpy(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memcpy
-#  define lzo_memcpy(a,b,c)     memcpy(a,b,c)
-#endif
-#if !(HAVE_MEMMOVE)
-#  undef memmove
-#  define memmove(a,b,c)        lzo_memmove(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memmove
-#  define lzo_memmove(a,b,c)    memmove(a,b,c)
-#endif
-#if !(HAVE_MEMSET)
-#  undef memset
-#  define memset(a,b,c)         lzo_memset(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memset
-#  define lzo_memset(a,b,c)     memset(a,b,c)
-#endif
-
-#undef NDEBUG
-#if (LZO_CFG_FREESTANDING)
-#  undef LZO_DEBUG
-#  define NDEBUG 1
-#  undef assert
-#  define assert(e) ((void)0)
-#else
-#  if !defined(LZO_DEBUG)
-#    define NDEBUG 1
-#  endif
-#  include <assert.h>
-#endif
-
-#if 0 && defined(__BOUNDS_CHECKING_ON)
-#  include <unchecked.h>
-#else
-#  define BOUNDS_CHECKING_OFF_DURING(stmt)      stmt
-#  define BOUNDS_CHECKING_OFF_IN_EXPR(expr)     (expr)
-#endif
-
-#if !defined(__lzo_inline)
-#  define __lzo_inline              /*empty*/
-#endif
-#if !defined(__lzo_forceinline)
-#  define __lzo_forceinline         /*empty*/
-#endif
-#if !defined(__lzo_noinline)
-#  define __lzo_noinline            /*empty*/
-#endif
-
-#if (LZO_CFG_PGO)
-#  undef __acc_likely
-#  undef __acc_unlikely
-#  undef __lzo_likely
-#  undef __lzo_unlikely
-#  define __acc_likely(e)       (e)
-#  define __acc_unlikely(e)     (e)
-#  define __lzo_likely(e)       (e)
-#  define __lzo_unlikely(e)     (e)
-#endif
-
-#if 1
-#  define LZO_BYTE(x)       ((unsigned char) (x))
-#else
-#  define LZO_BYTE(x)       ((unsigned char) ((x) & 0xff))
-#endif
-
-#define LZO_MAX(a,b)        ((a) >= (b) ? (a) : (b))
-#define LZO_MIN(a,b)        ((a) <= (b) ? (a) : (b))
-#define LZO_MAX3(a,b,c)     ((a) >= (b) ? LZO_MAX(a,c) : LZO_MAX(b,c))
-#define LZO_MIN3(a,b,c)     ((a) <= (b) ? LZO_MIN(a,c) : LZO_MIN(b,c))
-
-#define lzo_sizeof(type)    ((lzo_uint) (sizeof(type)))
-
-#define LZO_HIGH(array)     ((lzo_uint) (sizeof(array)/sizeof(*(array))))
-
-#define LZO_SIZE(bits)      (1u << (bits))
-#define LZO_MASK(bits)      (LZO_SIZE(bits) - 1)
-
-#define LZO_LSIZE(bits)     (1ul << (bits))
-#define LZO_LMASK(bits)     (LZO_LSIZE(bits) - 1)
-
-#define LZO_USIZE(bits)     ((lzo_uint) 1 << (bits))
-#define LZO_UMASK(bits)     (LZO_USIZE(bits) - 1)
-
-#if !defined(DMUL)
-#if 0
-
-#  define DMUL(a,b) ((lzo_xint) ((lzo_uint32)(a) * (lzo_uint32)(b)))
-#else
-#  define DMUL(a,b) ((lzo_xint) ((a) * (b)))
-#endif
-#endif
-
-#if 1 && !(LZO_CFG_NO_UNALIGNED)
-#if 1 && (LZO_ARCH_AMD64 || LZO_ARCH_I386 || LZO_ARCH_POWERPC)
-#  if (LZO_SIZEOF_SHORT == 2)
-#    define LZO_UNALIGNED_OK_2 1
-#  endif
-#  if (LZO_SIZEOF_INT == 4)
-#    define LZO_UNALIGNED_OK_4 1
-#  endif
-#endif
-#endif
-
-#if defined(LZO_UNALIGNED_OK_2)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(short) == 2)
-#endif
-#if defined(LZO_UNALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
-#elif defined(LZO_ALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
-#endif
-
-#undef COPY4
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#  if 1 && defined(ACC_UA_COPY32)
-#    define COPY4(d,s)  ACC_UA_COPY32(d,s)
-#  else
-#    define COPY4(d,s)  (* (__lzo_ua_volatile lzo_uint32p)(__lzo_ua_volatile lzo_voidp)(d) = * (__lzo_ua_volatile const lzo_uint32p)(__lzo_ua_volatile const lzo_voidp)(s))
-#  endif
-#endif
-
-#define MEMCPY8_DS(dest,src,len) \
-    lzo_memcpy(dest,src,len); dest += len; src += len
-
-#define BZERO8_PTR(s,l,n) \
-    lzo_memset((lzo_voidp)(s),0,(lzo_uint)(l)*(n))
-
-#define MEMCPY_DS(dest,src,len) \
-    do *dest++ = *src++; while (--len > 0)
-
-LZO_EXTERN(const lzo_bytep) lzo_copyright(void);
-
-#ifndef __LZO_PTR_H
-#define __LZO_PTR_H 1
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(lzo_uintptr_t)
-#  if (__LZO_MMODEL_HUGE)
-#    define lzo_uintptr_t   unsigned long
-#  else
-#    define lzo_uintptr_t   acc_uintptr_t
-#    ifdef __ACC_INTPTR_T_IS_POINTER
-#      define __LZO_UINTPTR_T_IS_POINTER 1
-#    endif
-#  endif
-#endif
-
-#if (LZO_ARCH_I086)
-#define PTR(a)              ((lzo_bytep) (a))
-#define PTR_ALIGNED_4(a)    ((ACC_PTR_FP_OFF(a) & 3) == 0)
-#define PTR_ALIGNED2_4(a,b) (((ACC_PTR_FP_OFF(a) | ACC_PTR_FP_OFF(b)) & 3) == 0)
-#elif (LZO_MM_PVP)
-#define PTR(a)              ((lzo_bytep) (a))
-#define PTR_ALIGNED_8(a)    ((((lzo_uintptr_t)(a)) >> 61) == 0)
-#define PTR_ALIGNED2_8(a,b) ((((lzo_uintptr_t)(a)|(lzo_uintptr_t)(b)) >> 61) == 0)
-#else
-#define PTR(a)              ((lzo_uintptr_t) (a))
-#define PTR_LINEAR(a)       PTR(a)
-#define PTR_ALIGNED_4(a)    ((PTR_LINEAR(a) & 3) == 0)
-#define PTR_ALIGNED_8(a)    ((PTR_LINEAR(a) & 7) == 0)
-#define PTR_ALIGNED2_4(a,b) (((PTR_LINEAR(a) | PTR_LINEAR(b)) & 3) == 0)
-#define PTR_ALIGNED2_8(a,b) (((PTR_LINEAR(a) | PTR_LINEAR(b)) & 7) == 0)
-#endif
-
-#define PTR_LT(a,b)         (PTR(a) < PTR(b))
-#define PTR_GE(a,b)         (PTR(a) >= PTR(b))
-#define PTR_DIFF(a,b)       (PTR(a) - PTR(b))
-#define pd(a,b)             ((lzo_uint) ((a)-(b)))
-
-LZO_EXTERN(lzo_uintptr_t)
-__lzo_ptr_linear(const lzo_voidp ptr);
-
-typedef union
-{
-    char            a_char;
-    unsigned char   a_uchar;
-    short           a_short;
-    unsigned short  a_ushort;
-    int             a_int;
-    unsigned int    a_uint;
-    long            a_long;
-    unsigned long   a_ulong;
-    lzo_int         a_lzo_int;
-    lzo_uint        a_lzo_uint;
-    lzo_int32       a_lzo_int32;
-    lzo_uint32      a_lzo_uint32;
-    ptrdiff_t       a_ptrdiff_t;
-    lzo_uintptr_t   a_lzo_uintptr_t;
-    lzo_voidp       a_lzo_voidp;
-    void *          a_void_p;
-    lzo_bytep       a_lzo_bytep;
-    lzo_bytepp      a_lzo_bytepp;
-    lzo_uintp       a_lzo_uintp;
-    lzo_uint *      a_lzo_uint_p;
-    lzo_uint32p     a_lzo_uint32p;
-    lzo_uint32 *    a_lzo_uint32_p;
-    unsigned char * a_uchar_p;
-    char *          a_char_p;
-}
-lzo_full_align_t;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-#define LZO_DETERMINISTIC 1
-
-#define LZO_DICT_USE_PTR 1
-#if 0 && (LZO_ARCH_I086)
-#  undef LZO_DICT_USE_PTR
-#endif
-
-#if (LZO_DICT_USE_PTR)
-#  define lzo_dict_t    const lzo_bytep
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
-#else
-#  define lzo_dict_t    lzo_uint
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
-#endif
-
-#endif
-
-#if !defined(MINILZO_CFG_SKIP_LZO_PTR)
-
-LZO_PUBLIC(lzo_uintptr_t)
-__lzo_ptr_linear(const lzo_voidp ptr)
-{
-    lzo_uintptr_t p;
-
-#if (LZO_ARCH_I086)
-    p = (((lzo_uintptr_t)(ACC_PTR_FP_SEG(ptr))) << (16 - ACC_MM_AHSHIFT)) + (ACC_PTR_FP_OFF(ptr));
-#elif (LZO_MM_PVP)
-    p = (lzo_uintptr_t) (ptr);
-    p = (p << 3) | (p >> 61);
-#else
-    p = (lzo_uintptr_t) PTR_LINEAR(ptr);
-#endif
-
-    return p;
-}
-
-LZO_PUBLIC(unsigned)
-__lzo_align_gap(const lzo_voidp ptr, lzo_uint size)
-{
-#if defined(__LZO_UINTPTR_T_IS_POINTER)
-    size_t n = (size_t) ptr;
-    n = (((n + size - 1) / size) * size) - n;
-#else
-    lzo_uintptr_t p, n;
-    p = __lzo_ptr_linear(ptr);
-    n = (((p + size - 1) / size) * size) - p;
-#endif
-
-    assert(size > 0);
-    assert((long)n >= 0);
-    assert(n <= size);
-    return (unsigned)n;
-}
-
-#endif
-#if !defined(MINILZO_CFG_SKIP_LZO_UTIL)
-
-/* If you use the LZO library in a product, I would appreciate that you
- * keep this copyright string in the executable of your product.
- */
-
-static const char __lzo_copyright[] =
-#if !defined(__LZO_IN_MINLZO)
-    LZO_VERSION_STRING;
-#else
-    "\r\n\n"
-    "LZO data compression library.\n"
-    "$Copyright: LZO Copyright (C) 1996-2010 Markus Franz Xaver Johannes Oberhumer\n"
-    "<markus@oberhumer.com>\n"
-    "http://www.oberhumer.com $\n\n"
-    "$Id: LZO version: v" LZO_VERSION_STRING ", " LZO_VERSION_DATE " $\n"
-    "$Info: " LZO_INFO_STRING " $\n";
-#endif
-
-LZO_PUBLIC(const lzo_bytep)
-lzo_copyright(void)
-{
-#if (LZO_OS_DOS16 && LZO_CC_TURBOC)
-    return (lzo_voidp) __lzo_copyright;
-#else
-    return (const lzo_bytep) __lzo_copyright;
-#endif
-}
-
-LZO_PUBLIC(unsigned)
-lzo_version(void)
-{
-    return LZO_VERSION;
-}
-
-LZO_PUBLIC(const char *)
-lzo_version_string(void)
-{
-    return LZO_VERSION_STRING;
-}
-
-LZO_PUBLIC(const char *)
-lzo_version_date(void)
-{
-    return LZO_VERSION_DATE;
-}
-
-LZO_PUBLIC(const lzo_charp)
-_lzo_version_string(void)
-{
-    return LZO_VERSION_STRING;
-}
-
-LZO_PUBLIC(const lzo_charp)
-_lzo_version_date(void)
-{
-    return LZO_VERSION_DATE;
-}
-
-#define LZO_BASE 65521u
-#define LZO_NMAX 5552
-
-#define LZO_DO1(buf,i)  s1 += buf[i]; s2 += s1
-#define LZO_DO2(buf,i)  LZO_DO1(buf,i); LZO_DO1(buf,i+1);
-#define LZO_DO4(buf,i)  LZO_DO2(buf,i); LZO_DO2(buf,i+2);
-#define LZO_DO8(buf,i)  LZO_DO4(buf,i); LZO_DO4(buf,i+4);
-#define LZO_DO16(buf,i) LZO_DO8(buf,i); LZO_DO8(buf,i+8);
-
-LZO_PUBLIC(lzo_uint32)
-lzo_adler32(lzo_uint32 adler, const lzo_bytep buf, lzo_uint len)
-{
-    lzo_uint32 s1 = adler & 0xffff;
-    lzo_uint32 s2 = (adler >> 16) & 0xffff;
-    unsigned k;
-
-    if (buf == NULL)
-        return 1;
-
-    while (len > 0)
-    {
-        k = len < LZO_NMAX ? (unsigned) len : LZO_NMAX;
-        len -= k;
-        if (k >= 16) do
-        {
-            LZO_DO16(buf,0);
-            buf += 16;
-            k -= 16;
-        } while (k >= 16);
-        if (k != 0) do
-        {
-            s1 += *buf++;
-            s2 += s1;
-        } while (--k > 0);
-        s1 %= LZO_BASE;
-        s2 %= LZO_BASE;
-    }
-    return (s2 << 16) | s1;
-}
-
-#undef LZO_DO1
-#undef LZO_DO2
-#undef LZO_DO4
-#undef LZO_DO8
-#undef LZO_DO16
-
-#endif
-#if !defined(MINILZO_CFG_SKIP_LZO_STRING)
-#undef lzo_memcmp
-#undef lzo_memcpy
-#undef lzo_memmove
-#undef lzo_memset
-#if !defined(__LZO_MMODEL_HUGE)
-#  undef LZO_HAVE_MM_HUGE_PTR
-#endif
-#define lzo_hsize_t             lzo_uint
-#define lzo_hvoid_p             lzo_voidp
-#define lzo_hbyte_p             lzo_bytep
-#define LZOLIB_PUBLIC(r,f)      LZO_PUBLIC(r) f
-#define lzo_hmemcmp             lzo_memcmp
-#define lzo_hmemcpy             lzo_memcpy
-#define lzo_hmemmove            lzo_memmove
-#define lzo_hmemset             lzo_memset
-#define __LZOLIB_HMEMCPY_CH_INCLUDED 1
-#if !defined(LZOLIB_PUBLIC)
-#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
-#endif
-LZOLIB_PUBLIC(int, lzo_hmemcmp) (const lzo_hvoid_p s1, const lzo_hvoid_p s2, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCMP)
-    const lzo_hbyte_p p1 = (const lzo_hbyte_p) s1;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) s2;
-    if __lzo_likely(len > 0) do
-    {
-        int d = *p1 - *p2;
-        if (d != 0)
-            return d;
-        p1++; p2++;
-    } while __lzo_likely(--len > 0);
-    return 0;
-#else
-    return memcmp(s1, s2, len);
-#endif
-}
-LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemcpy) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCPY)
-    lzo_hbyte_p p1 = (lzo_hbyte_p) dest;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) src;
-    if (!(len > 0) || p1 == p2)
-        return dest;
-    do
-        *p1++ = *p2++;
-    while __lzo_likely(--len > 0);
-    return dest;
-#else
-    return memcpy(dest, src, len);
-#endif
-}
-LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemmove) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMMOVE)
-    lzo_hbyte_p p1 = (lzo_hbyte_p) dest;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) src;
-    if (!(len > 0) || p1 == p2)
-        return dest;
-    if (p1 < p2)
-    {
-        do
-            *p1++ = *p2++;
-        while __lzo_likely(--len > 0);
-    }
-    else
-    {
-        p1 += len;
-        p2 += len;
-        do
-            *--p1 = *--p2;
-        while __lzo_likely(--len > 0);
-    }
-    return dest;
-#else
-    return memmove(dest, src, len);
-#endif
-}
-LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemset) (lzo_hvoid_p s, int c, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMSET)
-    lzo_hbyte_p p = (lzo_hbyte_p) s;
-    if __lzo_likely(len > 0) do
-        *p++ = (unsigned char) c;
-    while __lzo_likely(--len > 0);
-    return s;
-#else
-    return memset(s, c, len);
-#endif
-}
-#undef LZOLIB_PUBLIC
-#endif
-#if !defined(MINILZO_CFG_SKIP_LZO_INIT)
-
-#if !defined(__LZO_IN_MINILZO)
-
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
-
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint)
-
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int32)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint32)
-    ACCCHK_ASSERT((LZO_UINT32_C(1) << (int)(8*sizeof(LZO_UINT32_C(1))-1)) > 0)
-    ACCCHK_ASSERT(sizeof(lzo_uint32) >= 4)
-
-#if !defined(__LZO_UINTPTR_T_IS_POINTER)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uintptr_t)
-#endif
-    ACCCHK_ASSERT(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
-
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_xint)
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint32))
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint))
-    ACCCHK_ASSERT(sizeof(lzo_xint) == sizeof(lzo_uint32) || sizeof(lzo_xint) == sizeof(lzo_uint))
-
-#endif
-#undef ACCCHK_ASSERT
-
-#if 0
-#define u2p(ptr,off) ((lzo_voidp) (((lzo_bytep)(lzo_voidp)(ptr)) + (off)))
-#else
-static __lzo_noinline lzo_voidp u2p(lzo_voidp ptr, lzo_uint off)
-{
-    return (lzo_voidp) ((lzo_bytep) ptr + off);
-}
-#endif
-
-LZO_PUBLIC(int)
-_lzo_config_check(void)
-{
-    lzo_bool r = 1;
-    union {
-        lzo_xint a[2]; unsigned char b[2*sizeof(lzo_xint)];
-        unsigned short x[2]; lzo_uint32 y[2]; lzo_uint z[2];
-    } u;
-    lzo_voidp p;
-
-    u.a[0] = u.a[1] = 0;
-    p = u2p(&u, 0);
-    r &= ((* (lzo_bytep) p) == 0);
-#if !defined(LZO_CFG_NO_CONFIG_CHECK)
-#if defined(LZO_ABI_BIG_ENDIAN)
-    u.a[0] = u.a[1] = 0; u.b[sizeof(lzo_uint) - 1] = 128;
-    p = u2p(&u, 0);
-    r &= ((* (lzo_uintp) p) == 128);
-#endif
-#if defined(LZO_ABI_LITTLE_ENDIAN)
-    u.a[0] = u.a[1] = 0; u.b[0] = 128;
-    p = u2p(&u, 0);
-    r &= ((* (lzo_uintp) p) == 128);
-#endif
-#if defined(LZO_UNALIGNED_OK_2)
-    u.a[0] = u.a[1] = 0;
-    u.b[0] = 1; u.b[sizeof(unsigned short) + 1] = 2;
-    p = u2p(&u, 1);
-    r &= ((* (lzo_ushortp) p) == 0);
-#endif
-#if defined(LZO_UNALIGNED_OK_4)
-    u.a[0] = u.a[1] = 0;
-    u.b[0] = 3; u.b[sizeof(lzo_uint32) + 1] = 4;
-    p = u2p(&u, 1);
-    r &= ((* (lzo_uint32p) p) == 0);
-#endif
-#endif
-
-    return r == 1 ? LZO_E_OK : LZO_E_ERROR;
-}
-
-LZO_PUBLIC(int)
-__lzo_init_v2(unsigned v, int s1, int s2, int s3, int s4, int s5,
-                          int s6, int s7, int s8, int s9)
-{
-    int r;
-
-#if defined(__LZO_IN_MINILZO)
-#elif (LZO_CC_MSC && ((_MSC_VER) < 700))
-#else
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
-#define ACCCHK_ASSERT(expr)  LZO_COMPILE_TIME_ASSERT(expr)
-#endif
-#undef ACCCHK_ASSERT
-
-    if (v == 0)
-        return LZO_E_ERROR;
-
-    r = (s1 == -1 || s1 == (int) sizeof(short)) &&
-        (s2 == -1 || s2 == (int) sizeof(int)) &&
-        (s3 == -1 || s3 == (int) sizeof(long)) &&
-        (s4 == -1 || s4 == (int) sizeof(lzo_uint32)) &&
-        (s5 == -1 || s5 == (int) sizeof(lzo_uint)) &&
-        (s6 == -1 || s6 == (int) lzo_sizeof_dict_t) &&
-        (s7 == -1 || s7 == (int) sizeof(char *)) &&
-        (s8 == -1 || s8 == (int) sizeof(lzo_voidp)) &&
-        (s9 == -1 || s9 == (int) sizeof(lzo_callback_t));
-    if (!r)
-        return LZO_E_ERROR;
-
-    r = _lzo_config_check();
-    if (r != LZO_E_OK)
-        return r;
-
-    return r;
-}
-
-#if !defined(__LZO_IN_MINILZO)
-
-#if (LZO_OS_WIN16 && LZO_CC_WATCOMC) && defined(__SW_BD)
-
-#if 0
-BOOL FAR PASCAL LibMain ( HANDLE hInstance, WORD wDataSegment,
-                          WORD wHeapSize, LPSTR lpszCmdLine )
-#else
-int __far __pascal LibMain ( int a, short b, short c, long d )
-#endif
-{
-    LZO_UNUSED(a); LZO_UNUSED(b); LZO_UNUSED(c); LZO_UNUSED(d);
-    return 1;
-}
-
-#endif
-
-#endif
-
-#endif
-
-#define LZO1X           1
-#define LZO_EOF_CODE    1
-#define M2_MAX_OFFSET   0x0800
-
-#if !defined(MINILZO_CFG_SKIP_LZO1X_1_COMPRESS)
-
-#define LZO_NEED_DICT_H 1
-#define D_BITS          14
-#define D_INDEX1(d,p)       d = DM(DMUL(0x21,DX3(p,5,5,6)) >> 5)
-#define D_INDEX2(d,p)       d = (d & (D_MASK & 0x7ff)) ^ (D_HIGH | 0x1f)
-
-#ifndef __LZO_CONFIG1X_H
-#define __LZO_CONFIG1X_H 1
-
-#if !defined(LZO1X) && !defined(LZO1Y) && !defined(LZO1Z)
-#  define LZO1X 1
-#endif
-
-#if !defined(__LZO_IN_MINILZO)
-#include "lzo/lzo1x.h"
-#endif
-
-#ifndef LZO_EOF_CODE
-#define LZO_EOF_CODE 1
-#endif
-#undef LZO_DETERMINISTIC
-
-#define M1_MAX_OFFSET   0x0400
-#ifndef M2_MAX_OFFSET
-#define M2_MAX_OFFSET   0x0800
-#endif
-#define M3_MAX_OFFSET   0x4000
-#define M4_MAX_OFFSET   0xbfff
-
-#define MX_MAX_OFFSET   (M1_MAX_OFFSET + M2_MAX_OFFSET)
-
-#define M1_MIN_LEN      2
-#define M1_MAX_LEN      2
-#define M2_MIN_LEN      3
-#ifndef M2_MAX_LEN
-#define M2_MAX_LEN      8
-#endif
-#define M3_MIN_LEN      3
-#define M3_MAX_LEN      33
-#define M4_MIN_LEN      3
-#define M4_MAX_LEN      9
-
-#define M1_MARKER       0
-#define M2_MARKER       64
-#define M3_MARKER       32
-#define M4_MARKER       16
-
-#ifndef MIN_LOOKAHEAD
-#define MIN_LOOKAHEAD       (M2_MAX_LEN + 1)
-#endif
-
-#if defined(LZO_NEED_DICT_H)
-
-#ifndef LZO_HASH
-#define LZO_HASH            LZO_HASH_LZO_INCREMENTAL_B
-#endif
-#define DL_MIN_LEN          M2_MIN_LEN
-
-#ifndef __LZO_DICT_H
-#define __LZO_DICT_H 1
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(D_BITS) && defined(DBITS)
-#  define D_BITS        DBITS
-#endif
-#if !defined(D_BITS)
-#  error "D_BITS is not defined"
-#endif
-#if (D_BITS < 16)
-#  define D_SIZE        LZO_SIZE(D_BITS)
-#  define D_MASK        LZO_MASK(D_BITS)
-#else
-#  define D_SIZE        LZO_USIZE(D_BITS)
-#  define D_MASK        LZO_UMASK(D_BITS)
-#endif
-#define D_HIGH          ((D_MASK >> 1) + 1)
-
-#if !defined(DD_BITS)
-#  define DD_BITS       0
-#endif
-#define DD_SIZE         LZO_SIZE(DD_BITS)
-#define DD_MASK         LZO_MASK(DD_BITS)
-
-#if !defined(DL_BITS)
-#  define DL_BITS       (D_BITS - DD_BITS)
-#endif
-#if (DL_BITS < 16)
-#  define DL_SIZE       LZO_SIZE(DL_BITS)
-#  define DL_MASK       LZO_MASK(DL_BITS)
-#else
-#  define DL_SIZE       LZO_USIZE(DL_BITS)
-#  define DL_MASK       LZO_UMASK(DL_BITS)
-#endif
-
-#if (D_BITS != DL_BITS + DD_BITS)
-#  error "D_BITS does not match"
-#endif
-#if (D_BITS < 6 || D_BITS > 18)
-#  error "invalid D_BITS"
-#endif
-#if (DL_BITS < 6 || DL_BITS > 20)
-#  error "invalid DL_BITS"
-#endif
-#if (DD_BITS < 0 || DD_BITS > 6)
-#  error "invalid DD_BITS"
-#endif
-
-#if !defined(DL_MIN_LEN)
-#  define DL_MIN_LEN    3
-#endif
-#if !defined(DL_SHIFT)
-#  define DL_SHIFT      ((DL_BITS + (DL_MIN_LEN - 1)) / DL_MIN_LEN)
-#endif
-
-#define LZO_HASH_GZIP                   1
-#define LZO_HASH_GZIP_INCREMENTAL       2
-#define LZO_HASH_LZO_INCREMENTAL_A      3
-#define LZO_HASH_LZO_INCREMENTAL_B      4
-
-#if !defined(LZO_HASH)
-#  error "choose a hashing strategy"
-#endif
-
-#undef DM
-#undef DX
-
-#if (DL_MIN_LEN == 3)
-#  define _DV2_A(p,shift1,shift2) \
-        (((( (lzo_xint)((p)[0]) << shift1) ^ (p)[1]) << shift2) ^ (p)[2])
-#  define _DV2_B(p,shift1,shift2) \
-        (((( (lzo_xint)((p)[2]) << shift1) ^ (p)[1]) << shift2) ^ (p)[0])
-#  define _DV3_B(p,shift1,shift2,shift3) \
-        ((_DV2_B((p)+1,shift1,shift2) << (shift3)) ^ (p)[0])
-#elif (DL_MIN_LEN == 2)
-#  define _DV2_A(p,shift1,shift2) \
-        (( (lzo_xint)(p[0]) << shift1) ^ p[1])
-#  define _DV2_B(p,shift1,shift2) \
-        (( (lzo_xint)(p[1]) << shift1) ^ p[2])
-#else
-#  error "invalid DL_MIN_LEN"
-#endif
-#define _DV_A(p,shift)      _DV2_A(p,shift,shift)
-#define _DV_B(p,shift)      _DV2_B(p,shift,shift)
-#define DA2(p,s1,s2) \
-        (((((lzo_xint)((p)[2]) << (s2)) + (p)[1]) << (s1)) + (p)[0])
-#define DS2(p,s1,s2) \
-        (((((lzo_xint)((p)[2]) << (s2)) - (p)[1]) << (s1)) - (p)[0])
-#define DX2(p,s1,s2) \
-        (((((lzo_xint)((p)[2]) << (s2)) ^ (p)[1]) << (s1)) ^ (p)[0])
-#define DA3(p,s1,s2,s3) ((DA2((p)+1,s2,s3) << (s1)) + (p)[0])
-#define DS3(p,s1,s2,s3) ((DS2((p)+1,s2,s3) << (s1)) - (p)[0])
-#define DX3(p,s1,s2,s3) ((DX2((p)+1,s2,s3) << (s1)) ^ (p)[0])
-#define DMS(v,s)        ((lzo_uint) (((v) & (D_MASK >> (s))) << (s)))
-#define DM(v)           DMS(v,0)
-
-#if (LZO_HASH == LZO_HASH_GZIP)
-#  define _DINDEX(dv,p)     (_DV_A((p),DL_SHIFT))
-
-#elif (LZO_HASH == LZO_HASH_GZIP_INCREMENTAL)
-#  define __LZO_HASH_INCREMENTAL 1
-#  define DVAL_FIRST(dv,p)  dv = _DV_A((p),DL_SHIFT)
-#  define DVAL_NEXT(dv,p)   dv = (((dv) << DL_SHIFT) ^ p[2])
-#  define _DINDEX(dv,p)     (dv)
-#  define DVAL_LOOKAHEAD    DL_MIN_LEN
-
-#elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_A)
-#  define __LZO_HASH_INCREMENTAL 1
-#  define DVAL_FIRST(dv,p)  dv = _DV_A((p),5)
-#  define DVAL_NEXT(dv,p) \
-                dv ^= (lzo_xint)(p[-1]) << (2*5); dv = (((dv) << 5) ^ p[2])
-#  define _DINDEX(dv,p)     ((DMUL(0x9f5f,dv)) >> 5)
-#  define DVAL_LOOKAHEAD    DL_MIN_LEN
-
-#elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_B)
-#  define __LZO_HASH_INCREMENTAL 1
-#  define DVAL_FIRST(dv,p)  dv = _DV_B((p),5)
-#  define DVAL_NEXT(dv,p) \
-                dv ^= p[-1]; dv = (((dv) >> 5) ^ ((lzo_xint)(p[2]) << (2*5)))
-#  define _DINDEX(dv,p)     ((DMUL(0x9f5f,dv)) >> 5)
-#  define DVAL_LOOKAHEAD    DL_MIN_LEN
-
-#else
-#  error "choose a hashing strategy"
-#endif
-
-#ifndef DINDEX
-#define DINDEX(dv,p)        ((lzo_uint)((_DINDEX(dv,p)) & DL_MASK) << DD_BITS)
-#endif
-#if !defined(DINDEX1) && defined(D_INDEX1)
-#define DINDEX1             D_INDEX1
-#endif
-#if !defined(DINDEX2) && defined(D_INDEX2)
-#define DINDEX2             D_INDEX2
-#endif
-
-#if !defined(__LZO_HASH_INCREMENTAL)
-#  define DVAL_FIRST(dv,p)  ((void) 0)
-#  define DVAL_NEXT(dv,p)   ((void) 0)
-#  define DVAL_LOOKAHEAD    0
-#endif
-
-#if !defined(DVAL_ASSERT)
-#if defined(__LZO_HASH_INCREMENTAL) && !defined(NDEBUG)
-#if (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_LLVM)
-static void __attribute__((__unused__))
-#else
-static void
-#endif
-DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
-{
-    lzo_xint df;
-    DVAL_FIRST(df,(p));
-    assert(DINDEX(dv,p) == DINDEX(df,p));
-}
-#else
-#  define DVAL_ASSERT(dv,p) ((void) 0)
-#endif
-#endif
-
-#if defined(LZO_DICT_USE_PTR)
-#  define DENTRY(p,in)                          (p)
-#  define GINDEX(m_pos,m_off,dict,dindex,in)    m_pos = dict[dindex]
-#else
-#  define DENTRY(p,in)                          ((lzo_uint) ((p)-(in)))
-#  define GINDEX(m_pos,m_off,dict,dindex,in)    m_off = dict[dindex]
-#endif
-
-#if (DD_BITS == 0)
-
-#  define UPDATE_D(dict,drun,dv,p,in)       dict[ DINDEX(dv,p) ] = DENTRY(p,in)
-#  define UPDATE_I(dict,drun,index,p,in)    dict[index] = DENTRY(p,in)
-#  define UPDATE_P(ptr,drun,p,in)           (ptr)[0] = DENTRY(p,in)
-
-#else
-
-#  define UPDATE_D(dict,drun,dv,p,in)   \
-        dict[ DINDEX(dv,p) + drun++ ] = DENTRY(p,in); drun &= DD_MASK
-#  define UPDATE_I(dict,drun,index,p,in)    \
-        dict[ (index) + drun++ ] = DENTRY(p,in); drun &= DD_MASK
-#  define UPDATE_P(ptr,drun,p,in)   \
-        (ptr) [ drun++ ] = DENTRY(p,in); drun &= DD_MASK
-
-#endif
-
-#if defined(LZO_DICT_USE_PTR)
-
-#define LZO_CHECK_MPOS_DET(m_pos,m_off,in,ip,max_offset) \
-        (m_pos == NULL || (m_off = pd(ip, m_pos)) > max_offset)
-
-#define LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,max_offset) \
-    (BOUNDS_CHECKING_OFF_IN_EXPR(( \
-        m_pos = ip - (lzo_uint) PTR_DIFF(ip,m_pos), \
-        PTR_LT(m_pos,in) || \
-        (m_off = (lzo_uint) PTR_DIFF(ip,m_pos)) == 0 || \
-         m_off > max_offset )))
-
-#else
-
-#define LZO_CHECK_MPOS_DET(m_pos,m_off,in,ip,max_offset) \
-        (m_off == 0 || \
-         ((m_off = pd(ip, in) - m_off) > max_offset) || \
-         (m_pos = (ip) - (m_off), 0) )
-
-#define LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,max_offset) \
-        (pd(ip, in) <= m_off || \
-         ((m_off = pd(ip, in) - m_off) > max_offset) || \
-         (m_pos = (ip) - (m_off), 0) )
-
-#endif
-
-#if defined(LZO_DETERMINISTIC)
-#  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_DET
-#else
-#  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_NON_DET
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-#endif
-
-#endif
-
-#define do_compress     _lzo1x_1_do_compress
-#define DO_COMPRESS     lzo1x_1_compress
-
-#if 1 && defined(DO_COMPRESS) && !defined(do_compress)
-#  define do_compress       LZO_CPP_ECONCAT2(DO_COMPRESS,_core)
-#endif
-
-static __lzo_noinline lzo_uint
-do_compress ( const lzo_bytep in , lzo_uint  in_len,
-                    lzo_bytep out, lzo_uintp out_len,
-                    lzo_voidp wrkmem )
-{
-    register const lzo_bytep ip;
-    lzo_bytep op;
-    const lzo_bytep const in_end = in + in_len;
-    const lzo_bytep const ip_end = in + in_len - M2_MAX_LEN - 5;
-    const lzo_bytep ii;
-    lzo_dict_p const dict = (lzo_dict_p) wrkmem;
-
-    op = out;
-    ip = in;
-    ii = ip;
-
-    ip += 4;
-    for (;;)
-    {
-        register const lzo_bytep m_pos;
-        LZO_DEFINE_UNINITIALIZED_VAR(lzo_uint, m_off, 0);
-        lzo_uint m_len;
-        lzo_uint dindex;
-
-        DINDEX1(dindex,ip);
-        GINDEX(m_pos,m_off,dict,dindex,in);
-        if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))
-            goto literal;
-#if 1
-        if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])
-            goto try_match;
-        DINDEX2(dindex,ip);
-#endif
-        GINDEX(m_pos,m_off,dict,dindex,in);
-        if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))
-            goto literal;
-        if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])
-            goto try_match;
-        goto literal;
-
-try_match:
-#if 1 && defined(LZO_UNALIGNED_OK_2)
-        if (* (const lzo_ushortp) (const lzo_voidp) m_pos != * (const lzo_ushortp) (const lzo_voidp) ip)
-#else
-        if (m_pos[0] != ip[0] || m_pos[1] != ip[1])
-#endif
-        {
-        }
-        else
-        {
-            if __lzo_likely(m_pos[2] == ip[2])
-            {
-#if 0
-                if (m_off <= M2_MAX_OFFSET)
-                    goto match;
-                if (lit <= 3)
-                    goto match;
-                if (lit == 3)
-                {
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(3);
-                    *op++ = *ii++; *op++ = *ii++; *op++ = *ii++;
-                    goto code_match;
-                }
-                if (m_pos[3] == ip[3])
-#endif
-                    goto match;
-            }
-            else
-            {
-#if 0
-#if 0
-                if (m_off <= M1_MAX_OFFSET && lit > 0 && lit <= 3)
-#else
-                if (m_off <= M1_MAX_OFFSET && lit == 3)
-#endif
-                {
-                    register lzo_uint t;
-
-                    t = lit;
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(t);
-                    do *op++ = *ii++; while (--t > 0);
-                    assert(ii == ip);
-                    m_off -= 1;
-                    *op++ = LZO_BYTE(M1_MARKER | ((m_off & 3) << 2));
-                    *op++ = LZO_BYTE(m_off >> 2);
-                    ip += 2;
-                    goto match_done;
-                }
-#endif
-            }
-        }
-
-literal:
-        UPDATE_I(dict,0,dindex,ip,in);
-        ++ip;
-        if __lzo_unlikely(ip >= ip_end)
-            break;
-        continue;
-
-match:
-        UPDATE_I(dict,0,dindex,ip,in);
-        if (pd(ip,ii) > 0)
-        {
-            register lzo_uint t = pd(ip,ii);
-
-            if (t <= 3)
-            {
-                assert(op - 2 > out);
-                op[-2] |= LZO_BYTE(t);
-            }
-            else if (t <= 18)
-                *op++ = LZO_BYTE(t - 3);
-            else
-            {
-                register lzo_uint tt = t - 18;
-
-                *op++ = 0;
-                while (tt > 255)
-                {
-                    tt -= 255;
-                    *op++ = 0;
-                }
-                assert(tt > 0);
-                *op++ = LZO_BYTE(tt);
-            }
-            do *op++ = *ii++; while (--t > 0);
-        }
-
-        assert(ii == ip);
-        ip += 3;
-        if (m_pos[3] != *ip++ || m_pos[4] != *ip++ || m_pos[5] != *ip++ ||
-            m_pos[6] != *ip++ || m_pos[7] != *ip++ || m_pos[8] != *ip++
-#ifdef LZO1Y
-            || m_pos[ 9] != *ip++ || m_pos[10] != *ip++ || m_pos[11] != *ip++
-            || m_pos[12] != *ip++ || m_pos[13] != *ip++ || m_pos[14] != *ip++
-#endif
-           )
-        {
-            --ip;
-            m_len = pd(ip, ii);
-            assert(m_len >= 3); assert(m_len <= M2_MAX_LEN);
-
-            if (m_off <= M2_MAX_OFFSET)
-            {
-                m_off -= 1;
-#if defined(LZO1X)
-                *op++ = LZO_BYTE(((m_len - 1) << 5) | ((m_off & 7) << 2));
-                *op++ = LZO_BYTE(m_off >> 3);
-#elif defined(LZO1Y)
-                *op++ = LZO_BYTE(((m_len + 1) << 4) | ((m_off & 3) << 2));
-                *op++ = LZO_BYTE(m_off >> 2);
-#endif
-            }
-            else if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
-                *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                goto m3_m4_offset;
-            }
-            else
-#if defined(LZO1X)
-            {
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                *op++ = LZO_BYTE(M4_MARKER |
-                                 ((m_off & 0x4000) >> 11) | (m_len - 2));
-                goto m3_m4_offset;
-            }
-#elif defined(LZO1Y)
-                goto m4_match;
-#endif
-        }
-        else
-        {
-            {
-                const lzo_bytep end = in_end;
-                const lzo_bytep m = m_pos + M2_MAX_LEN + 1;
-                while (ip < end && *m == *ip)
-                    m++, ip++;
-                m_len = pd(ip, ii);
-            }
-            assert(m_len > M2_MAX_LEN);
-
-            if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
-                if (m_len <= 33)
-                    *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                else
-                {
-                    m_len -= 33;
-                    *op++ = M3_MARKER | 0;
-                    goto m3_m4_len;
-                }
-            }
-            else
-            {
-#if defined(LZO1Y)
-m4_match:
-#endif
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                if (m_len <= M4_MAX_LEN)
-                    *op++ = LZO_BYTE(M4_MARKER |
-                                     ((m_off & 0x4000) >> 11) | (m_len - 2));
-                else
-                {
-                    m_len -= M4_MAX_LEN;
-                    *op++ = LZO_BYTE(M4_MARKER | ((m_off & 0x4000) >> 11));
-m3_m4_len:
-                    while (m_len > 255)
-                    {
-                        m_len -= 255;
-                        *op++ = 0;
-                    }
-                    assert(m_len > 0);
-                    *op++ = LZO_BYTE(m_len);
-                }
-            }
-
-m3_m4_offset:
-            *op++ = LZO_BYTE((m_off & 63) << 2);
-            *op++ = LZO_BYTE(m_off >> 6);
-        }
-
-#if 0
-match_done:
-#endif
-        ii = ip;
-        if __lzo_unlikely(ip >= ip_end)
-            break;
-    }
-
-    *out_len = pd(op, out);
-    return pd(in_end,ii);
-}
-
-LZO_PUBLIC(int)
-DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
-                         lzo_bytep out, lzo_uintp out_len,
-                         lzo_voidp wrkmem )
-{
-    lzo_bytep op = out;
-    lzo_uint t;
-
-    if __lzo_unlikely(in_len <= M2_MAX_LEN + 5)
-        t = in_len;
-    else
-    {
-        t = do_compress(in,in_len,op,out_len,wrkmem);
-        op += *out_len;
-    }
-
-    if (t > 0)
-    {
-        const lzo_bytep ii = in + in_len - t;
-
-        if (op == out && t <= 238)
-            *op++ = LZO_BYTE(17 + t);
-        else if (t <= 3)
-            op[-2] |= LZO_BYTE(t);
-        else if (t <= 18)
-            *op++ = LZO_BYTE(t - 3);
-        else
-        {
-            lzo_uint tt = t - 18;
-
-            *op++ = 0;
-            while (tt > 255)
-            {
-                tt -= 255;
-                *op++ = 0;
-            }
-            assert(tt > 0);
-            *op++ = LZO_BYTE(tt);
-        }
-        do *op++ = *ii++; while (--t > 0);
-    }
-
-    *op++ = M4_MARKER | 1;
-    *op++ = 0;
-    *op++ = 0;
-
-    *out_len = pd(op, out);
-    return LZO_E_OK;
-}
-
-#endif
-
-#undef do_compress
-#undef DO_COMPRESS
-#undef LZO_HASH
-
-#undef LZO_TEST_OVERRUN
-#undef DO_DECOMPRESS
-#define DO_DECOMPRESS       lzo1x_decompress
-
-#if !defined(MINILZO_CFG_SKIP_LZO1X_DECOMPRESS)
-
-#if defined(LZO_TEST_OVERRUN)
-#  if !defined(LZO_TEST_OVERRUN_INPUT)
-#    define LZO_TEST_OVERRUN_INPUT       2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_OUTPUT)
-#    define LZO_TEST_OVERRUN_OUTPUT      2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#    define LZO_TEST_OVERRUN_LOOKBEHIND  1
-#  endif
-#endif
-
-#undef TEST_IP
-#undef TEST_OP
-#undef TEST_LB
-#undef TEST_LBO
-#undef NEED_IP
-#undef NEED_OP
-#undef HAVE_TEST_IP
-#undef HAVE_TEST_OP
-#undef HAVE_NEED_IP
-#undef HAVE_NEED_OP
-#undef HAVE_ANY_IP
-#undef HAVE_ANY_OP
-
-#if defined(LZO_TEST_OVERRUN_INPUT)
-#  if (LZO_TEST_OVERRUN_INPUT >= 1)
-#    define TEST_IP             (ip < ip_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_INPUT >= 2)
-#    define NEED_IP(x) \
-            if ((lzo_uint)(ip_end - ip) < (lzo_uint)(x))  goto input_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_OUTPUT)
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 1)
-#    define TEST_OP             (op <= op_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 2)
-#    undef TEST_OP
-#    define NEED_OP(x) \
-            if ((lzo_uint)(op_end - op) < (lzo_uint)(x))  goto output_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#  define TEST_LB(m_pos)        if (m_pos < out || m_pos >= op) goto lookbehind_overrun
-#  define TEST_LBO(m_pos,o)     if (m_pos < out || m_pos >= op - (o)) goto lookbehind_overrun
-#else
-#  define TEST_LB(m_pos)        ((void) 0)
-#  define TEST_LBO(m_pos,o)     ((void) 0)
-#endif
-
-#if !defined(LZO_EOF_CODE) && !defined(TEST_IP)
-#  define TEST_IP               (ip < ip_end)
-#endif
-
-#if defined(TEST_IP)
-#  define HAVE_TEST_IP 1
-#else
-#  define TEST_IP               1
-#endif
-#if defined(TEST_OP)
-#  define HAVE_TEST_OP 1
-#else
-#  define TEST_OP               1
-#endif
-
-#if defined(NEED_IP)
-#  define HAVE_NEED_IP 1
-#else
-#  define NEED_IP(x)            ((void) 0)
-#endif
-#if defined(NEED_OP)
-#  define HAVE_NEED_OP 1
-#else
-#  define NEED_OP(x)            ((void) 0)
-#endif
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_NEED_IP)
-#  define HAVE_ANY_IP 1
-#endif
-#if defined(HAVE_TEST_OP) || defined(HAVE_NEED_OP)
-#  define HAVE_ANY_OP 1
-#endif
-
-#if defined(DO_DECOMPRESS)
-LZO_PUBLIC(int)
-DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
-                       lzo_bytep out, lzo_uintp out_len,
-                       lzo_voidp wrkmem )
-#endif
-{
-    register lzo_bytep op;
-    register const lzo_bytep ip;
-    register lzo_uint t;
-#if defined(COPY_DICT)
-    lzo_uint m_off;
-    const lzo_bytep dict_end;
-#else
-    register const lzo_bytep m_pos;
-#endif
-
-    const lzo_bytep const ip_end = in + in_len;
-#if defined(HAVE_ANY_OP)
-    lzo_bytep const op_end = out + *out_len;
-#endif
-#if defined(LZO1Z)
-    lzo_uint last_m_off = 0;
-#endif
-
-    LZO_UNUSED(wrkmem);
-
-#if defined(COPY_DICT)
-    if (dict)
-    {
-        if (dict_len > M4_MAX_OFFSET)
-        {
-            dict += dict_len - M4_MAX_OFFSET;
-            dict_len = M4_MAX_OFFSET;
-        }
-        dict_end = dict + dict_len;
-    }
-    else
-    {
-        dict_len = 0;
-        dict_end = NULL;
-    }
-#endif
-
-    *out_len = 0;
-
-    op = out;
-    ip = in;
-
-    if (*ip > 17)
-    {
-        t = *ip++ - 17;
-        if (t < 4)
-            goto match_next;
-        assert(t > 0); NEED_OP(t); NEED_IP(t+1);
-        do *op++ = *ip++; while (--t > 0);
-        goto first_literal_run;
-    }
-
-    while (TEST_IP && TEST_OP)
-    {
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-        if (t == 0)
-        {
-            NEED_IP(1);
-            while (*ip == 0)
-            {
-                t += 255;
-                ip++;
-                NEED_IP(1);
-            }
-            t += 15 + *ip++;
-        }
-        assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-        if (PTR_ALIGNED2_4(op,ip))
-        {
-#endif
-        COPY4(op,ip);
-        op += 4; ip += 4;
-        if (--t > 0)
-        {
-            if (t >= 4)
-            {
-                do {
-                    COPY4(op,ip);
-                    op += 4; ip += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *ip++; while (--t > 0);
-            }
-            else
-                do *op++ = *ip++; while (--t > 0);
-        }
-#if !defined(LZO_UNALIGNED_OK_4)
-        }
-        else
-#endif
-#endif
-#if !defined(LZO_UNALIGNED_OK_4)
-        {
-            *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
-            do *op++ = *ip++; while (--t > 0);
-        }
-#endif
-
-first_literal_run:
-
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-        m_off = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        last_m_off = m_off;
-#else
-        m_off = (1 + M2_MAX_OFFSET) + (t >> 2) + (*ip++ << 2);
-#endif
-        NEED_OP(3);
-        t = 3; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-        t = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        m_pos = op - t;
-        last_m_off = t;
-#else
-        m_pos = op - (1 + M2_MAX_OFFSET);
-        m_pos -= t >> 2;
-        m_pos -= *ip++ << 2;
-#endif
-        TEST_LB(m_pos); NEED_OP(3);
-        *op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-        goto match_done;
-
-        do {
-match:
-            if (t >= 64)
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1X)
-                m_off = 1 + ((t >> 2) & 7) + (*ip++ << 3);
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_off = 1 + ((t >> 2) & 3) + (*ip++ << 2);
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                m_off = t & 0x1f;
-                if (m_off >= 0x1c)
-                    m_off = last_m_off;
-                else
-                {
-                    m_off = 1 + (m_off << 6) + (*ip++ >> 2);
-                    last_m_off = m_off;
-                }
-                t = (t >> 5) - 1;
-#endif
-#else
-#if defined(LZO1X)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 7;
-                m_pos -= *ip++ << 3;
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 3;
-                m_pos -= *ip++ << 2;
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                {
-                    lzo_uint off = t & 0x1f;
-                    m_pos = op;
-                    if (off >= 0x1c)
-                    {
-                        assert(last_m_off > 0);
-                        m_pos -= last_m_off;
-                    }
-                    else
-                    {
-                        off = 1 + (off << 6) + (*ip++ >> 2);
-                        m_pos -= off;
-                        last_m_off = off;
-                    }
-                }
-                t = (t >> 5) - 1;
-#endif
-                TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-                goto copy_match;
-#endif
-            }
-            else if (t >= 32)
-            {
-                t &= 31;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 31 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#else
-#if defined(LZO1Z)
-                {
-                    lzo_uint off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                    m_pos = op - off;
-                    last_m_off = off;
-                }
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos = op - 1;
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos = op - 1;
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#endif
-                ip += 2;
-            }
-            else if (t >= 16)
-            {
-#if defined(COPY_DICT)
-                m_off = (t & 8) << 11;
-#else
-                m_pos = op;
-                m_pos -= (t & 8) << 11;
-#endif
-                t &= 7;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 7 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off += (ip[0] << 6) + (ip[1] >> 2);
-#else
-                m_off += (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_off == 0)
-                    goto eof_found;
-                m_off += 0x4000;
-#if defined(LZO1Z)
-                last_m_off = m_off;
-#endif
-#else
-#if defined(LZO1Z)
-                m_pos -= (ip[0] << 6) + (ip[1] >> 2);
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_pos == op)
-                    goto eof_found;
-                m_pos -= 0x4000;
-#if defined(LZO1Z)
-                last_m_off = pd((const lzo_bytep)op, m_pos);
-#endif
-#endif
-            }
-            else
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (t << 6) + (*ip++ >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (t >> 2) + (*ip++ << 2);
-#endif
-                NEED_OP(2);
-                t = 2; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-                t = 1 + (t << 6) + (*ip++ >> 2);
-                m_pos = op - t;
-                last_m_off = t;
-#else
-                m_pos = op - 1;
-                m_pos -= t >> 2;
-                m_pos -= *ip++ << 2;
-#endif
-                TEST_LB(m_pos); NEED_OP(2);
-                *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-                goto match_done;
-            }
-
-#if defined(COPY_DICT)
-
-            NEED_OP(t+3-1);
-            t += 3-1; COPY_DICT(t,m_off)
-
-#else
-
-            TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-            if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
-            {
-                assert((op - m_pos) >= 4);
-#else
-            if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
-            {
-#endif
-                COPY4(op,m_pos);
-                op += 4; m_pos += 4; t -= 4 - (3 - 1);
-                do {
-                    COPY4(op,m_pos);
-                    op += 4; m_pos += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *m_pos++; while (--t > 0);
-            }
-            else
-#endif
-            {
-copy_match:
-                *op++ = *m_pos++; *op++ = *m_pos++;
-                do *op++ = *m_pos++; while (--t > 0);
-            }
-
-#endif
-
-match_done:
-#if defined(LZO1Z)
-            t = ip[-1] & 3;
-#else
-            t = ip[-2] & 3;
-#endif
-            if (t == 0)
-                break;
-
-match_next:
-            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);
-#if 0
-            do *op++ = *ip++; while (--t > 0);
-#else
-            *op++ = *ip++;
-            if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
-#endif
-            t = *ip++;
-        } while (TEST_IP && TEST_OP);
-    }
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
-    *out_len = pd(op, out);
-    return LZO_E_EOF_NOT_FOUND;
-#endif
-
-eof_found:
-    assert(t == 1);
-    *out_len = pd(op, out);
-    return (ip == ip_end ? LZO_E_OK :
-           (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
-
-#if defined(HAVE_NEED_IP)
-input_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_INPUT_OVERRUN;
-#endif
-
-#if defined(HAVE_NEED_OP)
-output_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_OUTPUT_OVERRUN;
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-lookbehind_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_LOOKBEHIND_OVERRUN;
-#endif
-}
-
-#endif
-
-#define LZO_TEST_OVERRUN 1
-#undef DO_DECOMPRESS
-#define DO_DECOMPRESS       lzo1x_decompress_safe
-
-#if !defined(MINILZO_CFG_SKIP_LZO1X_DECOMPRESS_SAFE)
-
-#if defined(LZO_TEST_OVERRUN)
-#  if !defined(LZO_TEST_OVERRUN_INPUT)
-#    define LZO_TEST_OVERRUN_INPUT       2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_OUTPUT)
-#    define LZO_TEST_OVERRUN_OUTPUT      2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#    define LZO_TEST_OVERRUN_LOOKBEHIND  1
-#  endif
-#endif
-
-#undef TEST_IP
-#undef TEST_OP
-#undef TEST_LB
-#undef TEST_LBO
-#undef NEED_IP
-#undef NEED_OP
-#undef HAVE_TEST_IP
-#undef HAVE_TEST_OP
-#undef HAVE_NEED_IP
-#undef HAVE_NEED_OP
-#undef HAVE_ANY_IP
-#undef HAVE_ANY_OP
-
-#if defined(LZO_TEST_OVERRUN_INPUT)
-#  if (LZO_TEST_OVERRUN_INPUT >= 1)
-#    define TEST_IP             (ip < ip_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_INPUT >= 2)
-#    define NEED_IP(x) \
-            if ((lzo_uint)(ip_end - ip) < (lzo_uint)(x))  goto input_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_OUTPUT)
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 1)
-#    define TEST_OP             (op <= op_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 2)
-#    undef TEST_OP
-#    define NEED_OP(x) \
-            if ((lzo_uint)(op_end - op) < (lzo_uint)(x))  goto output_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#  define TEST_LB(m_pos)        if (m_pos < out || m_pos >= op) goto lookbehind_overrun
-#  define TEST_LBO(m_pos,o)     if (m_pos < out || m_pos >= op - (o)) goto lookbehind_overrun
-#else
-#  define TEST_LB(m_pos)        ((void) 0)
-#  define TEST_LBO(m_pos,o)     ((void) 0)
-#endif
-
-#if !defined(LZO_EOF_CODE) && !defined(TEST_IP)
-#  define TEST_IP               (ip < ip_end)
-#endif
-
-#if defined(TEST_IP)
-#  define HAVE_TEST_IP 1
-#else
-#  define TEST_IP               1
-#endif
-#if defined(TEST_OP)
-#  define HAVE_TEST_OP 1
-#else
-#  define TEST_OP               1
-#endif
-
-#if defined(NEED_IP)
-#  define HAVE_NEED_IP 1
-#else
-#  define NEED_IP(x)            ((void) 0)
-#endif
-#if defined(NEED_OP)
-#  define HAVE_NEED_OP 1
-#else
-#  define NEED_OP(x)            ((void) 0)
-#endif
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_NEED_IP)
-#  define HAVE_ANY_IP 1
-#endif
-#if defined(HAVE_TEST_OP) || defined(HAVE_NEED_OP)
-#  define HAVE_ANY_OP 1
-#endif
-
-#if defined(DO_DECOMPRESS)
-LZO_PUBLIC(int)
-DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
-                       lzo_bytep out, lzo_uintp out_len,
-                       lzo_voidp wrkmem )
-#endif
-{
-    register lzo_bytep op;
-    register const lzo_bytep ip;
-    register lzo_uint t;
-#if defined(COPY_DICT)
-    lzo_uint m_off;
-    const lzo_bytep dict_end;
-#else
-    register const lzo_bytep m_pos;
-#endif
-
-    const lzo_bytep const ip_end = in + in_len;
-#if defined(HAVE_ANY_OP)
-    lzo_bytep const op_end = out + *out_len;
-#endif
-#if defined(LZO1Z)
-    lzo_uint last_m_off = 0;
-#endif
-
-    LZO_UNUSED(wrkmem);
-
-#if defined(COPY_DICT)
-    if (dict)
-    {
-        if (dict_len > M4_MAX_OFFSET)
-        {
-            dict += dict_len - M4_MAX_OFFSET;
-            dict_len = M4_MAX_OFFSET;
-        }
-        dict_end = dict + dict_len;
-    }
-    else
-    {
-        dict_len = 0;
-        dict_end = NULL;
-    }
-#endif
-
-    *out_len = 0;
-
-    op = out;
-    ip = in;
-
-    if (*ip > 17)
-    {
-        t = *ip++ - 17;
-        if (t < 4)
-            goto match_next;
-        assert(t > 0); NEED_OP(t); NEED_IP(t+1);
-        do *op++ = *ip++; while (--t > 0);
-        goto first_literal_run;
-    }
-
-    while (TEST_IP && TEST_OP)
-    {
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-        if (t == 0)
-        {
-            NEED_IP(1);
-            while (*ip == 0)
-            {
-                t += 255;
-                ip++;
-                NEED_IP(1);
-            }
-            t += 15 + *ip++;
-        }
-        assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-        if (PTR_ALIGNED2_4(op,ip))
-        {
-#endif
-        COPY4(op,ip);
-        op += 4; ip += 4;
-        if (--t > 0)
-        {
-            if (t >= 4)
-            {
-                do {
-                    COPY4(op,ip);
-                    op += 4; ip += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *ip++; while (--t > 0);
-            }
-            else
-                do *op++ = *ip++; while (--t > 0);
-        }
-#if !defined(LZO_UNALIGNED_OK_4)
-        }
-        else
-#endif
-#endif
-#if !defined(LZO_UNALIGNED_OK_4)
-        {
-            *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
-            do *op++ = *ip++; while (--t > 0);
-        }
-#endif
-
-first_literal_run:
-
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-        m_off = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        last_m_off = m_off;
-#else
-        m_off = (1 + M2_MAX_OFFSET) + (t >> 2) + (*ip++ << 2);
-#endif
-        NEED_OP(3);
-        t = 3; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-        t = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        m_pos = op - t;
-        last_m_off = t;
-#else
-        m_pos = op - (1 + M2_MAX_OFFSET);
-        m_pos -= t >> 2;
-        m_pos -= *ip++ << 2;
-#endif
-        TEST_LB(m_pos); NEED_OP(3);
-        *op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-        goto match_done;
-
-        do {
-match:
-            if (t >= 64)
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1X)
-                m_off = 1 + ((t >> 2) & 7) + (*ip++ << 3);
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_off = 1 + ((t >> 2) & 3) + (*ip++ << 2);
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                m_off = t & 0x1f;
-                if (m_off >= 0x1c)
-                    m_off = last_m_off;
-                else
-                {
-                    m_off = 1 + (m_off << 6) + (*ip++ >> 2);
-                    last_m_off = m_off;
-                }
-                t = (t >> 5) - 1;
-#endif
-#else
-#if defined(LZO1X)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 7;
-                m_pos -= *ip++ << 3;
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 3;
-                m_pos -= *ip++ << 2;
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                {
-                    lzo_uint off = t & 0x1f;
-                    m_pos = op;
-                    if (off >= 0x1c)
-                    {
-                        assert(last_m_off > 0);
-                        m_pos -= last_m_off;
-                    }
-                    else
-                    {
-                        off = 1 + (off << 6) + (*ip++ >> 2);
-                        m_pos -= off;
-                        last_m_off = off;
-                    }
-                }
-                t = (t >> 5) - 1;
-#endif
-                TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-                goto copy_match;
-#endif
-            }
-            else if (t >= 32)
-            {
-                t &= 31;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 31 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#else
-#if defined(LZO1Z)
-                {
-                    lzo_uint off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                    m_pos = op - off;
-                    last_m_off = off;
-                }
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos = op - 1;
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos = op - 1;
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#endif
-                ip += 2;
-            }
-            else if (t >= 16)
-            {
-#if defined(COPY_DICT)
-                m_off = (t & 8) << 11;
-#else
-                m_pos = op;
-                m_pos -= (t & 8) << 11;
-#endif
-                t &= 7;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 7 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off += (ip[0] << 6) + (ip[1] >> 2);
-#else
-                m_off += (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_off == 0)
-                    goto eof_found;
-                m_off += 0x4000;
-#if defined(LZO1Z)
-                last_m_off = m_off;
-#endif
-#else
-#if defined(LZO1Z)
-                m_pos -= (ip[0] << 6) + (ip[1] >> 2);
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_pos == op)
-                    goto eof_found;
-                m_pos -= 0x4000;
-#if defined(LZO1Z)
-                last_m_off = pd((const lzo_bytep)op, m_pos);
-#endif
-#endif
-            }
-            else
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (t << 6) + (*ip++ >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (t >> 2) + (*ip++ << 2);
-#endif
-                NEED_OP(2);
-                t = 2; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-                t = 1 + (t << 6) + (*ip++ >> 2);
-                m_pos = op - t;
-                last_m_off = t;
-#else
-                m_pos = op - 1;
-                m_pos -= t >> 2;
-                m_pos -= *ip++ << 2;
-#endif
-                TEST_LB(m_pos); NEED_OP(2);
-                *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-                goto match_done;
-            }
-
-#if defined(COPY_DICT)
-
-            NEED_OP(t+3-1);
-            t += 3-1; COPY_DICT(t,m_off)
-
-#else
-
-            TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-            if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
-            {
-                assert((op - m_pos) >= 4);
-#else
-            if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
-            {
-#endif
-                COPY4(op,m_pos);
-                op += 4; m_pos += 4; t -= 4 - (3 - 1);
-                do {
-                    COPY4(op,m_pos);
-                    op += 4; m_pos += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *m_pos++; while (--t > 0);
-            }
-            else
-#endif
-            {
-copy_match:
-                *op++ = *m_pos++; *op++ = *m_pos++;
-                do *op++ = *m_pos++; while (--t > 0);
-            }
-
-#endif
-
-match_done:
-#if defined(LZO1Z)
-            t = ip[-1] & 3;
-#else
-            t = ip[-2] & 3;
-#endif
-            if (t == 0)
-                break;
-
-match_next:
-            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);
-#if 0
-            do *op++ = *ip++; while (--t > 0);
-#else
-            *op++ = *ip++;
-            if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
-#endif
-            t = *ip++;
-        } while (TEST_IP && TEST_OP);
-    }
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
-    *out_len = pd(op, out);
-    return LZO_E_EOF_NOT_FOUND;
-#endif
-
-eof_found:
-    assert(t == 1);
-    *out_len = pd(op, out);
-    return (ip == ip_end ? LZO_E_OK :
-           (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
-
-#if defined(HAVE_NEED_IP)
-input_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_INPUT_OVERRUN;
-#endif
-
-#if defined(HAVE_NEED_OP)
-output_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_OUTPUT_OVERRUN;
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-lookbehind_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_LOOKBEHIND_OVERRUN;
-#endif
-}
-
-#endif
-
-/***** End of minilzo.c *****/
-
diff --git a/libvncserver/minilzo.h b/libvncserver/minilzo.h
deleted file mode 100644
index bd8ad65..0000000
--- a/libvncserver/minilzo.h
+++ /dev/null
@@ -1,108 +0,0 @@
-/* minilzo.h -- mini subset of the LZO real-time data compression library
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-/*
- * NOTE:
- *   the full LZO package can be found at
- *   http://www.oberhumer.com/opensource/lzo/
- */
-
-
-#ifndef __MINILZO_H
-#define __MINILZO_H 1
-
-#define MINILZO_VERSION         0x2040
-
-#ifdef __LZOCONF_H
-#  error "you cannot use both LZO and miniLZO"
-#endif
-
-#undef LZO_HAVE_CONFIG_H
-#include "lzoconf.h"
-
-#if !defined(LZO_VERSION) || (LZO_VERSION != MINILZO_VERSION)
-#  error "version mismatch in header files"
-#endif
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/***********************************************************************
-//
-************************************************************************/
-
-/* Memory required for the wrkmem parameter.
- * When the required size is 0, you can also pass a NULL pointer.
- */
-
-#define LZO1X_MEM_COMPRESS      LZO1X_1_MEM_COMPRESS
-#define LZO1X_1_MEM_COMPRESS    ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
-#define LZO1X_MEM_DECOMPRESS    (0)
-
-
-/* compression */
-LZO_EXTERN(int)
-lzo1x_1_compress        ( const lzo_bytep src, lzo_uint  src_len,
-                                lzo_bytep dst, lzo_uintp dst_len,
-                                lzo_voidp wrkmem );
-
-/* decompression */
-LZO_EXTERN(int)
-lzo1x_decompress        ( const lzo_bytep src, lzo_uint  src_len,
-                                lzo_bytep dst, lzo_uintp dst_len,
-                                lzo_voidp wrkmem /* NOT USED */ );
-
-/* safe decompression with overrun testing */
-LZO_EXTERN(int)
-lzo1x_decompress_safe   ( const lzo_bytep src, lzo_uint  src_len,
-                                lzo_bytep dst, lzo_uintp dst_len,
-                                lzo_voidp wrkmem /* NOT USED */ );
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-
-#endif /* already included */
-
diff --git a/libvncserver/private.h b/libvncserver/private.h
deleted file mode 100644
index d656e39..0000000
--- a/libvncserver/private.h
+++ /dev/null
@@ -1,35 +0,0 @@
-#ifndef RFB_PRIVATE_H
-#define RFB_PRIVATE_H
-
-/* from cursor.c */
-
-void rfbShowCursor(rfbClientPtr cl);
-void rfbHideCursor(rfbClientPtr cl);
-void rfbRedrawAfterHideCursor(rfbClientPtr cl,sraRegionPtr updateRegion);
-
-/* from main.c */
-
-rfbClientPtr rfbClientIteratorHead(rfbClientIteratorPtr i);
-
-/* from tight.c */
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-extern void rfbTightCleanup(rfbScreenInfoPtr screen);
-#endif
-
-/* from zlib.c */
-extern void rfbZlibCleanup(rfbScreenInfoPtr screen);
-
-/* from zrle.c */
-void rfbFreeZrleData(rfbClientPtr cl);
-
-#endif
-
-
-/* from ultra.c */
-
-extern void rfbFreeUltraData(rfbClientPtr cl);
-
-#endif
-
diff --git a/libvncserver/rfb/default8x16.h b/libvncserver/rfb/default8x16.h
deleted file mode 100644
index 252f411..0000000
--- a/libvncserver/rfb/default8x16.h
+++ /dev/null
@@ -1,261 +0,0 @@
-static unsigned char default8x16FontData[4096+1]={
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7e,0x81,0xa5,0x81,0x81,0xbd,0x99,0x81,0x81,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7e,0xff,0xdb,0xff,0xff,0xc3,0xe7,0xff,0xff,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x6c,0xfe,0xfe,0xfe,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x18,0x3c,0x3c,0xe7,0xe7,0xe7,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x18,0x3c,0x7e,0xff,0xff,0x7e,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
-0xff,0xff,0xff,0xff,0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0xff,0xff,0xff,0xff,
-0x00,0x00,0x00,0x00,0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,0x00,0x00,0x00,0x00,
-0xff,0xff,0xff,0xff,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0xff,0xff,0xff,0xff,
-0x00,0x00,0x1e,0x0e,0x1a,0x32,0x78,0xcc,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0x66,0x66,0x66,0x3c,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3f,0x33,0x3f,0x30,0x30,0x30,0x30,0x70,0xf0,0xe0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7f,0x63,0x7f,0x63,0x63,0x63,0x63,0x67,0xe7,0xe6,0xc0,0x00,0x00,0x00,
-0x00,0x00,0x00,0x18,0x18,0xdb,0x3c,0xe7,0x3c,0xdb,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfe,0xf8,0xf0,0xe0,0xc0,0x80,0x00,0x00,0x00,0x00,
-0x00,0x02,0x06,0x0e,0x1e,0x3e,0xfe,0x3e,0x1e,0x0e,0x06,0x02,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7f,0xdb,0xdb,0xdb,0x7b,0x1b,0x1b,0x1b,0x1b,0x1b,0x00,0x00,0x00,0x00,
-0x00,0x7c,0xc6,0x60,0x38,0x6c,0xc6,0xc6,0x6c,0x38,0x0c,0xc6,0x7c,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfe,0xfe,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x7e,0x3c,0x18,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x18,0x0c,0xfe,0x0c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x30,0x60,0xfe,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x24,0x66,0xff,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x10,0x38,0x38,0x7c,0x7c,0xfe,0xfe,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0xfe,0xfe,0x7c,0x7c,0x38,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x3c,0x3c,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x6c,0x6c,0xfe,0x6c,0x6c,0x6c,0xfe,0x6c,0x6c,0x00,0x00,0x00,0x00,
-0x18,0x18,0x7c,0xc6,0xc2,0xc0,0x7c,0x06,0x06,0x86,0xc6,0x7c,0x18,0x18,0x00,0x00,
-0x00,0x00,0x00,0x00,0xc2,0xc6,0x0c,0x18,0x30,0x60,0xc6,0x86,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x6c,0x6c,0x38,0x76,0xdc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0c,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x30,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x30,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x02,0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xce,0xde,0xf6,0xe6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0x06,0x0c,0x18,0x30,0x60,0xc0,0xc6,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0x06,0x06,0x3c,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0c,0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x0c,0x0c,0x1e,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xfc,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x60,0xc0,0xc0,0xfc,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0xc6,0x06,0x06,0x0c,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x0c,0x78,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x06,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x06,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x60,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0x0c,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xde,0xde,0xde,0xdc,0xc0,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x66,0x66,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xc0,0xc0,0xc2,0x66,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xf8,0x6c,0x66,0x66,0x66,0x66,0x66,0x66,0x6c,0xf8,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xde,0xc6,0xc6,0x66,0x3a,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1e,0x0c,0x0c,0x0c,0x0c,0x0c,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0x00,
-0x00,0x00,0xe6,0x66,0x66,0x6c,0x78,0x78,0x6c,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0xf0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xe7,0xff,0xff,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xd6,0xde,0x7c,0x0c,0x0e,0x00,0x00,
-0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x6c,0x66,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0x60,0x38,0x0c,0x06,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xff,0xdb,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0x66,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xdb,0xdb,0xff,0x66,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0x66,0x3c,0x18,0x18,0x3c,0x66,0xc3,0xc3,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0xc3,0x66,0x3c,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xff,0xc3,0x86,0x0c,0x18,0x30,0x60,0xc1,0xc3,0xff,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x80,0xc0,0xe0,0x70,0x38,0x1c,0x0e,0x06,0x02,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00,0x00,0x00,0x00,
-0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,
-0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0xe0,0x60,0x60,0x78,0x6c,0x66,0x66,0x66,0x66,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc0,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1c,0x0c,0x0c,0x3c,0x6c,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x6c,0x64,0x60,0xf0,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0xcc,0xcc,0x7c,0x0c,0xcc,0x78,0x00,
-0x00,0x00,0xe0,0x60,0x60,0x6c,0x76,0x66,0x66,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x06,0x06,0x00,0x0e,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3c,0x00,
-0x00,0x00,0xe0,0x60,0x60,0x66,0x6c,0x78,0x78,0x6c,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xe6,0xff,0xdb,0xdb,0xdb,0xdb,0xdb,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0xcc,0xcc,0x7c,0x0c,0x0c,0x1e,0x00,
-0x00,0x00,0x00,0x00,0x00,0xdc,0x76,0x66,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0x60,0x38,0x0c,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x10,0x30,0x30,0xfc,0x30,0x30,0x30,0x30,0x36,0x1c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc3,0xc3,0xc3,0xc3,0x66,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc3,0xc3,0xc3,0xdb,0xdb,0xff,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc3,0x66,0x3c,0x18,0x3c,0x66,0xc3,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x0c,0xf8,0x00,
-0x00,0x00,0x00,0x00,0x00,0xfe,0xcc,0x18,0x30,0x60,0xc6,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0e,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x70,0x18,0x18,0x18,0x0e,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,
-0x00,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xc6,0xfe,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xc0,0xc2,0x66,0x3c,0x0c,0x06,0x7c,0x00,0x00,
-0x00,0x00,0xcc,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x0c,0x18,0x30,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x10,0x38,0x6c,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0xcc,0x00,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x38,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x3c,0x66,0x60,0x60,0x66,0x3c,0x0c,0x06,0x3c,0x00,0x00,0x00,
-0x00,0x10,0x38,0x6c,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0x00,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x66,0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x3c,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0xc6,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x38,0x6c,0x38,0x00,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x18,0x30,0x60,0x00,0xfe,0x66,0x60,0x7c,0x60,0x60,0x66,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x6e,0x3b,0x1b,0x7e,0xd8,0xdc,0x77,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3e,0x6c,0xcc,0xcc,0xfe,0xcc,0xcc,0xcc,0xcc,0xce,0x00,0x00,0x00,0x00,
-0x00,0x10,0x38,0x6c,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x30,0x78,0xcc,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x0c,0x78,0x00,
-0x00,0xc6,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0xc6,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x18,0x7e,0xc3,0xc0,0xc0,0xc0,0xc3,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x64,0x60,0xf0,0x60,0x60,0x60,0x60,0xe6,0xfc,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0x66,0x3c,0x18,0xff,0x18,0xff,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0xfc,0x66,0x66,0x7c,0x62,0x66,0x6f,0x66,0x66,0x66,0xf3,0x00,0x00,0x00,0x00,
-0x00,0x0e,0x1b,0x18,0x18,0x18,0x7e,0x18,0x18,0x18,0x18,0x18,0xd8,0x70,0x00,0x00,
-0x00,0x18,0x30,0x60,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x0c,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x30,0x60,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x30,0x60,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x76,0xdc,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
-0x76,0xdc,0x00,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x3c,0x6c,0x6c,0x3e,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x6c,0x38,0x00,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x60,0xc0,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00,
-0x00,0xc0,0xc0,0xc2,0xc6,0xcc,0x18,0x30,0x60,0xce,0x9b,0x06,0x0c,0x1f,0x00,0x00,
-0x00,0xc0,0xc0,0xc2,0xc6,0xcc,0x18,0x30,0x66,0xce,0x96,0x3e,0x06,0x06,0x00,0x00,
-0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x3c,0x3c,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x36,0x6c,0xd8,0x6c,0x36,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xd8,0x6c,0x36,0x6c,0xd8,0x00,0x00,0x00,0x00,0x00,0x00,
-0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
-0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,
-0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0xfe,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x3f,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x18,0x18,0x18,0x18,0x18,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x18,0x18,0x18,0x18,0x18,0xff,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
-0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xdc,0xd8,0xd8,0xd8,0xdc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x78,0xcc,0xcc,0xcc,0xd8,0xcc,0xc6,0xc6,0xc6,0xcc,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0xc6,0xc6,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0xfe,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0xfe,0xc6,0x60,0x30,0x18,0x30,0x60,0xc6,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7e,0xd8,0xd8,0xd8,0xd8,0xd8,0x70,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x7c,0x60,0x60,0xc0,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x76,0xdc,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x7e,0x18,0x3c,0x66,0x66,0x66,0x3c,0x18,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0x6c,0x38,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x6c,0xc6,0xc6,0xc6,0x6c,0x6c,0x6c,0x6c,0xee,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1e,0x30,0x18,0x0c,0x3e,0x66,0x66,0x66,0x66,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7e,0xdb,0xdb,0xdb,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x03,0x06,0x7e,0xdb,0xdb,0xf3,0x7e,0x60,0xc0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1c,0x30,0x60,0x60,0x7c,0x60,0x60,0x60,0x30,0x1c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0xfe,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0xff,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x00,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x00,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0e,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xd8,0xd8,0xd8,0x70,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x7e,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xdc,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x6c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x0f,0x0c,0x0c,0x0c,0x0c,0x0c,0xec,0x6c,0x6c,0x3c,0x1c,0x00,0x00,0x00,0x00,
-0x00,0xd8,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x70,0xd8,0x30,0x60,0xc8,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-};
-static int default8x16FontMetaData[256*5+1]={
-0,8,16,0,0,16,8,16,0,0,32,8,16,0,0,48,8,16,0,0,64,8,16,0,0,80,8,16,0,0,96,8,16,0,0,112,8,16,0,0,128,8,16,0,0,144,8,16,0,0,160,8,16,0,0,176,8,16,0,0,192,8,16,0,0,208,8,16,0,0,224,8,16,0,0,240,8,16,0,0,256,8,16,0,0,272,8,16,0,0,288,8,16,0,0,304,8,16,0,0,320,8,16,0,0,336,8,16,0,0,352,8,16,0,0,368,8,16,0,0,384,8,16,0,0,400,8,16,0,0,416,8,16,0,0,432,8,16,0,0,448,8,16,0,0,464,8,16,0,0,480,8,16,0,0,496,8,16,0,0,512,8,16,0,0,528,8,16,0,0,544,8,16,0,0,560,8,16,0,0,576,8,16,0,0,592,8,16,0,0,608,8,16,0,0,624,8,16,0,0,640,8,16,0,0,656,8,16,0,0,672,8,16,0,0,688,8,16,0,0,704,8,16,0,0,720,8,16,0,0,736,8,16,0,0,752,8,16,0,0,768,8,16,0,0,784,8,16,0,0,800,8,16,0,0,816,8,16,0,0,832,8,16,0,0,848,8,16,0,0,864,8,16,0,0,880,8,16,0,0,896,8,16,0,0,912,8,16,0,0,928,8,16,0,0,944,8,16,0,0,960,8,16,0,0,976,8,16,0,0,992,8,16,0,0,1008,8,16,0,0,1024,8,16,0,0,1040,8,16,0,0,1056,8,16,0,0,1072,8,16,0,0,1088,8,16,0,0,1104,8,16,0,0,1120,8,16,0,0,1136,8,16,0,0,1152,8,16,0,0,1168,8,16,0,0,1184,8,16,0,0,1200,8,16,0,0,1216,8,16,0,0,1232,8,16,0,0,1248,8,16,0,0,1264,8,16,0,0,1280,8,16,0,0,1296,8,16,0,0,1312,8,16,0,0,1328,8,16,0,0,1344,8,16,0,0,1360,8,16,0,0,1376,8,16,0,0,1392,8,16,0,0,1408,8,16,0,0,1424,8,16,0,0,1440,8,16,0,0,1456,8,16,0,0,1472,8,16,0,0,1488,8,16,0,0,1504,8,16,0,0,1520,8,16,0,0,1536,8,16,0,0,1552,8,16,0,0,1568,8,16,0,0,1584,8,16,0,0,1600,8,16,0,0,1616,8,16,0,0,1632,8,16,0,0,1648,8,16,0,0,1664,8,16,0,0,1680,8,16,0,0,1696,8,16,0,0,1712,8,16,0,0,1728,8,16,0,0,1744,8,16,0,0,1760,8,16,0,0,1776,8,16,0,0,1792,8,16,0,0,1808,8,16,0,0,1824,8,16,0,0,1840,8,16,0,0,1856,8,16,0,0,1872,8,16,0,0,1888,8,16,0,0,1904,8,16,0,0,1920,8,16,0,0,1936,8,16,0,0,1952,8,16,0,0,1968,8,16,0,0,1984,8,16,0,0,2000,8,16,0,0,2016,8,16,0,0,2032,8,16,0,0,2048,8,16,0,0,2064,8,16,0,0,2080,8,16,0,0,2096,8,16,0,0,2112,8,16,0,0,2128,8,16,0,0,2144,8,16,0,0,2160,8,16,0,0,2176,8,16,0,0,2192,8,16,0,0,2208,8,16,0,0,2224,8,16,0,0,2240,8,16,0,0,2256,8,16,0,0,2272,8,16,0,0,2288,8,16,0,0,2304,8,16,0,0,2320,8,16,0,0,2336,8,16,0,0,2352,8,16,0,0,2368,8,16,0,0,2384,8,16,0,0,2400,8,16,0,0,2416,8,16,0,0,2432,8,16,0,0,2448,8,16,0,0,2464,8,16,0,0,2480,8,16,0,0,2496,8,16,0,0,2512,8,16,0,0,2528,8,16,0,0,2544,8,16,0,0,2560,8,16,0,0,2576,8,16,0,0,2592,8,16,0,0,2608,8,16,0,0,2624,8,16,0,0,2640,8,16,0,0,2656,8,16,0,0,2672,8,16,0,0,2688,8,16,0,0,2704,8,16,0,0,2720,8,16,0,0,2736,8,16,0,0,2752,8,16,0,0,2768,8,16,0,0,2784,8,16,0,0,2800,8,16,0,0,2816,8,16,0,0,2832,8,16,0,0,2848,8,16,0,0,2864,8,16,0,0,2880,8,16,0,0,2896,8,16,0,0,2912,8,16,0,0,2928,8,16,0,0,2944,8,16,0,0,2960,8,16,0,0,2976,8,16,0,0,2992,8,16,0,0,3008,8,16,0,0,3024,8,16,0,0,3040,8,16,0,0,3056,8,16,0,0,3072,8,16,0,0,3088,8,16,0,0,3104,8,16,0,0,3120,8,16,0,0,3136,8,16,0,0,3152,8,16,0,0,3168,8,16,0,0,3184,8,16,0,0,3200,8,16,0,0,3216,8,16,0,0,3232,8,16,0,0,3248,8,16,0,0,3264,8,16,0,0,3280,8,16,0,0,3296,8,16,0,0,3312,8,16,0,0,3328,8,16,0,0,3344,8,16,0,0,3360,8,16,0,0,3376,8,16,0,0,3392,8,16,0,0,3408,8,16,0,0,3424,8,16,0,0,3440,8,16,0,0,3456,8,16,0,0,3472,8,16,0,0,3488,8,16,0,0,3504,8,16,0,0,3520,8,16,0,0,3536,8,16,0,0,3552,8,16,0,0,3568,8,16,0,0,3584,8,16,0,0,3600,8,16,0,0,3616,8,16,0,0,3632,8,16,0,0,3648,8,16,0,0,3664,8,16,0,0,3680,8,16,0,0,3696,8,16,0,0,3712,8,16,0,0,3728,8,16,0,0,3744,8,16,0,0,3760,8,16,0,0,3776,8,16,0,0,3792,8,16,0,0,3808,8,16,0,0,3824,8,16,0,0,3840,8,16,0,0,3856,8,16,0,0,3872,8,16,0,0,3888,8,16,0,0,3904,8,16,0,0,3920,8,16,0,0,3936,8,16,0,0,3952,8,16,0,0,3968,8,16,0,0,3984,8,16,0,0,4000,8,16,0,0,4016,8,16,0,0,4032,8,16,0,0,4048,8,16,0,0,4064,8,16,0,0,4080,8,16,0,0,};
-static rfbFontData default8x16Font = { default8x16FontData, default8x16FontMetaData };
diff --git a/libvncserver/rfb/keysym.h b/libvncserver/rfb/keysym.h
deleted file mode 100644
index 219f95b..0000000
--- a/libvncserver/rfb/keysym.h
+++ /dev/null
@@ -1,1638 +0,0 @@
-#ifndef XK_0
-
-/* $XConsortium: keysym.h,v 1.15 94/04/17 20:10:55 rws Exp $ */
-
-/***********************************************************
-
-Copyright (c) 1987  X Consortium
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of the X Consortium shall not be
-used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization from the X Consortium.
-
-
-Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
-
-                        All Rights Reserved
-
-Permission to use, copy, modify, and distribute this software and its 
-documentation for any purpose and without fee is hereby granted, 
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in 
-supporting documentation, and that the name of Digital not be
-used in advertising or publicity pertaining to distribution of the
-software without specific, written prior permission.  
-
-DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
-ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
-DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
-ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-SOFTWARE.
-
-******************************************************************/
-
-/* default keysyms */
-#define XK_MISCELLANY
-#define XK_XKB_KEYS
-#define XK_LATIN1
-#define XK_LATIN2
-#define XK_LATIN3
-#define XK_LATIN4
-#define XK_GREEK
-
-/* $TOG: keysymdef.h /main/25 1997/06/21 10:54:51 kaleb $ */
-
-/***********************************************************
-Copyright (c) 1987, 1994  X Consortium
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
-OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of the X Consortium shall
-not be used in advertising or otherwise to promote the sale, use or
-other dealings in this Software without prior written authorization
-from the X Consortium.
-
-
-Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts
-
-                        All Rights Reserved
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for any purpose and without fee is hereby granted,
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in
-supporting documentation, and that the name of Digital not be
-used in advertising or publicity pertaining to distribution of the
-software without specific, written prior permission.
-
-DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
-ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
-DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
-ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-SOFTWARE.
-
-******************************************************************/
-
-#define XK_VoidSymbol		0xFFFFFF	/* void symbol */
-
-#ifdef XK_MISCELLANY
-/*
- * TTY Functions, cleverly chosen to map to ascii, for convenience of
- * programming, but could have been arbitrary (at the cost of lookup
- * tables in client code.
- */
-
-#define XK_BackSpace		0xFF08	/* back space, back char */
-#define XK_Tab			0xFF09
-#define XK_Linefeed		0xFF0A	/* Linefeed, LF */
-#define XK_Clear		0xFF0B
-#define XK_Return		0xFF0D	/* Return, enter */
-#define XK_Pause		0xFF13	/* Pause, hold */
-#define XK_Scroll_Lock		0xFF14
-#define XK_Sys_Req		0xFF15
-#define XK_Escape		0xFF1B
-#define XK_Delete		0xFFFF	/* Delete, rubout */
-
-
-
-/* International & multi-key character composition */
-
-#define XK_Multi_key		0xFF20  /* Multi-key character compose */
-#define XK_SingleCandidate	0xFF3C
-#define XK_MultipleCandidate	0xFF3D
-#define XK_PreviousCandidate	0xFF3E
-
-/* Japanese keyboard support */
-
-#define XK_Kanji		0xFF21	/* Kanji, Kanji convert */
-#define XK_Muhenkan		0xFF22  /* Cancel Conversion */
-#define XK_Henkan_Mode		0xFF23  /* Start/Stop Conversion */
-#define XK_Henkan		0xFF23  /* Alias for Henkan_Mode */
-#define XK_Romaji		0xFF24  /* to Romaji */
-#define XK_Hiragana		0xFF25  /* to Hiragana */
-#define XK_Katakana		0xFF26  /* to Katakana */
-#define XK_Hiragana_Katakana	0xFF27  /* Hiragana/Katakana toggle */
-#define XK_Zenkaku		0xFF28  /* to Zenkaku */
-#define XK_Hankaku		0xFF29  /* to Hankaku */
-#define XK_Zenkaku_Hankaku	0xFF2A  /* Zenkaku/Hankaku toggle */
-#define XK_Touroku		0xFF2B  /* Add to Dictionary */
-#define XK_Massyo		0xFF2C  /* Delete from Dictionary */
-#define XK_Kana_Lock		0xFF2D  /* Kana Lock */
-#define XK_Kana_Shift		0xFF2E  /* Kana Shift */
-#define XK_Eisu_Shift		0xFF2F  /* Alphanumeric Shift */
-#define XK_Eisu_toggle		0xFF30  /* Alphanumeric toggle */
-#define XK_Zen_Koho		0xFF3D	/* Multiple/All Candidate(s) */
-#define XK_Mae_Koho		0xFF3E	/* Previous Candidate */
-
-/* 0xFF31 thru 0xFF3F are under XK_KOREAN */
-
-/* Cursor control & motion */
-
-#define XK_Home			0xFF50
-#define XK_Left			0xFF51	/* Move left, left arrow */
-#define XK_Up			0xFF52	/* Move up, up arrow */
-#define XK_Right		0xFF53	/* Move right, right arrow */
-#define XK_Down			0xFF54	/* Move down, down arrow */
-#define XK_Prior		0xFF55	/* Prior, previous */
-#define XK_Page_Up		0xFF55
-#define XK_Next			0xFF56	/* Next */
-#define XK_Page_Down		0xFF56
-#define XK_End			0xFF57	/* EOL */
-#define XK_Begin		0xFF58	/* BOL */
-
-
-/* Misc Functions */
-
-#define XK_Select		0xFF60	/* Select, mark */
-#define XK_Print		0xFF61
-#define XK_Execute		0xFF62	/* Execute, run, do */
-#define XK_Insert		0xFF63	/* Insert, insert here */
-#define XK_Undo			0xFF65	/* Undo, oops */
-#define XK_Redo			0xFF66	/* redo, again */
-#define XK_Menu			0xFF67
-#define XK_Find			0xFF68	/* Find, search */
-#define XK_Cancel		0xFF69	/* Cancel, stop, abort, exit */
-#define XK_Help			0xFF6A	/* Help */
-#define XK_Break		0xFF6B
-#define XK_Mode_switch		0xFF7E	/* Character set switch */
-#define XK_script_switch        0xFF7E  /* Alias for mode_switch */
-#define XK_Num_Lock		0xFF7F
-
-/* Keypad Functions, keypad numbers cleverly chosen to map to ascii */
-
-#define XK_KP_Space		0xFF80	/* space */
-#define XK_KP_Tab		0xFF89
-#define XK_KP_Enter		0xFF8D	/* enter */
-#define XK_KP_F1		0xFF91	/* PF1, KP_A, ... */
-#define XK_KP_F2		0xFF92
-#define XK_KP_F3		0xFF93
-#define XK_KP_F4		0xFF94
-#define XK_KP_Home		0xFF95
-#define XK_KP_Left		0xFF96
-#define XK_KP_Up		0xFF97
-#define XK_KP_Right		0xFF98
-#define XK_KP_Down		0xFF99
-#define XK_KP_Prior		0xFF9A
-#define XK_KP_Page_Up		0xFF9A
-#define XK_KP_Next		0xFF9B
-#define XK_KP_Page_Down		0xFF9B
-#define XK_KP_End		0xFF9C
-#define XK_KP_Begin		0xFF9D
-#define XK_KP_Insert		0xFF9E
-#define XK_KP_Delete		0xFF9F
-#define XK_KP_Equal		0xFFBD	/* equals */
-#define XK_KP_Multiply		0xFFAA
-#define XK_KP_Add		0xFFAB
-#define XK_KP_Separator		0xFFAC	/* separator, often comma */
-#define XK_KP_Subtract		0xFFAD
-#define XK_KP_Decimal		0xFFAE
-#define XK_KP_Divide		0xFFAF
-
-#define XK_KP_0			0xFFB0
-#define XK_KP_1			0xFFB1
-#define XK_KP_2			0xFFB2
-#define XK_KP_3			0xFFB3
-#define XK_KP_4			0xFFB4
-#define XK_KP_5			0xFFB5
-#define XK_KP_6			0xFFB6
-#define XK_KP_7			0xFFB7
-#define XK_KP_8			0xFFB8
-#define XK_KP_9			0xFFB9
-
-
-
-/*
- * Auxilliary Functions; note the duplicate definitions for left and right
- * function keys;  Sun keyboards and a few other manufactures have such
- * function key groups on the left and/or right sides of the keyboard.
- * We've not found a keyboard with more than 35 function keys total.
- */
-
-#define XK_F1			0xFFBE
-#define XK_F2			0xFFBF
-#define XK_F3			0xFFC0
-#define XK_F4			0xFFC1
-#define XK_F5			0xFFC2
-#define XK_F6			0xFFC3
-#define XK_F7			0xFFC4
-#define XK_F8			0xFFC5
-#define XK_F9			0xFFC6
-#define XK_F10			0xFFC7
-#define XK_F11			0xFFC8
-#define XK_L1			0xFFC8
-#define XK_F12			0xFFC9
-#define XK_L2			0xFFC9
-#define XK_F13			0xFFCA
-#define XK_L3			0xFFCA
-#define XK_F14			0xFFCB
-#define XK_L4			0xFFCB
-#define XK_F15			0xFFCC
-#define XK_L5			0xFFCC
-#define XK_F16			0xFFCD
-#define XK_L6			0xFFCD
-#define XK_F17			0xFFCE
-#define XK_L7			0xFFCE
-#define XK_F18			0xFFCF
-#define XK_L8			0xFFCF
-#define XK_F19			0xFFD0
-#define XK_L9			0xFFD0
-#define XK_F20			0xFFD1
-#define XK_L10			0xFFD1
-#define XK_F21			0xFFD2
-#define XK_R1			0xFFD2
-#define XK_F22			0xFFD3
-#define XK_R2			0xFFD3
-#define XK_F23			0xFFD4
-#define XK_R3			0xFFD4
-#define XK_F24			0xFFD5
-#define XK_R4			0xFFD5
-#define XK_F25			0xFFD6
-#define XK_R5			0xFFD6
-#define XK_F26			0xFFD7
-#define XK_R6			0xFFD7
-#define XK_F27			0xFFD8
-#define XK_R7			0xFFD8
-#define XK_F28			0xFFD9
-#define XK_R8			0xFFD9
-#define XK_F29			0xFFDA
-#define XK_R9			0xFFDA
-#define XK_F30			0xFFDB
-#define XK_R10			0xFFDB
-#define XK_F31			0xFFDC
-#define XK_R11			0xFFDC
-#define XK_F32			0xFFDD
-#define XK_R12			0xFFDD
-#define XK_F33			0xFFDE
-#define XK_R13			0xFFDE
-#define XK_F34			0xFFDF
-#define XK_R14			0xFFDF
-#define XK_F35			0xFFE0
-#define XK_R15			0xFFE0
-
-/* Modifiers */
-
-#define XK_Shift_L		0xFFE1	/* Left shift */
-#define XK_Shift_R		0xFFE2	/* Right shift */
-#define XK_Control_L		0xFFE3	/* Left control */
-#define XK_Control_R		0xFFE4	/* Right control */
-#define XK_Caps_Lock		0xFFE5	/* Caps lock */
-#define XK_Shift_Lock		0xFFE6	/* Shift lock */
-
-#define XK_Meta_L		0xFFE7	/* Left meta */
-#define XK_Meta_R		0xFFE8	/* Right meta */
-#define XK_Alt_L		0xFFE9	/* Left alt */
-#define XK_Alt_R		0xFFEA	/* Right alt */
-#define XK_Super_L		0xFFEB	/* Left super */
-#define XK_Super_R		0xFFEC	/* Right super */
-#define XK_Hyper_L		0xFFED	/* Left hyper */
-#define XK_Hyper_R		0xFFEE	/* Right hyper */
-#endif /* XK_MISCELLANY */
-
-/*
- * ISO 9995 Function and Modifier Keys
- * Byte 3 = 0xFE
- */
-
-#ifdef XK_XKB_KEYS
-#define	XK_ISO_Lock					0xFE01
-#define	XK_ISO_Level2_Latch				0xFE02
-#define	XK_ISO_Level3_Shift				0xFE03
-#define	XK_ISO_Level3_Latch				0xFE04
-#define	XK_ISO_Level3_Lock				0xFE05
-#define	XK_ISO_Group_Shift		0xFF7E	/* Alias for mode_switch */
-#define	XK_ISO_Group_Latch				0xFE06
-#define	XK_ISO_Group_Lock				0xFE07
-#define	XK_ISO_Next_Group				0xFE08
-#define	XK_ISO_Next_Group_Lock				0xFE09
-#define	XK_ISO_Prev_Group				0xFE0A
-#define	XK_ISO_Prev_Group_Lock				0xFE0B
-#define	XK_ISO_First_Group				0xFE0C
-#define	XK_ISO_First_Group_Lock				0xFE0D
-#define	XK_ISO_Last_Group				0xFE0E
-#define	XK_ISO_Last_Group_Lock				0xFE0F
-
-#define	XK_ISO_Left_Tab					0xFE20
-#define	XK_ISO_Move_Line_Up				0xFE21
-#define	XK_ISO_Move_Line_Down				0xFE22
-#define	XK_ISO_Partial_Line_Up				0xFE23
-#define	XK_ISO_Partial_Line_Down			0xFE24
-#define	XK_ISO_Partial_Space_Left			0xFE25
-#define	XK_ISO_Partial_Space_Right			0xFE26
-#define	XK_ISO_Set_Margin_Left				0xFE27
-#define	XK_ISO_Set_Margin_Right				0xFE28
-#define	XK_ISO_Release_Margin_Left			0xFE29
-#define	XK_ISO_Release_Margin_Right			0xFE2A
-#define	XK_ISO_Release_Both_Margins			0xFE2B
-#define	XK_ISO_Fast_Cursor_Left				0xFE2C
-#define	XK_ISO_Fast_Cursor_Right			0xFE2D
-#define	XK_ISO_Fast_Cursor_Up				0xFE2E
-#define	XK_ISO_Fast_Cursor_Down				0xFE2F
-#define	XK_ISO_Continuous_Underline			0xFE30
-#define	XK_ISO_Discontinuous_Underline			0xFE31
-#define	XK_ISO_Emphasize				0xFE32
-#define	XK_ISO_Center_Object				0xFE33
-#define	XK_ISO_Enter					0xFE34
-
-#define	XK_dead_grave					0xFE50
-#define	XK_dead_acute					0xFE51
-#define	XK_dead_circumflex				0xFE52
-#define	XK_dead_tilde					0xFE53
-#define	XK_dead_macron					0xFE54
-#define	XK_dead_breve					0xFE55
-#define	XK_dead_abovedot				0xFE56
-#define	XK_dead_diaeresis				0xFE57
-#define	XK_dead_abovering				0xFE58
-#define	XK_dead_doubleacute				0xFE59
-#define	XK_dead_caron					0xFE5A
-#define	XK_dead_cedilla					0xFE5B
-#define	XK_dead_ogonek					0xFE5C
-#define	XK_dead_iota					0xFE5D
-#define	XK_dead_voiced_sound				0xFE5E
-#define	XK_dead_semivoiced_sound			0xFE5F
-#define	XK_dead_belowdot				0xFE60
-
-#define	XK_First_Virtual_Screen				0xFED0
-#define	XK_Prev_Virtual_Screen				0xFED1
-#define	XK_Next_Virtual_Screen				0xFED2
-#define	XK_Last_Virtual_Screen				0xFED4
-#define	XK_Terminate_Server				0xFED5
-
-#define	XK_AccessX_Enable				0xFE70
-#define	XK_AccessX_Feedback_Enable			0xFE71
-#define	XK_RepeatKeys_Enable				0xFE72
-#define	XK_SlowKeys_Enable				0xFE73
-#define	XK_BounceKeys_Enable				0xFE74
-#define	XK_StickyKeys_Enable				0xFE75
-#define	XK_MouseKeys_Enable				0xFE76
-#define	XK_MouseKeys_Accel_Enable			0xFE77
-#define	XK_Overlay1_Enable				0xFE78
-#define	XK_Overlay2_Enable				0xFE79
-#define	XK_AudibleBell_Enable				0xFE7A
-
-#define	XK_Pointer_Left					0xFEE0
-#define	XK_Pointer_Right				0xFEE1
-#define	XK_Pointer_Up					0xFEE2
-#define	XK_Pointer_Down					0xFEE3
-#define	XK_Pointer_UpLeft				0xFEE4
-#define	XK_Pointer_UpRight				0xFEE5
-#define	XK_Pointer_DownLeft				0xFEE6
-#define	XK_Pointer_DownRight				0xFEE7
-#define	XK_Pointer_Button_Dflt				0xFEE8
-#define	XK_Pointer_Button1				0xFEE9
-#define	XK_Pointer_Button2				0xFEEA
-#define	XK_Pointer_Button3				0xFEEB
-#define	XK_Pointer_Button4				0xFEEC
-#define	XK_Pointer_Button5				0xFEED
-#define	XK_Pointer_DblClick_Dflt			0xFEEE
-#define	XK_Pointer_DblClick1				0xFEEF
-#define	XK_Pointer_DblClick2				0xFEF0
-#define	XK_Pointer_DblClick3				0xFEF1
-#define	XK_Pointer_DblClick4				0xFEF2
-#define	XK_Pointer_DblClick5				0xFEF3
-#define	XK_Pointer_Drag_Dflt				0xFEF4
-#define	XK_Pointer_Drag1				0xFEF5
-#define	XK_Pointer_Drag2				0xFEF6
-#define	XK_Pointer_Drag3				0xFEF7
-#define	XK_Pointer_Drag4				0xFEF8
-#define	XK_Pointer_Drag5				0xFEFD
-
-#define	XK_Pointer_EnableKeys				0xFEF9
-#define	XK_Pointer_Accelerate				0xFEFA
-#define	XK_Pointer_DfltBtnNext				0xFEFB
-#define	XK_Pointer_DfltBtnPrev				0xFEFC
-
-#endif
-
-/*
- * 3270 Terminal Keys
- * Byte 3 = 0xFD
- */
-
-#ifdef XK_3270
-#define XK_3270_Duplicate      0xFD01
-#define XK_3270_FieldMark      0xFD02
-#define XK_3270_Right2         0xFD03
-#define XK_3270_Left2          0xFD04
-#define XK_3270_BackTab        0xFD05
-#define XK_3270_EraseEOF       0xFD06
-#define XK_3270_EraseInput     0xFD07
-#define XK_3270_Reset          0xFD08
-#define XK_3270_Quit           0xFD09
-#define XK_3270_PA1            0xFD0A
-#define XK_3270_PA2            0xFD0B
-#define XK_3270_PA3            0xFD0C
-#define XK_3270_Test           0xFD0D
-#define XK_3270_Attn           0xFD0E
-#define XK_3270_CursorBlink    0xFD0F
-#define XK_3270_AltCursor      0xFD10
-#define XK_3270_KeyClick       0xFD11
-#define XK_3270_Jump           0xFD12
-#define XK_3270_Ident          0xFD13
-#define XK_3270_Rule           0xFD14
-#define XK_3270_Copy           0xFD15
-#define XK_3270_Play           0xFD16
-#define XK_3270_Setup          0xFD17
-#define XK_3270_Record         0xFD18
-#define XK_3270_ChangeScreen   0xFD19
-#define XK_3270_DeleteWord     0xFD1A
-#define XK_3270_ExSelect       0xFD1B
-#define XK_3270_CursorSelect   0xFD1C
-#define XK_3270_PrintScreen    0xFD1D
-#define XK_3270_Enter          0xFD1E
-#endif
-
-/*
- *  Latin 1
- *  Byte 3 = 0
- */
-#ifdef XK_LATIN1
-#define XK_space               0x020
-#define XK_exclam              0x021
-#define XK_quotedbl            0x022
-#define XK_numbersign          0x023
-#define XK_dollar              0x024
-#define XK_percent             0x025
-#define XK_ampersand           0x026
-#define XK_apostrophe          0x027
-#define XK_quoteright          0x027	/* deprecated */
-#define XK_parenleft           0x028
-#define XK_parenright          0x029
-#define XK_asterisk            0x02a
-#define XK_plus                0x02b
-#define XK_comma               0x02c
-#define XK_minus               0x02d
-#define XK_period              0x02e
-#define XK_slash               0x02f
-#define XK_0                   0x030
-#define XK_1                   0x031
-#define XK_2                   0x032
-#define XK_3                   0x033
-#define XK_4                   0x034
-#define XK_5                   0x035
-#define XK_6                   0x036
-#define XK_7                   0x037
-#define XK_8                   0x038
-#define XK_9                   0x039
-#define XK_colon               0x03a
-#define XK_semicolon           0x03b
-#define XK_less                0x03c
-#define XK_equal               0x03d
-#define XK_greater             0x03e
-#define XK_question            0x03f
-#define XK_at                  0x040
-#define XK_A                   0x041
-#define XK_B                   0x042
-#define XK_C                   0x043
-#define XK_D                   0x044
-#define XK_E                   0x045
-#define XK_F                   0x046
-#define XK_G                   0x047
-#define XK_H                   0x048
-#define XK_I                   0x049
-#define XK_J                   0x04a
-#define XK_K                   0x04b
-#define XK_L                   0x04c
-#define XK_M                   0x04d
-#define XK_N                   0x04e
-#define XK_O                   0x04f
-#define XK_P                   0x050
-#define XK_Q                   0x051
-#define XK_R                   0x052
-#define XK_S                   0x053
-#define XK_T                   0x054
-#define XK_U                   0x055
-#define XK_V                   0x056
-#define XK_W                   0x057
-#define XK_X                   0x058
-#define XK_Y                   0x059
-#define XK_Z                   0x05a
-#define XK_bracketleft         0x05b
-#define XK_backslash           0x05c
-#define XK_bracketright        0x05d
-#define XK_asciicircum         0x05e
-#define XK_underscore          0x05f
-#define XK_grave               0x060
-#define XK_quoteleft           0x060	/* deprecated */
-#define XK_a                   0x061
-#define XK_b                   0x062
-#define XK_c                   0x063
-#define XK_d                   0x064
-#define XK_e                   0x065
-#define XK_f                   0x066
-#define XK_g                   0x067
-#define XK_h                   0x068
-#define XK_i                   0x069
-#define XK_j                   0x06a
-#define XK_k                   0x06b
-#define XK_l                   0x06c
-#define XK_m                   0x06d
-#define XK_n                   0x06e
-#define XK_o                   0x06f
-#define XK_p                   0x070
-#define XK_q                   0x071
-#define XK_r                   0x072
-#define XK_s                   0x073
-#define XK_t                   0x074
-#define XK_u                   0x075
-#define XK_v                   0x076
-#define XK_w                   0x077
-#define XK_x                   0x078
-#define XK_y                   0x079
-#define XK_z                   0x07a
-#define XK_braceleft           0x07b
-#define XK_bar                 0x07c
-#define XK_braceright          0x07d
-#define XK_asciitilde          0x07e
-
-#define XK_nobreakspace        0x0a0
-#define XK_exclamdown          0x0a1
-#define XK_cent        	       0x0a2
-#define XK_sterling            0x0a3
-#define XK_currency            0x0a4
-#define XK_yen                 0x0a5
-#define XK_brokenbar           0x0a6
-#define XK_section             0x0a7
-#define XK_diaeresis           0x0a8
-#define XK_copyright           0x0a9
-#define XK_ordfeminine         0x0aa
-#define XK_guillemotleft       0x0ab	/* left angle quotation mark */
-#define XK_notsign             0x0ac
-#define XK_hyphen              0x0ad
-#define XK_registered          0x0ae
-#define XK_macron              0x0af
-#define XK_degree              0x0b0
-#define XK_plusminus           0x0b1
-#define XK_twosuperior         0x0b2
-#define XK_threesuperior       0x0b3
-#define XK_acute               0x0b4
-#define XK_mu                  0x0b5
-#define XK_paragraph           0x0b6
-#define XK_periodcentered      0x0b7
-#define XK_cedilla             0x0b8
-#define XK_onesuperior         0x0b9
-#define XK_masculine           0x0ba
-#define XK_guillemotright      0x0bb	/* right angle quotation mark */
-#define XK_onequarter          0x0bc
-#define XK_onehalf             0x0bd
-#define XK_threequarters       0x0be
-#define XK_questiondown        0x0bf
-#define XK_Agrave              0x0c0
-#define XK_Aacute              0x0c1
-#define XK_Acircumflex         0x0c2
-#define XK_Atilde              0x0c3
-#define XK_Adiaeresis          0x0c4
-#define XK_Aring               0x0c5
-#define XK_AE                  0x0c6
-#define XK_Ccedilla            0x0c7
-#define XK_Egrave              0x0c8
-#define XK_Eacute              0x0c9
-#define XK_Ecircumflex         0x0ca
-#define XK_Ediaeresis          0x0cb
-#define XK_Igrave              0x0cc
-#define XK_Iacute              0x0cd
-#define XK_Icircumflex         0x0ce
-#define XK_Idiaeresis          0x0cf
-#define XK_ETH                 0x0d0
-#define XK_Eth                 0x0d0	/* deprecated */
-#define XK_Ntilde              0x0d1
-#define XK_Ograve              0x0d2
-#define XK_Oacute              0x0d3
-#define XK_Ocircumflex         0x0d4
-#define XK_Otilde              0x0d5
-#define XK_Odiaeresis          0x0d6
-#define XK_multiply            0x0d7
-#define XK_Ooblique            0x0d8
-#define XK_Ugrave              0x0d9
-#define XK_Uacute              0x0da
-#define XK_Ucircumflex         0x0db
-#define XK_Udiaeresis          0x0dc
-#define XK_Yacute              0x0dd
-#define XK_THORN               0x0de
-#define XK_Thorn               0x0de	/* deprecated */
-#define XK_ssharp              0x0df
-#define XK_agrave              0x0e0
-#define XK_aacute              0x0e1
-#define XK_acircumflex         0x0e2
-#define XK_atilde              0x0e3
-#define XK_adiaeresis          0x0e4
-#define XK_aring               0x0e5
-#define XK_ae                  0x0e6
-#define XK_ccedilla            0x0e7
-#define XK_egrave              0x0e8
-#define XK_eacute              0x0e9
-#define XK_ecircumflex         0x0ea
-#define XK_ediaeresis          0x0eb
-#define XK_igrave              0x0ec
-#define XK_iacute              0x0ed
-#define XK_icircumflex         0x0ee
-#define XK_idiaeresis          0x0ef
-#define XK_eth                 0x0f0
-#define XK_ntilde              0x0f1
-#define XK_ograve              0x0f2
-#define XK_oacute              0x0f3
-#define XK_ocircumflex         0x0f4
-#define XK_otilde              0x0f5
-#define XK_odiaeresis          0x0f6
-#define XK_division            0x0f7
-#define XK_oslash              0x0f8
-#define XK_ugrave              0x0f9
-#define XK_uacute              0x0fa
-#define XK_ucircumflex         0x0fb
-#define XK_udiaeresis          0x0fc
-#define XK_yacute              0x0fd
-#define XK_thorn               0x0fe
-#define XK_ydiaeresis          0x0ff
-#endif /* XK_LATIN1 */
-
-/*
- *   Latin 2
- *   Byte 3 = 1
- */
-
-#ifdef XK_LATIN2
-#define XK_Aogonek             0x1a1
-#define XK_breve               0x1a2
-#define XK_Lstroke             0x1a3
-#define XK_Lcaron              0x1a5
-#define XK_Sacute              0x1a6
-#define XK_Scaron              0x1a9
-#define XK_Scedilla            0x1aa
-#define XK_Tcaron              0x1ab
-#define XK_Zacute              0x1ac
-#define XK_Zcaron              0x1ae
-#define XK_Zabovedot           0x1af
-#define XK_aogonek             0x1b1
-#define XK_ogonek              0x1b2
-#define XK_lstroke             0x1b3
-#define XK_lcaron              0x1b5
-#define XK_sacute              0x1b6
-#define XK_caron               0x1b7
-#define XK_scaron              0x1b9
-#define XK_scedilla            0x1ba
-#define XK_tcaron              0x1bb
-#define XK_zacute              0x1bc
-#define XK_doubleacute         0x1bd
-#define XK_zcaron              0x1be
-#define XK_zabovedot           0x1bf
-#define XK_Racute              0x1c0
-#define XK_Abreve              0x1c3
-#define XK_Lacute              0x1c5
-#define XK_Cacute              0x1c6
-#define XK_Ccaron              0x1c8
-#define XK_Eogonek             0x1ca
-#define XK_Ecaron              0x1cc
-#define XK_Dcaron              0x1cf
-#define XK_Dstroke             0x1d0
-#define XK_Nacute              0x1d1
-#define XK_Ncaron              0x1d2
-#define XK_Odoubleacute        0x1d5
-#define XK_Rcaron              0x1d8
-#define XK_Uring               0x1d9
-#define XK_Udoubleacute        0x1db
-#define XK_Tcedilla            0x1de
-#define XK_racute              0x1e0
-#define XK_abreve              0x1e3
-#define XK_lacute              0x1e5
-#define XK_cacute              0x1e6
-#define XK_ccaron              0x1e8
-#define XK_eogonek             0x1ea
-#define XK_ecaron              0x1ec
-#define XK_dcaron              0x1ef
-#define XK_dstroke             0x1f0
-#define XK_nacute              0x1f1
-#define XK_ncaron              0x1f2
-#define XK_odoubleacute        0x1f5
-#define XK_udoubleacute        0x1fb
-#define XK_rcaron              0x1f8
-#define XK_uring               0x1f9
-#define XK_tcedilla            0x1fe
-#define XK_abovedot            0x1ff
-#endif /* XK_LATIN2 */
-
-/*
- *   Latin 3
- *   Byte 3 = 2
- */
-
-#ifdef XK_LATIN3
-#define XK_Hstroke             0x2a1
-#define XK_Hcircumflex         0x2a6
-#define XK_Iabovedot           0x2a9
-#define XK_Gbreve              0x2ab
-#define XK_Jcircumflex         0x2ac
-#define XK_hstroke             0x2b1
-#define XK_hcircumflex         0x2b6
-#define XK_idotless            0x2b9
-#define XK_gbreve              0x2bb
-#define XK_jcircumflex         0x2bc
-#define XK_Cabovedot           0x2c5
-#define XK_Ccircumflex         0x2c6
-#define XK_Gabovedot           0x2d5
-#define XK_Gcircumflex         0x2d8
-#define XK_Ubreve              0x2dd
-#define XK_Scircumflex         0x2de
-#define XK_cabovedot           0x2e5
-#define XK_ccircumflex         0x2e6
-#define XK_gabovedot           0x2f5
-#define XK_gcircumflex         0x2f8
-#define XK_ubreve              0x2fd
-#define XK_scircumflex         0x2fe
-#endif /* XK_LATIN3 */
-
-
-/*
- *   Latin 4
- *   Byte 3 = 3
- */
-
-#ifdef XK_LATIN4
-#define XK_kra                 0x3a2
-#define XK_kappa               0x3a2	/* deprecated */
-#define XK_Rcedilla            0x3a3
-#define XK_Itilde              0x3a5
-#define XK_Lcedilla            0x3a6
-#define XK_Emacron             0x3aa
-#define XK_Gcedilla            0x3ab
-#define XK_Tslash              0x3ac
-#define XK_rcedilla            0x3b3
-#define XK_itilde              0x3b5
-#define XK_lcedilla            0x3b6
-#define XK_emacron             0x3ba
-#define XK_gcedilla            0x3bb
-#define XK_tslash              0x3bc
-#define XK_ENG                 0x3bd
-#define XK_eng                 0x3bf
-#define XK_Amacron             0x3c0
-#define XK_Iogonek             0x3c7
-#define XK_Eabovedot           0x3cc
-#define XK_Imacron             0x3cf
-#define XK_Ncedilla            0x3d1
-#define XK_Omacron             0x3d2
-#define XK_Kcedilla            0x3d3
-#define XK_Uogonek             0x3d9
-#define XK_Utilde              0x3dd
-#define XK_Umacron             0x3de
-#define XK_amacron             0x3e0
-#define XK_iogonek             0x3e7
-#define XK_eabovedot           0x3ec
-#define XK_imacron             0x3ef
-#define XK_ncedilla            0x3f1
-#define XK_omacron             0x3f2
-#define XK_kcedilla            0x3f3
-#define XK_uogonek             0x3f9
-#define XK_utilde              0x3fd
-#define XK_umacron             0x3fe
-#endif /* XK_LATIN4 */
-
-/*
- * Katakana
- * Byte 3 = 4
- */
-
-#ifdef XK_KATAKANA
-#define XK_overline				       0x47e
-#define XK_kana_fullstop                               0x4a1
-#define XK_kana_openingbracket                         0x4a2
-#define XK_kana_closingbracket                         0x4a3
-#define XK_kana_comma                                  0x4a4
-#define XK_kana_conjunctive                            0x4a5
-#define XK_kana_middledot                              0x4a5  /* deprecated */
-#define XK_kana_WO                                     0x4a6
-#define XK_kana_a                                      0x4a7
-#define XK_kana_i                                      0x4a8
-#define XK_kana_u                                      0x4a9
-#define XK_kana_e                                      0x4aa
-#define XK_kana_o                                      0x4ab
-#define XK_kana_ya                                     0x4ac
-#define XK_kana_yu                                     0x4ad
-#define XK_kana_yo                                     0x4ae
-#define XK_kana_tsu                                    0x4af
-#define XK_kana_tu                                     0x4af  /* deprecated */
-#define XK_prolongedsound                              0x4b0
-#define XK_kana_A                                      0x4b1
-#define XK_kana_I                                      0x4b2
-#define XK_kana_U                                      0x4b3
-#define XK_kana_E                                      0x4b4
-#define XK_kana_O                                      0x4b5
-#define XK_kana_KA                                     0x4b6
-#define XK_kana_KI                                     0x4b7
-#define XK_kana_KU                                     0x4b8
-#define XK_kana_KE                                     0x4b9
-#define XK_kana_KO                                     0x4ba
-#define XK_kana_SA                                     0x4bb
-#define XK_kana_SHI                                    0x4bc
-#define XK_kana_SU                                     0x4bd
-#define XK_kana_SE                                     0x4be
-#define XK_kana_SO                                     0x4bf
-#define XK_kana_TA                                     0x4c0
-#define XK_kana_CHI                                    0x4c1
-#define XK_kana_TI                                     0x4c1  /* deprecated */
-#define XK_kana_TSU                                    0x4c2
-#define XK_kana_TU                                     0x4c2  /* deprecated */
-#define XK_kana_TE                                     0x4c3
-#define XK_kana_TO                                     0x4c4
-#define XK_kana_NA                                     0x4c5
-#define XK_kana_NI                                     0x4c6
-#define XK_kana_NU                                     0x4c7
-#define XK_kana_NE                                     0x4c8
-#define XK_kana_NO                                     0x4c9
-#define XK_kana_HA                                     0x4ca
-#define XK_kana_HI                                     0x4cb
-#define XK_kana_FU                                     0x4cc
-#define XK_kana_HU                                     0x4cc  /* deprecated */
-#define XK_kana_HE                                     0x4cd
-#define XK_kana_HO                                     0x4ce
-#define XK_kana_MA                                     0x4cf
-#define XK_kana_MI                                     0x4d0
-#define XK_kana_MU                                     0x4d1
-#define XK_kana_ME                                     0x4d2
-#define XK_kana_MO                                     0x4d3
-#define XK_kana_YA                                     0x4d4
-#define XK_kana_YU                                     0x4d5
-#define XK_kana_YO                                     0x4d6
-#define XK_kana_RA                                     0x4d7
-#define XK_kana_RI                                     0x4d8
-#define XK_kana_RU                                     0x4d9
-#define XK_kana_RE                                     0x4da
-#define XK_kana_RO                                     0x4db
-#define XK_kana_WA                                     0x4dc
-#define XK_kana_N                                      0x4dd
-#define XK_voicedsound                                 0x4de
-#define XK_semivoicedsound                             0x4df
-#define XK_kana_switch          0xFF7E  /* Alias for mode_switch */
-#endif /* XK_KATAKANA */
-
-/*
- *  Arabic
- *  Byte 3 = 5
- */
-
-#ifdef XK_ARABIC
-#define XK_Arabic_comma                                0x5ac
-#define XK_Arabic_semicolon                            0x5bb
-#define XK_Arabic_question_mark                        0x5bf
-#define XK_Arabic_hamza                                0x5c1
-#define XK_Arabic_maddaonalef                          0x5c2
-#define XK_Arabic_hamzaonalef                          0x5c3
-#define XK_Arabic_hamzaonwaw                           0x5c4
-#define XK_Arabic_hamzaunderalef                       0x5c5
-#define XK_Arabic_hamzaonyeh                           0x5c6
-#define XK_Arabic_alef                                 0x5c7
-#define XK_Arabic_beh                                  0x5c8
-#define XK_Arabic_tehmarbuta                           0x5c9
-#define XK_Arabic_teh                                  0x5ca
-#define XK_Arabic_theh                                 0x5cb
-#define XK_Arabic_jeem                                 0x5cc
-#define XK_Arabic_hah                                  0x5cd
-#define XK_Arabic_khah                                 0x5ce
-#define XK_Arabic_dal                                  0x5cf
-#define XK_Arabic_thal                                 0x5d0
-#define XK_Arabic_ra                                   0x5d1
-#define XK_Arabic_zain                                 0x5d2
-#define XK_Arabic_seen                                 0x5d3
-#define XK_Arabic_sheen                                0x5d4
-#define XK_Arabic_sad                                  0x5d5
-#define XK_Arabic_dad                                  0x5d6
-#define XK_Arabic_tah                                  0x5d7
-#define XK_Arabic_zah                                  0x5d8
-#define XK_Arabic_ain                                  0x5d9
-#define XK_Arabic_ghain                                0x5da
-#define XK_Arabic_tatweel                              0x5e0
-#define XK_Arabic_feh                                  0x5e1
-#define XK_Arabic_qaf                                  0x5e2
-#define XK_Arabic_kaf                                  0x5e3
-#define XK_Arabic_lam                                  0x5e4
-#define XK_Arabic_meem                                 0x5e5
-#define XK_Arabic_noon                                 0x5e6
-#define XK_Arabic_ha                                   0x5e7
-#define XK_Arabic_heh                                  0x5e7  /* deprecated */
-#define XK_Arabic_waw                                  0x5e8
-#define XK_Arabic_alefmaksura                          0x5e9
-#define XK_Arabic_yeh                                  0x5ea
-#define XK_Arabic_fathatan                             0x5eb
-#define XK_Arabic_dammatan                             0x5ec
-#define XK_Arabic_kasratan                             0x5ed
-#define XK_Arabic_fatha                                0x5ee
-#define XK_Arabic_damma                                0x5ef
-#define XK_Arabic_kasra                                0x5f0
-#define XK_Arabic_shadda                               0x5f1
-#define XK_Arabic_sukun                                0x5f2
-#define XK_Arabic_switch        0xFF7E  /* Alias for mode_switch */
-#endif /* XK_ARABIC */
-
-/*
- * Cyrillic
- * Byte 3 = 6
- */
-#ifdef XK_CYRILLIC
-#define XK_Serbian_dje                                 0x6a1
-#define XK_Macedonia_gje                               0x6a2
-#define XK_Cyrillic_io                                 0x6a3
-#define XK_Ukrainian_ie                                0x6a4
-#define XK_Ukranian_je                                 0x6a4  /* deprecated */
-#define XK_Macedonia_dse                               0x6a5
-#define XK_Ukrainian_i                                 0x6a6
-#define XK_Ukranian_i                                  0x6a6  /* deprecated */
-#define XK_Ukrainian_yi                                0x6a7
-#define XK_Ukranian_yi                                 0x6a7  /* deprecated */
-#define XK_Cyrillic_je                                 0x6a8
-#define XK_Serbian_je                                  0x6a8  /* deprecated */
-#define XK_Cyrillic_lje                                0x6a9
-#define XK_Serbian_lje                                 0x6a9  /* deprecated */
-#define XK_Cyrillic_nje                                0x6aa
-#define XK_Serbian_nje                                 0x6aa  /* deprecated */
-#define XK_Serbian_tshe                                0x6ab
-#define XK_Macedonia_kje                               0x6ac
-#define XK_Byelorussian_shortu                         0x6ae
-#define XK_Cyrillic_dzhe                               0x6af
-#define XK_Serbian_dze                                 0x6af  /* deprecated */
-#define XK_numerosign                                  0x6b0
-#define XK_Serbian_DJE                                 0x6b1
-#define XK_Macedonia_GJE                               0x6b2
-#define XK_Cyrillic_IO                                 0x6b3
-#define XK_Ukrainian_IE                                0x6b4
-#define XK_Ukranian_JE                                 0x6b4  /* deprecated */
-#define XK_Macedonia_DSE                               0x6b5
-#define XK_Ukrainian_I                                 0x6b6
-#define XK_Ukranian_I                                  0x6b6  /* deprecated */
-#define XK_Ukrainian_YI                                0x6b7
-#define XK_Ukranian_YI                                 0x6b7  /* deprecated */
-#define XK_Cyrillic_JE                                 0x6b8
-#define XK_Serbian_JE                                  0x6b8  /* deprecated */
-#define XK_Cyrillic_LJE                                0x6b9
-#define XK_Serbian_LJE                                 0x6b9  /* deprecated */
-#define XK_Cyrillic_NJE                                0x6ba
-#define XK_Serbian_NJE                                 0x6ba  /* deprecated */
-#define XK_Serbian_TSHE                                0x6bb
-#define XK_Macedonia_KJE                               0x6bc
-#define XK_Byelorussian_SHORTU                         0x6be
-#define XK_Cyrillic_DZHE                               0x6bf
-#define XK_Serbian_DZE                                 0x6bf  /* deprecated */
-#define XK_Cyrillic_yu                                 0x6c0
-#define XK_Cyrillic_a                                  0x6c1
-#define XK_Cyrillic_be                                 0x6c2
-#define XK_Cyrillic_tse                                0x6c3
-#define XK_Cyrillic_de                                 0x6c4
-#define XK_Cyrillic_ie                                 0x6c5
-#define XK_Cyrillic_ef                                 0x6c6
-#define XK_Cyrillic_ghe                                0x6c7
-#define XK_Cyrillic_ha                                 0x6c8
-#define XK_Cyrillic_i                                  0x6c9
-#define XK_Cyrillic_shorti                             0x6ca
-#define XK_Cyrillic_ka                                 0x6cb
-#define XK_Cyrillic_el                                 0x6cc
-#define XK_Cyrillic_em                                 0x6cd
-#define XK_Cyrillic_en                                 0x6ce
-#define XK_Cyrillic_o                                  0x6cf
-#define XK_Cyrillic_pe                                 0x6d0
-#define XK_Cyrillic_ya                                 0x6d1
-#define XK_Cyrillic_er                                 0x6d2
-#define XK_Cyrillic_es                                 0x6d3
-#define XK_Cyrillic_te                                 0x6d4
-#define XK_Cyrillic_u                                  0x6d5
-#define XK_Cyrillic_zhe                                0x6d6
-#define XK_Cyrillic_ve                                 0x6d7
-#define XK_Cyrillic_softsign                           0x6d8
-#define XK_Cyrillic_yeru                               0x6d9
-#define XK_Cyrillic_ze                                 0x6da
-#define XK_Cyrillic_sha                                0x6db
-#define XK_Cyrillic_e                                  0x6dc
-#define XK_Cyrillic_shcha                              0x6dd
-#define XK_Cyrillic_che                                0x6de
-#define XK_Cyrillic_hardsign                           0x6df
-#define XK_Cyrillic_YU                                 0x6e0
-#define XK_Cyrillic_A                                  0x6e1
-#define XK_Cyrillic_BE                                 0x6e2
-#define XK_Cyrillic_TSE                                0x6e3
-#define XK_Cyrillic_DE                                 0x6e4
-#define XK_Cyrillic_IE                                 0x6e5
-#define XK_Cyrillic_EF                                 0x6e6
-#define XK_Cyrillic_GHE                                0x6e7
-#define XK_Cyrillic_HA                                 0x6e8
-#define XK_Cyrillic_I                                  0x6e9
-#define XK_Cyrillic_SHORTI                             0x6ea
-#define XK_Cyrillic_KA                                 0x6eb
-#define XK_Cyrillic_EL                                 0x6ec
-#define XK_Cyrillic_EM                                 0x6ed
-#define XK_Cyrillic_EN                                 0x6ee
-#define XK_Cyrillic_O                                  0x6ef
-#define XK_Cyrillic_PE                                 0x6f0
-#define XK_Cyrillic_YA                                 0x6f1
-#define XK_Cyrillic_ER                                 0x6f2
-#define XK_Cyrillic_ES                                 0x6f3
-#define XK_Cyrillic_TE                                 0x6f4
-#define XK_Cyrillic_U                                  0x6f5
-#define XK_Cyrillic_ZHE                                0x6f6
-#define XK_Cyrillic_VE                                 0x6f7
-#define XK_Cyrillic_SOFTSIGN                           0x6f8
-#define XK_Cyrillic_YERU                               0x6f9
-#define XK_Cyrillic_ZE                                 0x6fa
-#define XK_Cyrillic_SHA                                0x6fb
-#define XK_Cyrillic_E                                  0x6fc
-#define XK_Cyrillic_SHCHA                              0x6fd
-#define XK_Cyrillic_CHE                                0x6fe
-#define XK_Cyrillic_HARDSIGN                           0x6ff
-#endif /* XK_CYRILLIC */
-
-/*
- * Greek
- * Byte 3 = 7
- */
-
-#ifdef XK_GREEK
-#define XK_Greek_ALPHAaccent                           0x7a1
-#define XK_Greek_EPSILONaccent                         0x7a2
-#define XK_Greek_ETAaccent                             0x7a3
-#define XK_Greek_IOTAaccent                            0x7a4
-#define XK_Greek_IOTAdieresis                          0x7a5
-#define XK_Greek_OMICRONaccent                         0x7a7
-#define XK_Greek_UPSILONaccent                         0x7a8
-#define XK_Greek_UPSILONdieresis                       0x7a9
-#define XK_Greek_OMEGAaccent                           0x7ab
-#define XK_Greek_accentdieresis                        0x7ae
-#define XK_Greek_horizbar                              0x7af
-#define XK_Greek_alphaaccent                           0x7b1
-#define XK_Greek_epsilonaccent                         0x7b2
-#define XK_Greek_etaaccent                             0x7b3
-#define XK_Greek_iotaaccent                            0x7b4
-#define XK_Greek_iotadieresis                          0x7b5
-#define XK_Greek_iotaaccentdieresis                    0x7b6
-#define XK_Greek_omicronaccent                         0x7b7
-#define XK_Greek_upsilonaccent                         0x7b8
-#define XK_Greek_upsilondieresis                       0x7b9
-#define XK_Greek_upsilonaccentdieresis                 0x7ba
-#define XK_Greek_omegaaccent                           0x7bb
-#define XK_Greek_ALPHA                                 0x7c1
-#define XK_Greek_BETA                                  0x7c2
-#define XK_Greek_GAMMA                                 0x7c3
-#define XK_Greek_DELTA                                 0x7c4
-#define XK_Greek_EPSILON                               0x7c5
-#define XK_Greek_ZETA                                  0x7c6
-#define XK_Greek_ETA                                   0x7c7
-#define XK_Greek_THETA                                 0x7c8
-#define XK_Greek_IOTA                                  0x7c9
-#define XK_Greek_KAPPA                                 0x7ca
-#define XK_Greek_LAMDA                                 0x7cb
-#define XK_Greek_LAMBDA                                0x7cb
-#define XK_Greek_MU                                    0x7cc
-#define XK_Greek_NU                                    0x7cd
-#define XK_Greek_XI                                    0x7ce
-#define XK_Greek_OMICRON                               0x7cf
-#define XK_Greek_PI                                    0x7d0
-#define XK_Greek_RHO                                   0x7d1
-#define XK_Greek_SIGMA                                 0x7d2
-#define XK_Greek_TAU                                   0x7d4
-#define XK_Greek_UPSILON                               0x7d5
-#define XK_Greek_PHI                                   0x7d6
-#define XK_Greek_CHI                                   0x7d7
-#define XK_Greek_PSI                                   0x7d8
-#define XK_Greek_OMEGA                                 0x7d9
-#define XK_Greek_alpha                                 0x7e1
-#define XK_Greek_beta                                  0x7e2
-#define XK_Greek_gamma                                 0x7e3
-#define XK_Greek_delta                                 0x7e4
-#define XK_Greek_epsilon                               0x7e5
-#define XK_Greek_zeta                                  0x7e6
-#define XK_Greek_eta                                   0x7e7
-#define XK_Greek_theta                                 0x7e8
-#define XK_Greek_iota                                  0x7e9
-#define XK_Greek_kappa                                 0x7ea
-#define XK_Greek_lamda                                 0x7eb
-#define XK_Greek_lambda                                0x7eb
-#define XK_Greek_mu                                    0x7ec
-#define XK_Greek_nu                                    0x7ed
-#define XK_Greek_xi                                    0x7ee
-#define XK_Greek_omicron                               0x7ef
-#define XK_Greek_pi                                    0x7f0
-#define XK_Greek_rho                                   0x7f1
-#define XK_Greek_sigma                                 0x7f2
-#define XK_Greek_finalsmallsigma                       0x7f3
-#define XK_Greek_tau                                   0x7f4
-#define XK_Greek_upsilon                               0x7f5
-#define XK_Greek_phi                                   0x7f6
-#define XK_Greek_chi                                   0x7f7
-#define XK_Greek_psi                                   0x7f8
-#define XK_Greek_omega                                 0x7f9
-#define XK_Greek_switch         0xFF7E  /* Alias for mode_switch */
-#endif /* XK_GREEK */
-
-/*
- * Technical
- * Byte 3 = 8
- */
-
-#ifdef XK_TECHNICAL
-#define XK_leftradical                                 0x8a1
-#define XK_topleftradical                              0x8a2
-#define XK_horizconnector                              0x8a3
-#define XK_topintegral                                 0x8a4
-#define XK_botintegral                                 0x8a5
-#define XK_vertconnector                               0x8a6
-#define XK_topleftsqbracket                            0x8a7
-#define XK_botleftsqbracket                            0x8a8
-#define XK_toprightsqbracket                           0x8a9
-#define XK_botrightsqbracket                           0x8aa
-#define XK_topleftparens                               0x8ab
-#define XK_botleftparens                               0x8ac
-#define XK_toprightparens                              0x8ad
-#define XK_botrightparens                              0x8ae
-#define XK_leftmiddlecurlybrace                        0x8af
-#define XK_rightmiddlecurlybrace                       0x8b0
-#define XK_topleftsummation                            0x8b1
-#define XK_botleftsummation                            0x8b2
-#define XK_topvertsummationconnector                   0x8b3
-#define XK_botvertsummationconnector                   0x8b4
-#define XK_toprightsummation                           0x8b5
-#define XK_botrightsummation                           0x8b6
-#define XK_rightmiddlesummation                        0x8b7
-#define XK_lessthanequal                               0x8bc
-#define XK_notequal                                    0x8bd
-#define XK_greaterthanequal                            0x8be
-#define XK_integral                                    0x8bf
-#define XK_therefore                                   0x8c0
-#define XK_variation                                   0x8c1
-#define XK_infinity                                    0x8c2
-#define XK_nabla                                       0x8c5
-#define XK_approximate                                 0x8c8
-#define XK_similarequal                                0x8c9
-#define XK_ifonlyif                                    0x8cd
-#define XK_implies                                     0x8ce
-#define XK_identical                                   0x8cf
-#define XK_radical                                     0x8d6
-#define XK_includedin                                  0x8da
-#define XK_includes                                    0x8db
-#define XK_intersection                                0x8dc
-#define XK_union                                       0x8dd
-#define XK_logicaland                                  0x8de
-#define XK_logicalor                                   0x8df
-#define XK_partialderivative                           0x8ef
-#define XK_function                                    0x8f6
-#define XK_leftarrow                                   0x8fb
-#define XK_uparrow                                     0x8fc
-#define XK_rightarrow                                  0x8fd
-#define XK_downarrow                                   0x8fe
-#endif /* XK_TECHNICAL */
-
-/*
- *  Special
- *  Byte 3 = 9
- */
-
-#ifdef XK_SPECIAL
-#define XK_blank                                       0x9df
-#define XK_soliddiamond                                0x9e0
-#define XK_checkerboard                                0x9e1
-#define XK_ht                                          0x9e2
-#define XK_ff                                          0x9e3
-#define XK_cr                                          0x9e4
-#define XK_lf                                          0x9e5
-#define XK_nl                                          0x9e8
-#define XK_vt                                          0x9e9
-#define XK_lowrightcorner                              0x9ea
-#define XK_uprightcorner                               0x9eb
-#define XK_upleftcorner                                0x9ec
-#define XK_lowleftcorner                               0x9ed
-#define XK_crossinglines                               0x9ee
-#define XK_horizlinescan1                              0x9ef
-#define XK_horizlinescan3                              0x9f0
-#define XK_horizlinescan5                              0x9f1
-#define XK_horizlinescan7                              0x9f2
-#define XK_horizlinescan9                              0x9f3
-#define XK_leftt                                       0x9f4
-#define XK_rightt                                      0x9f5
-#define XK_bott                                        0x9f6
-#define XK_topt                                        0x9f7
-#define XK_vertbar                                     0x9f8
-#endif /* XK_SPECIAL */
-
-/*
- *  Publishing
- *  Byte 3 = a
- */
-
-#ifdef XK_PUBLISHING
-#define XK_emspace                                     0xaa1
-#define XK_enspace                                     0xaa2
-#define XK_em3space                                    0xaa3
-#define XK_em4space                                    0xaa4
-#define XK_digitspace                                  0xaa5
-#define XK_punctspace                                  0xaa6
-#define XK_thinspace                                   0xaa7
-#define XK_hairspace                                   0xaa8
-#define XK_emdash                                      0xaa9
-#define XK_endash                                      0xaaa
-#define XK_signifblank                                 0xaac
-#define XK_ellipsis                                    0xaae
-#define XK_doubbaselinedot                             0xaaf
-#define XK_onethird                                    0xab0
-#define XK_twothirds                                   0xab1
-#define XK_onefifth                                    0xab2
-#define XK_twofifths                                   0xab3
-#define XK_threefifths                                 0xab4
-#define XK_fourfifths                                  0xab5
-#define XK_onesixth                                    0xab6
-#define XK_fivesixths                                  0xab7
-#define XK_careof                                      0xab8
-#define XK_figdash                                     0xabb
-#define XK_leftanglebracket                            0xabc
-#define XK_decimalpoint                                0xabd
-#define XK_rightanglebracket                           0xabe
-#define XK_marker                                      0xabf
-#define XK_oneeighth                                   0xac3
-#define XK_threeeighths                                0xac4
-#define XK_fiveeighths                                 0xac5
-#define XK_seveneighths                                0xac6
-#define XK_trademark                                   0xac9
-#define XK_signaturemark                               0xaca
-#define XK_trademarkincircle                           0xacb
-#define XK_leftopentriangle                            0xacc
-#define XK_rightopentriangle                           0xacd
-#define XK_emopencircle                                0xace
-#define XK_emopenrectangle                             0xacf
-#define XK_leftsinglequotemark                         0xad0
-#define XK_rightsinglequotemark                        0xad1
-#define XK_leftdoublequotemark                         0xad2
-#define XK_rightdoublequotemark                        0xad3
-#define XK_prescription                                0xad4
-#define XK_minutes                                     0xad6
-#define XK_seconds                                     0xad7
-#define XK_latincross                                  0xad9
-#define XK_hexagram                                    0xada
-#define XK_filledrectbullet                            0xadb
-#define XK_filledlefttribullet                         0xadc
-#define XK_filledrighttribullet                        0xadd
-#define XK_emfilledcircle                              0xade
-#define XK_emfilledrect                                0xadf
-#define XK_enopencircbullet                            0xae0
-#define XK_enopensquarebullet                          0xae1
-#define XK_openrectbullet                              0xae2
-#define XK_opentribulletup                             0xae3
-#define XK_opentribulletdown                           0xae4
-#define XK_openstar                                    0xae5
-#define XK_enfilledcircbullet                          0xae6
-#define XK_enfilledsqbullet                            0xae7
-#define XK_filledtribulletup                           0xae8
-#define XK_filledtribulletdown                         0xae9
-#define XK_leftpointer                                 0xaea
-#define XK_rightpointer                                0xaeb
-#define XK_club                                        0xaec
-#define XK_diamond                                     0xaed
-#define XK_heart                                       0xaee
-#define XK_maltesecross                                0xaf0
-#define XK_dagger                                      0xaf1
-#define XK_doubledagger                                0xaf2
-#define XK_checkmark                                   0xaf3
-#define XK_ballotcross                                 0xaf4
-#define XK_musicalsharp                                0xaf5
-#define XK_musicalflat                                 0xaf6
-#define XK_malesymbol                                  0xaf7
-#define XK_femalesymbol                                0xaf8
-#define XK_telephone                                   0xaf9
-#define XK_telephonerecorder                           0xafa
-#define XK_phonographcopyright                         0xafb
-#define XK_caret                                       0xafc
-#define XK_singlelowquotemark                          0xafd
-#define XK_doublelowquotemark                          0xafe
-#define XK_cursor                                      0xaff
-#endif /* XK_PUBLISHING */
-
-/*
- *  APL
- *  Byte 3 = b
- */
-
-#ifdef XK_APL
-#define XK_leftcaret                                   0xba3
-#define XK_rightcaret                                  0xba6
-#define XK_downcaret                                   0xba8
-#define XK_upcaret                                     0xba9
-#define XK_overbar                                     0xbc0
-#define XK_downtack                                    0xbc2
-#define XK_upshoe                                      0xbc3
-#define XK_downstile                                   0xbc4
-#define XK_underbar                                    0xbc6
-#define XK_jot                                         0xbca
-#define XK_quad                                        0xbcc
-#define XK_uptack                                      0xbce
-#define XK_circle                                      0xbcf
-#define XK_upstile                                     0xbd3
-#define XK_downshoe                                    0xbd6
-#define XK_rightshoe                                   0xbd8
-#define XK_leftshoe                                    0xbda
-#define XK_lefttack                                    0xbdc
-#define XK_righttack                                   0xbfc
-#endif /* XK_APL */
-
-/*
- * Hebrew
- * Byte 3 = c
- */
-
-#ifdef XK_HEBREW
-#define XK_hebrew_doublelowline                        0xcdf
-#define XK_hebrew_aleph                                0xce0
-#define XK_hebrew_bet                                  0xce1
-#define XK_hebrew_beth                                 0xce1  /* deprecated */
-#define XK_hebrew_gimel                                0xce2
-#define XK_hebrew_gimmel                               0xce2  /* deprecated */
-#define XK_hebrew_dalet                                0xce3
-#define XK_hebrew_daleth                               0xce3  /* deprecated */
-#define XK_hebrew_he                                   0xce4
-#define XK_hebrew_waw                                  0xce5
-#define XK_hebrew_zain                                 0xce6
-#define XK_hebrew_zayin                                0xce6  /* deprecated */
-#define XK_hebrew_chet                                 0xce7
-#define XK_hebrew_het                                  0xce7  /* deprecated */
-#define XK_hebrew_tet                                  0xce8
-#define XK_hebrew_teth                                 0xce8  /* deprecated */
-#define XK_hebrew_yod                                  0xce9
-#define XK_hebrew_finalkaph                            0xcea
-#define XK_hebrew_kaph                                 0xceb
-#define XK_hebrew_lamed                                0xcec
-#define XK_hebrew_finalmem                             0xced
-#define XK_hebrew_mem                                  0xcee
-#define XK_hebrew_finalnun                             0xcef
-#define XK_hebrew_nun                                  0xcf0
-#define XK_hebrew_samech                               0xcf1
-#define XK_hebrew_samekh                               0xcf1  /* deprecated */
-#define XK_hebrew_ayin                                 0xcf2
-#define XK_hebrew_finalpe                              0xcf3
-#define XK_hebrew_pe                                   0xcf4
-#define XK_hebrew_finalzade                            0xcf5
-#define XK_hebrew_finalzadi                            0xcf5  /* deprecated */
-#define XK_hebrew_zade                                 0xcf6
-#define XK_hebrew_zadi                                 0xcf6  /* deprecated */
-#define XK_hebrew_qoph                                 0xcf7
-#define XK_hebrew_kuf                                  0xcf7  /* deprecated */
-#define XK_hebrew_resh                                 0xcf8
-#define XK_hebrew_shin                                 0xcf9
-#define XK_hebrew_taw                                  0xcfa
-#define XK_hebrew_taf                                  0xcfa  /* deprecated */
-#define XK_Hebrew_switch        0xFF7E  /* Alias for mode_switch */
-#endif /* XK_HEBREW */
-
-/*
- * Thai
- * Byte 3 = d
- */
-
-#ifdef XK_THAI
-#define XK_Thai_kokai					0xda1
-#define XK_Thai_khokhai					0xda2
-#define XK_Thai_khokhuat				0xda3
-#define XK_Thai_khokhwai				0xda4
-#define XK_Thai_khokhon					0xda5
-#define XK_Thai_khorakhang			        0xda6  
-#define XK_Thai_ngongu					0xda7  
-#define XK_Thai_chochan					0xda8  
-#define XK_Thai_choching				0xda9   
-#define XK_Thai_chochang				0xdaa  
-#define XK_Thai_soso					0xdab
-#define XK_Thai_chochoe					0xdac
-#define XK_Thai_yoying					0xdad
-#define XK_Thai_dochada					0xdae
-#define XK_Thai_topatak					0xdaf
-#define XK_Thai_thothan					0xdb0
-#define XK_Thai_thonangmontho			        0xdb1
-#define XK_Thai_thophuthao			        0xdb2
-#define XK_Thai_nonen					0xdb3
-#define XK_Thai_dodek					0xdb4
-#define XK_Thai_totao					0xdb5
-#define XK_Thai_thothung				0xdb6
-#define XK_Thai_thothahan				0xdb7
-#define XK_Thai_thothong	 			0xdb8
-#define XK_Thai_nonu					0xdb9
-#define XK_Thai_bobaimai				0xdba
-#define XK_Thai_popla					0xdbb
-#define XK_Thai_phophung				0xdbc
-#define XK_Thai_fofa					0xdbd
-#define XK_Thai_phophan					0xdbe
-#define XK_Thai_fofan					0xdbf
-#define XK_Thai_phosamphao			        0xdc0
-#define XK_Thai_moma					0xdc1
-#define XK_Thai_yoyak					0xdc2
-#define XK_Thai_rorua					0xdc3
-#define XK_Thai_ru					0xdc4
-#define XK_Thai_loling					0xdc5
-#define XK_Thai_lu					0xdc6
-#define XK_Thai_wowaen					0xdc7
-#define XK_Thai_sosala					0xdc8
-#define XK_Thai_sorusi					0xdc9
-#define XK_Thai_sosua					0xdca
-#define XK_Thai_hohip					0xdcb
-#define XK_Thai_lochula					0xdcc
-#define XK_Thai_oang					0xdcd
-#define XK_Thai_honokhuk				0xdce
-#define XK_Thai_paiyannoi				0xdcf
-#define XK_Thai_saraa					0xdd0
-#define XK_Thai_maihanakat				0xdd1
-#define XK_Thai_saraaa					0xdd2
-#define XK_Thai_saraam					0xdd3
-#define XK_Thai_sarai					0xdd4   
-#define XK_Thai_saraii					0xdd5   
-#define XK_Thai_saraue					0xdd6    
-#define XK_Thai_sarauee					0xdd7    
-#define XK_Thai_sarau					0xdd8    
-#define XK_Thai_sarauu					0xdd9   
-#define XK_Thai_phinthu					0xdda
-#define XK_Thai_maihanakat_maitho   			0xdde
-#define XK_Thai_baht					0xddf
-#define XK_Thai_sarae					0xde0    
-#define XK_Thai_saraae					0xde1
-#define XK_Thai_sarao					0xde2
-#define XK_Thai_saraaimaimuan				0xde3   
-#define XK_Thai_saraaimaimalai				0xde4  
-#define XK_Thai_lakkhangyao				0xde5
-#define XK_Thai_maiyamok				0xde6
-#define XK_Thai_maitaikhu				0xde7
-#define XK_Thai_maiek					0xde8   
-#define XK_Thai_maitho					0xde9
-#define XK_Thai_maitri					0xdea
-#define XK_Thai_maichattawa				0xdeb
-#define XK_Thai_thanthakhat				0xdec
-#define XK_Thai_nikhahit				0xded
-#define XK_Thai_leksun					0xdf0 
-#define XK_Thai_leknung					0xdf1  
-#define XK_Thai_leksong					0xdf2 
-#define XK_Thai_leksam					0xdf3
-#define XK_Thai_leksi					0xdf4  
-#define XK_Thai_lekha					0xdf5  
-#define XK_Thai_lekhok					0xdf6  
-#define XK_Thai_lekchet					0xdf7  
-#define XK_Thai_lekpaet					0xdf8  
-#define XK_Thai_lekkao					0xdf9 
-#endif /* XK_THAI */
-
-/*
- *   Korean
- *   Byte 3 = e
- */
-
-#ifdef XK_KOREAN
-
-#define XK_Hangul		0xff31    /* Hangul start/stop(toggle) */
-#define XK_Hangul_Start		0xff32    /* Hangul start */
-#define XK_Hangul_End		0xff33    /* Hangul end, English start */
-#define XK_Hangul_Hanja		0xff34    /* Start Hangul->Hanja Conversion */
-#define XK_Hangul_Jamo		0xff35    /* Hangul Jamo mode */
-#define XK_Hangul_Romaja	0xff36    /* Hangul Romaja mode */
-#define XK_Hangul_Codeinput	0xff37    /* Hangul code input mode */
-#define XK_Hangul_Jeonja	0xff38    /* Jeonja mode */
-#define XK_Hangul_Banja		0xff39    /* Banja mode */
-#define XK_Hangul_PreHanja	0xff3a    /* Pre Hanja conversion */
-#define XK_Hangul_PostHanja	0xff3b    /* Post Hanja conversion */
-#define XK_Hangul_SingleCandidate	0xff3c    /* Single candidate */
-#define XK_Hangul_MultipleCandidate	0xff3d    /* Multiple candidate */
-#define XK_Hangul_PreviousCandidate	0xff3e    /* Previous candidate */
-#define XK_Hangul_Special	0xff3f    /* Special symbols */
-#define XK_Hangul_switch	0xFF7E    /* Alias for mode_switch */
-
-/* Hangul Consonant Characters */
-#define XK_Hangul_Kiyeog				0xea1
-#define XK_Hangul_SsangKiyeog				0xea2
-#define XK_Hangul_KiyeogSios				0xea3
-#define XK_Hangul_Nieun					0xea4
-#define XK_Hangul_NieunJieuj				0xea5
-#define XK_Hangul_NieunHieuh				0xea6
-#define XK_Hangul_Dikeud				0xea7
-#define XK_Hangul_SsangDikeud				0xea8
-#define XK_Hangul_Rieul					0xea9
-#define XK_Hangul_RieulKiyeog				0xeaa
-#define XK_Hangul_RieulMieum				0xeab
-#define XK_Hangul_RieulPieub				0xeac
-#define XK_Hangul_RieulSios				0xead
-#define XK_Hangul_RieulTieut				0xeae
-#define XK_Hangul_RieulPhieuf				0xeaf
-#define XK_Hangul_RieulHieuh				0xeb0
-#define XK_Hangul_Mieum					0xeb1
-#define XK_Hangul_Pieub					0xeb2
-#define XK_Hangul_SsangPieub				0xeb3
-#define XK_Hangul_PieubSios				0xeb4
-#define XK_Hangul_Sios					0xeb5
-#define XK_Hangul_SsangSios				0xeb6
-#define XK_Hangul_Ieung					0xeb7
-#define XK_Hangul_Jieuj					0xeb8
-#define XK_Hangul_SsangJieuj				0xeb9
-#define XK_Hangul_Cieuc					0xeba
-#define XK_Hangul_Khieuq				0xebb
-#define XK_Hangul_Tieut					0xebc
-#define XK_Hangul_Phieuf				0xebd
-#define XK_Hangul_Hieuh					0xebe
-
-/* Hangul Vowel Characters */
-#define XK_Hangul_A					0xebf
-#define XK_Hangul_AE					0xec0
-#define XK_Hangul_YA					0xec1
-#define XK_Hangul_YAE					0xec2
-#define XK_Hangul_EO					0xec3
-#define XK_Hangul_E					0xec4
-#define XK_Hangul_YEO					0xec5
-#define XK_Hangul_YE					0xec6
-#define XK_Hangul_O					0xec7
-#define XK_Hangul_WA					0xec8
-#define XK_Hangul_WAE					0xec9
-#define XK_Hangul_OE					0xeca
-#define XK_Hangul_YO					0xecb
-#define XK_Hangul_U					0xecc
-#define XK_Hangul_WEO					0xecd
-#define XK_Hangul_WE					0xece
-#define XK_Hangul_WI					0xecf
-#define XK_Hangul_YU					0xed0
-#define XK_Hangul_EU					0xed1
-#define XK_Hangul_YI					0xed2
-#define XK_Hangul_I					0xed3
-
-/* Hangul syllable-final (JongSeong) Characters */
-#define XK_Hangul_J_Kiyeog				0xed4
-#define XK_Hangul_J_SsangKiyeog				0xed5
-#define XK_Hangul_J_KiyeogSios				0xed6
-#define XK_Hangul_J_Nieun				0xed7
-#define XK_Hangul_J_NieunJieuj				0xed8
-#define XK_Hangul_J_NieunHieuh				0xed9
-#define XK_Hangul_J_Dikeud				0xeda
-#define XK_Hangul_J_Rieul				0xedb
-#define XK_Hangul_J_RieulKiyeog				0xedc
-#define XK_Hangul_J_RieulMieum				0xedd
-#define XK_Hangul_J_RieulPieub				0xede
-#define XK_Hangul_J_RieulSios				0xedf
-#define XK_Hangul_J_RieulTieut				0xee0
-#define XK_Hangul_J_RieulPhieuf				0xee1
-#define XK_Hangul_J_RieulHieuh				0xee2
-#define XK_Hangul_J_Mieum				0xee3
-#define XK_Hangul_J_Pieub				0xee4
-#define XK_Hangul_J_PieubSios				0xee5
-#define XK_Hangul_J_Sios				0xee6
-#define XK_Hangul_J_SsangSios				0xee7
-#define XK_Hangul_J_Ieung				0xee8
-#define XK_Hangul_J_Jieuj				0xee9
-#define XK_Hangul_J_Cieuc				0xeea
-#define XK_Hangul_J_Khieuq				0xeeb
-#define XK_Hangul_J_Tieut				0xeec
-#define XK_Hangul_J_Phieuf				0xeed
-#define XK_Hangul_J_Hieuh				0xeee
-
-/* Ancient Hangul Consonant Characters */
-#define XK_Hangul_RieulYeorinHieuh			0xeef
-#define XK_Hangul_SunkyeongeumMieum			0xef0
-#define XK_Hangul_SunkyeongeumPieub			0xef1
-#define XK_Hangul_PanSios				0xef2
-#define XK_Hangul_KkogjiDalrinIeung			0xef3
-#define XK_Hangul_SunkyeongeumPhieuf			0xef4
-#define XK_Hangul_YeorinHieuh				0xef5
-
-/* Ancient Hangul Vowel Characters */
-#define XK_Hangul_AraeA					0xef6
-#define XK_Hangul_AraeAE				0xef7
-
-/* Ancient Hangul syllable-final (JongSeong) Characters */
-#define XK_Hangul_J_PanSios				0xef8
-#define XK_Hangul_J_KkogjiDalrinIeung			0xef9
-#define XK_Hangul_J_YeorinHieuh				0xefa
-
-/* Korean currency symbol */
-#define XK_Korean_Won					0xeff
-
-#endif /* XK_KOREAN */
-
-/* Euro currency symbol */
-#define XK_EuroSign 0x20ac
-
-#endif
diff --git a/libvncserver/rfb/rfb.h b/libvncserver/rfb/rfb.h
deleted file mode 100644
index 1f98f76..0000000
--- a/libvncserver/rfb/rfb.h
+++ /dev/null
@@ -1,1188 +0,0 @@
-#ifndef RFB_H
-#define RFB_H
-/**
- * @defgroup libvncserver_api LibVNCServer API Reference
- * @{
- */
-
-/**
- * @file rfb.h
- */
-
-/*
- *  Copyright (C) 2005 Rohit Kumar <rokumar@novell.com>,
- *                     Johannes E. Schindelin <johannes.schindelin@gmx.de>
- *  Copyright (C) 2002 RealVNC Ltd.
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#if(defined __cplusplus)
-extern "C"
-{
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "rfbproto.h"
-
-#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#ifdef __MINGW32__
-#undef SOCKET
-#include <winsock2.h>
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-#include <pthread.h>
-#if 0 /* debugging */
-#define LOCK(mutex) (rfbLog("%s:%d LOCK(%s,0x%x)\n",__FILE__,__LINE__,#mutex,&(mutex)), pthread_mutex_lock(&(mutex)))
-#define UNLOCK(mutex) (rfbLog("%s:%d UNLOCK(%s,0x%x)\n",__FILE__,__LINE__,#mutex,&(mutex)), pthread_mutex_unlock(&(mutex)))
-#define MUTEX(mutex) pthread_mutex_t (mutex)
-#define INIT_MUTEX(mutex) (rfbLog("%s:%d INIT_MUTEX(%s,0x%x)\n",__FILE__,__LINE__,#mutex,&(mutex)), pthread_mutex_init(&(mutex),NULL))
-#define TINI_MUTEX(mutex) (rfbLog("%s:%d TINI_MUTEX(%s)\n",__FILE__,__LINE__,#mutex), pthread_mutex_destroy(&(mutex)))
-#define TSIGNAL(cond) (rfbLog("%s:%d TSIGNAL(%s)\n",__FILE__,__LINE__,#cond), pthread_cond_signal(&(cond)))
-#define WAIT(cond,mutex) (rfbLog("%s:%d WAIT(%s,%s)\n",__FILE__,__LINE__,#cond,#mutex), pthread_cond_wait(&(cond),&(mutex)))
-#define COND(cond) pthread_cond_t (cond)
-#define INIT_COND(cond) (rfbLog("%s:%d INIT_COND(%s)\n",__FILE__,__LINE__,#cond), pthread_cond_init(&(cond),NULL))
-#define TINI_COND(cond) (rfbLog("%s:%d TINI_COND(%s)\n",__FILE__,__LINE__,#cond), pthread_cond_destroy(&(cond)))
-#define IF_PTHREADS(x) x
-#else
-#if !NONETWORK
-#define LOCK(mutex) pthread_mutex_lock(&(mutex));
-#define UNLOCK(mutex) pthread_mutex_unlock(&(mutex));
-#endif
-#define MUTEX(mutex) pthread_mutex_t (mutex)
-#define INIT_MUTEX(mutex) pthread_mutex_init(&(mutex),NULL)
-#define TINI_MUTEX(mutex) pthread_mutex_destroy(&(mutex))
-#define TSIGNAL(cond) pthread_cond_signal(&(cond))
-#define WAIT(cond,mutex) pthread_cond_wait(&(cond),&(mutex))
-#define COND(cond) pthread_cond_t (cond)
-#define INIT_COND(cond) pthread_cond_init(&(cond),NULL)
-#define TINI_COND(cond) pthread_cond_destroy(&(cond))
-#define IF_PTHREADS(x) x
-#endif
-#else
-#define LOCK(mutex)
-#define UNLOCK(mutex)
-#define MUTEX(mutex)
-#define INIT_MUTEX(mutex)
-#define TINI_MUTEX(mutex)
-#define TSIGNAL(cond)
-#define WAIT(cond,mutex) this_is_unsupported
-#define COND(cond)
-#define INIT_COND(cond)
-#define TINI_COND(cond)
-#define IF_PTHREADS(x)
-#endif
-
-/* end of stuff for autoconf */
-
-/* if you use pthreads, but don't define LIBVNCSERVER_HAVE_LIBPTHREAD, the structs
-   get all mixed up. So this gives a linker error reminding you to compile
-   the library and your application (at least the parts including rfb.h)
-   with the same support for pthreads. */
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#define rfbInitServer rfbInitServerWithPthreadsAndZRLE
-#else
-#define rfbInitServer rfbInitServerWithPthreadsButWithoutZRLE
-#endif
-#else
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#define rfbInitServer rfbInitServerWithoutPthreadsButWithZRLE
-#else
-#define rfbInitServer rfbInitServerWithoutPthreadsAndZRLE
-#endif
-#endif
-
-struct _rfbClientRec;
-struct _rfbScreenInfo;
-struct rfbCursor;
-
-enum rfbNewClientAction {
-	RFB_CLIENT_ACCEPT,
-	RFB_CLIENT_ON_HOLD,
-	RFB_CLIENT_REFUSE
-};
-
-enum rfbSocketState {
-	RFB_SOCKET_INIT,
-	RFB_SOCKET_READY,
-	RFB_SOCKET_SHUTDOWN
-};
-
-typedef void (*rfbKbdAddEventProcPtr) (rfbBool down, rfbKeySym keySym, struct _rfbClientRec* cl);
-typedef void (*rfbKbdReleaseAllKeysProcPtr) (struct _rfbClientRec* cl);
-typedef void (*rfbPtrAddEventProcPtr) (int buttonMask, int x, int y, struct _rfbClientRec* cl);
-typedef void (*rfbSetXCutTextProcPtr) (char* str,int len, struct _rfbClientRec* cl);
-typedef struct rfbCursor* (*rfbGetCursorProcPtr) (struct _rfbClientRec* pScreen);
-typedef rfbBool (*rfbSetTranslateFunctionProcPtr)(struct _rfbClientRec* cl);
-typedef rfbBool (*rfbPasswordCheckProcPtr)(struct _rfbClientRec* cl,const char* encryptedPassWord,int len);
-typedef enum rfbNewClientAction (*rfbNewClientHookPtr)(struct _rfbClientRec* cl);
-typedef void (*rfbDisplayHookPtr)(struct _rfbClientRec* cl);
-typedef void (*rfbDisplayFinishedHookPtr)(struct _rfbClientRec* cl, int result);
-/** support the capability to view the caps/num/scroll states of the X server */
-typedef int  (*rfbGetKeyboardLedStateHookPtr)(struct _rfbScreenInfo* screen);
-typedef rfbBool (*rfbXvpHookPtr)(struct _rfbClientRec* cl, uint8_t, uint8_t);
-/**
- * If x==1 and y==1 then set the whole display
- * else find the window underneath x and y and set the framebuffer to the dimensions
- * of that window
- */
-typedef void (*rfbSetSingleWindowProcPtr) (struct _rfbClientRec* cl, int x, int y);
-/**
- * Status determines if the X11 server permits input from the local user
- * status==0 or 1
- */
-typedef void (*rfbSetServerInputProcPtr) (struct _rfbClientRec* cl, int status);
-/**
- * Permit the server to allow or deny filetransfers.   This is defaulted to deny
- * It is called when a client initiates a connection to determine if it is permitted.
- */
-typedef int  (*rfbFileTransferPermitted) (struct _rfbClientRec* cl);
-/** Handle the textchat messages */
-typedef void (*rfbSetTextChat) (struct _rfbClientRec* cl, int length, char *string);
-
-typedef struct {
-  uint32_t count;
-  rfbBool is16; /**< is the data format short? */
-  union {
-    uint8_t* bytes;
-    uint16_t* shorts;
-  } data; /**< there have to be count*3 entries */
-} rfbColourMap;
-
-/**
- * Security handling (RFB protocol version 3.7)
- */
-
-typedef struct _rfbSecurity {
-	uint8_t type;
-	void (*handler)(struct _rfbClientRec* cl);
-	struct _rfbSecurity* next;
-} rfbSecurityHandler;
-
-/**
- * Protocol extension handling.
- */
-
-typedef struct _rfbProtocolExtension {
-	/** returns FALSE if extension should be deactivated for client.
-	   if newClient == NULL, it is always deactivated. */
-	rfbBool (*newClient)(struct _rfbClientRec* client, void** data);
-	/** returns FALSE if extension should be deactivated for client.
-	   if init == NULL, it stays activated. */
-	rfbBool (*init)(struct _rfbClientRec* client, void* data);
-	/** if pseudoEncodings is not NULL, it contains a 0 terminated
-	   list of the pseudo encodings handled by this extension. */
-	int *pseudoEncodings;
-	/** returns TRUE if that pseudo encoding is handled by the extension.
-	   encodingNumber==0 means "reset encodings". */
-	rfbBool (*enablePseudoEncoding)(struct _rfbClientRec* client,
-			void** data, int encodingNumber);
-	/** returns TRUE if message was handled */
-	rfbBool (*handleMessage)(struct _rfbClientRec* client,
-				void* data,
-				const rfbClientToServerMsg* message);
-	void (*close)(struct _rfbClientRec* client, void* data);
-	void (*usage)(void);
-	/** processArguments returns the number of handled arguments */
-	int (*processArgument)(int argc, char *argv[]);
-	struct _rfbProtocolExtension* next;
-} rfbProtocolExtension;
-
-typedef struct _rfbExtensionData {
-	rfbProtocolExtension* extension;
-	void* data;
-	struct _rfbExtensionData* next;
-} rfbExtensionData;
-
-/**
- * Per-screen (framebuffer) structure.  There can be as many as you wish,
- * each serving different clients. However, you have to call
- * rfbProcessEvents for each of these.
- */
-
-typedef struct _rfbScreenInfo
-{
-    /** this structure has children that are scaled versions of this screen */
-    struct _rfbScreenInfo *scaledScreenNext;
-    int scaledScreenRefCount;
-
-    int width;
-    int paddedWidthInBytes;
-    int height;
-    int depth;
-    int bitsPerPixel;
-    int sizeInBytes;
-
-    rfbPixel blackPixel;
-    rfbPixel whitePixel;
-
-    /**
-     * some screen specific data can be put into a struct where screenData
-     * points to. You need this if you have more than one screen at the
-     * same time while using the same functions.
-     */
-    void* screenData;
-
-    /* additions by libvncserver */
-
-    rfbPixelFormat serverFormat;
-    rfbColourMap colourMap; /**< set this if rfbServerFormat.trueColour==FALSE */
-    const char* desktopName;
-    char thisHost[255];
-
-    rfbBool autoPort;
-    int port;
-    SOCKET listenSock;
-    int maxSock;
-    int maxFd;
-#ifdef __MINGW32__
-    struct fd_set allFds;
-#else
-    fd_set allFds;
-#endif
-
-    enum rfbSocketState socketState;
-    SOCKET inetdSock;
-    rfbBool inetdInitDone;
-
-    int udpPort;
-    SOCKET udpSock;
-    struct _rfbClientRec* udpClient;
-    rfbBool udpSockConnected;
-    struct sockaddr_in udpRemoteAddr;
-
-    int maxClientWait;
-
-    /* http stuff */
-    rfbBool httpInitDone;
-    rfbBool httpEnableProxyConnect;
-    int httpPort;
-    char* httpDir;
-    SOCKET httpListenSock;
-    SOCKET httpSock;
-
-    rfbPasswordCheckProcPtr passwordCheck;
-    void* authPasswdData;
-    /** If rfbAuthPasswdData is given a list, this is the first
-        view only password. */
-    int authPasswdFirstViewOnly;
-
-    /** send only this many rectangles in one update */
-    int maxRectsPerUpdate;
-    /** this is the amount of milliseconds to wait at least before sending
-     * an update. */
-    int deferUpdateTime;
-#ifdef TODELETE
-    char* screen;
-#endif
-    rfbBool alwaysShared;
-    rfbBool neverShared;
-    rfbBool dontDisconnect;
-    struct _rfbClientRec* clientHead;
-    struct _rfbClientRec* pointerClient;  /**< "Mutex" for pointer events */
-
-
-    /* cursor */
-    int cursorX, cursorY,underCursorBufferLen;
-    char* underCursorBuffer;
-    rfbBool dontConvertRichCursorToXCursor;
-    struct rfbCursor* cursor;
-
-    /**
-     * the frameBuffer has to be supplied by the serving process.
-     * The buffer will not be freed by
-     */
-    char* frameBuffer;
-    rfbKbdAddEventProcPtr kbdAddEvent;
-    rfbKbdReleaseAllKeysProcPtr kbdReleaseAllKeys;
-    rfbPtrAddEventProcPtr ptrAddEvent;
-    rfbSetXCutTextProcPtr setXCutText;
-    rfbGetCursorProcPtr getCursorPtr;
-    rfbSetTranslateFunctionProcPtr setTranslateFunction;
-    rfbSetSingleWindowProcPtr setSingleWindow;
-    rfbSetServerInputProcPtr  setServerInput;
-    rfbFileTransferPermitted  getFileTransferPermission;
-    rfbSetTextChat            setTextChat;
-
-    /** newClientHook is called just after a new client is created */
-    rfbNewClientHookPtr newClientHook;
-    /** displayHook is called just before a frame buffer update */
-    rfbDisplayHookPtr displayHook;
-
-    /** These hooks are called to pass keyboard state back to the client */
-    rfbGetKeyboardLedStateHookPtr getKeyboardLedStateHook;
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    MUTEX(cursorMutex);
-    rfbBool backgroundLoop;
-#endif
-
-    /** if TRUE, an ignoring signal handler is installed for SIGPIPE */
-    rfbBool ignoreSIGPIPE;
-
-    /** if not zero, only a slice of this height is processed every time
-     * an update should be sent. This should make working on a slow
-     * link more interactive. */
-    int progressiveSliceHeight;
-
-    in_addr_t listenInterface;
-    int deferPtrUpdateTime;
-
-    /** handle as many input events as possible (default off) */
-    rfbBool handleEventsEagerly;
-
-    /** rfbEncodingServerIdentity */
-    char *versionString;
-
-    /** What does the server tell the new clients which version it supports */
-    int protocolMajorVersion;
-    int protocolMinorVersion;
-
-    /** command line authorization of file transfers */
-    rfbBool permitFileTransfer;
-
-    /** displayFinishedHook is called just after a frame buffer update */
-    rfbDisplayFinishedHookPtr displayFinishedHook;
-    /** xvpHook is called to handle an xvp client message */
-    rfbXvpHookPtr xvpHook;
-} rfbScreenInfo, *rfbScreenInfoPtr;
-
-
-/**
- * rfbTranslateFnType is the type of translation functions.
- */
-
-typedef void (*rfbTranslateFnType)(char *table, rfbPixelFormat *in,
-                                   rfbPixelFormat *out,
-                                   char *iptr, char *optr,
-                                   int bytesBetweenInputLines,
-                                   int width, int height);
-
-
-/* region stuff */
-
-struct sraRegion;
-typedef struct sraRegion* sraRegionPtr;
-
-/*
- * Per-client structure.
- */
-
-typedef void (*ClientGoneHookPtr)(struct _rfbClientRec* cl);
-
-typedef struct _rfbFileTransferData {
-  int fd;
-  int compressionEnabled;
-  int fileSize;
-  int numPackets;
-  int receiving;
-  int sending;
-} rfbFileTransferData;
-
-
-typedef struct _rfbStatList {
-    uint32_t type;
-    uint32_t sentCount;
-    uint32_t bytesSent;
-    uint32_t bytesSentIfRaw;
-    uint32_t rcvdCount;
-    uint32_t bytesRcvd;
-    uint32_t bytesRcvdIfRaw;
-    struct _rfbStatList *Next;
-} rfbStatList;
-
-typedef struct _rfbClientRec {
-
-    /** back pointer to the screen */
-    rfbScreenInfoPtr screen;
-
-     /** points to a scaled version of the screen buffer in cl->scaledScreenList */
-     rfbScreenInfoPtr scaledScreen;
-     /** how did the client tell us it wanted the screen changed?  Ultra style or palm style? */
-     rfbBool PalmVNC;
-
-
-    /** private data. You should put any application client specific data
-     * into a struct and let clientData point to it. Don't forget to
-     * free the struct via clientGoneHook!
-     *
-     * This is useful if the IO functions have to behave client specific.
-     */
-    void* clientData;
-    ClientGoneHookPtr clientGoneHook;
-
-    SOCKET sock;
-    char *host;
-
-    /* RFB protocol minor version number */
-    int protocolMajorVersion;
-    int protocolMinorVersion;
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    pthread_t client_thread;
-#endif
-                                /** Possible client states: */
-    enum {
-        RFB_PROTOCOL_VERSION,   /**< establishing protocol version */
-	RFB_SECURITY_TYPE,      /**< negotiating security (RFB v.3.7) */
-        RFB_AUTHENTICATION,     /**< authenticating */
-        RFB_INITIALISATION,     /**< sending initialisation messages */
-        RFB_NORMAL              /**< normal protocol messages */
-    } state;
-
-    rfbBool reverseConnection;
-    rfbBool onHold;
-    rfbBool readyForSetColourMapEntries;
-    rfbBool useCopyRect;
-    int preferredEncoding;
-    int correMaxWidth, correMaxHeight;
-
-    rfbBool viewOnly;
-
-    /* The following member is only used during VNC authentication */
-    uint8_t authChallenge[CHALLENGESIZE];
-
-    /* The following members represent the update needed to get the client's
-       framebuffer from its present state to the current state of our
-       framebuffer.
-
-       If the client does not accept CopyRect encoding then the update is
-       simply represented as the region of the screen which has been modified
-       (modifiedRegion).
-
-       If the client does accept CopyRect encoding, then the update consists of
-       two parts.  First we have a single copy from one region of the screen to
-       another (the destination of the copy is copyRegion), and second we have
-       the region of the screen which has been modified in some other way
-       (modifiedRegion).
-
-       Although the copy is of a single region, this region may have many
-       rectangles.  When sending an update, the copyRegion is always sent
-       before the modifiedRegion.  This is because the modifiedRegion may
-       overlap parts of the screen which are in the source of the copy.
-
-       In fact during normal processing, the modifiedRegion may even overlap
-       the destination copyRegion.  Just before an update is sent we remove
-       from the copyRegion anything in the modifiedRegion. */
-
-    sraRegionPtr copyRegion;	/**< the destination region of the copy */
-    int copyDX, copyDY;		/**< the translation by which the copy happens */
-
-    sraRegionPtr modifiedRegion;
-
-    /** As part of the FramebufferUpdateRequest, a client can express interest
-       in a subrectangle of the whole framebuffer.  This is stored in the
-       requestedRegion member.  In the normal case this is the whole
-       framebuffer if the client is ready, empty if it's not. */
-
-    sraRegionPtr requestedRegion;
-
-    /** The following member represents the state of the "deferred update" timer
-       - when the framebuffer is modified and the client is ready, in most
-       cases it is more efficient to defer sending the update by a few
-       milliseconds so that several changes to the framebuffer can be combined
-       into a single update. */
-
-      struct timeval startDeferring;
-      struct timeval startPtrDeferring;
-      int lastPtrX;
-      int lastPtrY;
-      int lastPtrButtons;
-
-    /** translateFn points to the translation function which is used to copy
-       and translate a rectangle from the framebuffer to an output buffer. */
-
-    rfbTranslateFnType translateFn;
-    char *translateLookupTable;
-    rfbPixelFormat format;
-
-    /**
-     * UPDATE_BUF_SIZE must be big enough to send at least one whole line of the
-     * framebuffer.  So for a max screen width of say 2K with 32-bit pixels this
-     * means 8K minimum.
-     */
-
-#define UPDATE_BUF_SIZE 30000
-
-    char updateBuf[UPDATE_BUF_SIZE];
-    int ublen;
-
-    /* statistics */
-    struct _rfbStatList *statEncList;
-    struct _rfbStatList *statMsgList;
-    int rawBytesEquivalent;
-    int bytesSent;
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    /* zlib encoding -- necessary compression state info per client */
-
-    struct z_stream_s compStream;
-    rfbBool compStreamInited;
-    uint32_t zlibCompressLevel;
-    /** the quality level is also used by ZYWRLE */
-    int tightQualityLevel;
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-    /* tight encoding -- preserve zlib streams' state for each client */
-    z_stream zsStruct[4];
-    rfbBool zsActive[4];
-    int zsLevel[4];
-    int tightCompressLevel;
-#endif
-#endif
-
-    /* Ultra Encoding support */
-    rfbBool compStreamInitedLZO;
-    char *lzoWrkMem;
-
-    rfbFileTransferData fileTransfer;
-
-    int     lastKeyboardLedState;     /**< keep track of last value so we can send *change* events */
-    rfbBool enableSupportedMessages;  /**< client supports SupportedMessages encoding */
-    rfbBool enableSupportedEncodings; /**< client supports SupportedEncodings encoding */
-    rfbBool enableServerIdentity;     /**< client supports ServerIdentity encoding */
-    rfbBool enableKeyboardLedState;   /**< client supports KeyboardState encoding */
-    rfbBool enableLastRectEncoding;   /**< client supports LastRect encoding */
-    rfbBool enableCursorShapeUpdates; /**< client supports cursor shape updates */
-    rfbBool enableCursorPosUpdates;   /**< client supports cursor position updates */
-    rfbBool useRichCursorEncoding;    /**< rfbEncodingRichCursor is preferred */
-    rfbBool cursorWasChanged;         /**< cursor shape update should be sent */
-    rfbBool cursorWasMoved;           /**< cursor position update should be sent */
-    int cursorX,cursorY;	      /**< the coordinates of the cursor,
-					 if enableCursorShapeUpdates = FALSE */
-
-    rfbBool useNewFBSize;             /**< client supports NewFBSize encoding */
-    rfbBool newFBSizePending;         /**< framebuffer size was changed */
-
-    struct _rfbClientRec *prev;
-    struct _rfbClientRec *next;
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    /** whenever a client is referenced, the refCount has to be incremented
-       and afterwards decremented, so that the client is not cleaned up
-       while being referenced.
-       Use the functions rfbIncrClientRef(cl) and rfbDecrClientRef(cl);
-    */
-    int refCount;
-    MUTEX(refCountMutex);
-    COND(deleteCond);
-
-    MUTEX(outputMutex);
-    MUTEX(updateMutex);
-    COND(updateCond);
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    void* zrleData;
-    int zywrleLevel;
-    int zywrleBuf[rfbZRLETileWidth * rfbZRLETileHeight];
-#endif
-
-    /** if progressive updating is on, this variable holds the current
-     * y coordinate of the progressive slice. */
-    int progressiveSliceY;
-
-    rfbExtensionData* extensions;
-
-    /** for threaded zrle */
-    char *zrleBeforeBuf;
-    void *paletteHelper;
-
-    /** for thread safety for rfbSendFBUpdate() */
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-#define LIBVNCSERVER_SEND_MUTEX
-    MUTEX(sendMutex);
-#endif
-
-  /* buffers to hold pixel data before and after encoding.
-     per-client for thread safety */
-  char *beforeEncBuf;
-  int beforeEncBufSize;
-  char *afterEncBuf;
-  int afterEncBufSize;
-  int afterEncBufLen;
-} rfbClientRec, *rfbClientPtr;
-
-/**
- * This macro is used to test whether there is a framebuffer update needing to
- * be sent to the client.
- */
-
-#define FB_UPDATE_PENDING(cl)                                              \
-     (((cl)->enableCursorShapeUpdates && (cl)->cursorWasChanged) ||        \
-     (((cl)->enableCursorShapeUpdates == FALSE &&                          \
-       ((cl)->cursorX != (cl)->screen->cursorX ||                          \
-	(cl)->cursorY != (cl)->screen->cursorY))) ||                       \
-     ((cl)->useNewFBSize && (cl)->newFBSizePending) ||                     \
-     ((cl)->enableCursorPosUpdates && (cl)->cursorWasMoved) ||             \
-     !sraRgnEmpty((cl)->copyRegion) || !sraRgnEmpty((cl)->modifiedRegion))
-
-/*
- * Macros for endian swapping.
- */
-
-#define Swap16(s) ((((s) & 0xff) << 8) | (((s) >> 8) & 0xff))
-
-#define Swap24(l) ((((l) & 0xff) << 16) | (((l) >> 16) & 0xff) | \
-                   (((l) & 0x00ff00)))
-
-#define Swap32(l) (((l) >> 24) | \
-                   (((l) & 0x00ff0000) >> 8)  | \
-                   (((l) & 0x0000ff00) << 8)  | \
-                   ((l) << 24))
-
-
-extern char rfbEndianTest;
-
-#define Swap16IfLE(s) (rfbEndianTest ? Swap16(s) : (s))
-#define Swap24IfLE(l) (rfbEndianTest ? Swap24(l) : (l))
-#define Swap32IfLE(l) (rfbEndianTest ? Swap32(l) : (l))
-
-/* UltraVNC uses some windows structures unmodified, so the viewer expects LittleEndian Data */
-#define Swap16IfBE(s) (rfbEndianTest ? (s) : Swap16(s))
-#define Swap24IfBE(l) (rfbEndianTest ? (l) : Swap24(l))
-#define Swap32IfBE(l) (rfbEndianTest ? (l) : Swap32(l))
-
-/* sockets.c */
-
-extern int rfbMaxClientWait;
-
-extern void rfbInitSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbShutdownSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbDisconnectUDPSock(rfbScreenInfoPtr rfbScreen);
-extern void rfbCloseClient(rfbClientPtr cl);
-extern int rfbReadExact(rfbClientPtr cl, char *buf, int len);
-extern int rfbReadExactTimeout(rfbClientPtr cl, char *buf, int len,int timeout);
-extern int rfbWriteExact(rfbClientPtr cl, const char *buf, int len);
-extern int rfbCheckFds(rfbScreenInfoPtr rfbScreen,long usec);
-extern int rfbConnect(rfbScreenInfoPtr rfbScreen, char* host, int port);
-extern int rfbConnectToTcpAddr(char* host, int port);
-extern int rfbListenOnTCPPort(int port, in_addr_t iface);
-extern int rfbListenOnUDPPort(int port, in_addr_t iface);
-extern int rfbStringToAddr(char* string,in_addr_t* addr);
-extern rfbBool rfbSetNonBlocking(int sock);
-
-/* rfbserver.c */
-
-/* Routines to iterate over the client list in a thread-safe way.
-   Only a single iterator can be in use at a time process-wide. */
-typedef struct rfbClientIterator *rfbClientIteratorPtr;
-
-extern void rfbClientListInit(rfbScreenInfoPtr rfbScreen);
-extern rfbClientIteratorPtr rfbGetClientIterator(rfbScreenInfoPtr rfbScreen);
-extern rfbClientPtr rfbClientIteratorNext(rfbClientIteratorPtr iterator);
-extern void rfbReleaseClientIterator(rfbClientIteratorPtr iterator);
-extern void rfbIncrClientRef(rfbClientPtr cl);
-extern void rfbDecrClientRef(rfbClientPtr cl);
-
-extern void rfbNewClientConnection(rfbScreenInfoPtr rfbScreen,int sock);
-extern rfbClientPtr rfbNewClient(rfbScreenInfoPtr rfbScreen,int sock);
-extern rfbClientPtr rfbNewUDPClient(rfbScreenInfoPtr rfbScreen);
-extern rfbClientPtr rfbReverseConnection(rfbScreenInfoPtr rfbScreen,char *host, int port);
-extern void rfbClientConnectionGone(rfbClientPtr cl);
-extern void rfbProcessClientMessage(rfbClientPtr cl);
-extern void rfbClientConnFailed(rfbClientPtr cl, const char *reason);
-extern void rfbNewUDPConnection(rfbScreenInfoPtr rfbScreen,int sock);
-extern void rfbProcessUDPInput(rfbScreenInfoPtr rfbScreen);
-extern rfbBool rfbSendFramebufferUpdate(rfbClientPtr cl, sraRegionPtr updateRegion);
-extern rfbBool rfbSendRectEncodingRaw(rfbClientPtr cl, int x,int y,int w,int h);
-extern rfbBool rfbSendUpdateBuf(rfbClientPtr cl);
-extern void rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len);
-extern rfbBool rfbSendCopyRegion(rfbClientPtr cl,sraRegionPtr reg,int dx,int dy);
-extern rfbBool rfbSendLastRectMarker(rfbClientPtr cl);
-extern rfbBool rfbSendNewFBSize(rfbClientPtr cl, int w, int h);
-extern rfbBool rfbSendSetColourMapEntries(rfbClientPtr cl, int firstColour, int nColours);
-extern void rfbSendBell(rfbScreenInfoPtr rfbScreen);
-
-extern char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length);
-extern rfbBool rfbSendFileTransferChunk(rfbClientPtr cl);
-extern rfbBool rfbSendDirContent(rfbClientPtr cl, int length, char *buffer);
-extern rfbBool rfbSendFileTransferMessage(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length, const char *buffer);
-extern char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length);
-extern rfbBool rfbProcessFileTransfer(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length);
-
-void rfbGotXCutText(rfbScreenInfoPtr rfbScreen, char *str, int len);
-
-/* translate.c */
-
-extern rfbBool rfbEconomicTranslate;
-
-extern void rfbTranslateNone(char *table, rfbPixelFormat *in,
-                             rfbPixelFormat *out,
-                             char *iptr, char *optr,
-                             int bytesBetweenInputLines,
-                             int width, int height);
-extern rfbBool rfbSetTranslateFunction(rfbClientPtr cl);
-extern rfbBool rfbSetClientColourMap(rfbClientPtr cl, int firstColour, int nColours);
-extern void rfbSetClientColourMaps(rfbScreenInfoPtr rfbScreen, int firstColour, int nColours);
-
-/* httpd.c */
-
-extern void rfbHttpInitSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbHttpShutdownSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbHttpCheckFds(rfbScreenInfoPtr rfbScreen);
-
-
-
-/* auth.c */
-
-extern void rfbAuthNewClient(rfbClientPtr cl);
-extern void rfbProcessClientSecurityType(rfbClientPtr cl);
-extern void rfbAuthProcessClientMessage(rfbClientPtr cl);
-extern void rfbRegisterSecurityHandler(rfbSecurityHandler* handler);
-extern void rfbUnregisterSecurityHandler(rfbSecurityHandler* handler);
-
-/* rre.c */
-
-extern rfbBool rfbSendRectEncodingRRE(rfbClientPtr cl, int x,int y,int w,int h);
-
-
-/* corre.c */
-
-extern rfbBool rfbSendRectEncodingCoRRE(rfbClientPtr cl, int x,int y,int w,int h);
-
-
-/* hextile.c */
-
-extern rfbBool rfbSendRectEncodingHextile(rfbClientPtr cl, int x, int y, int w,
-                                       int h);
-
-/* ultra.c */
-
-/* Set maximum ultra rectangle size in pixels.  Always allow at least
- * two scan lines.
- */
-#define ULTRA_MAX_RECT_SIZE (128*256)
-#define ULTRA_MAX_SIZE(min) ((( min * 2 ) > ULTRA_MAX_RECT_SIZE ) ? \
-                            ( min * 2 ) : ULTRA_MAX_RECT_SIZE )
-
-extern rfbBool rfbSendRectEncodingUltra(rfbClientPtr cl, int x,int y,int w,int h);
-
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-/* zlib.c */
-
-/** Minimum zlib rectangle size in bytes.  Anything smaller will
- * not compress well due to overhead.
- */
-#define VNC_ENCODE_ZLIB_MIN_COMP_SIZE (17)
-
-/* Set maximum zlib rectangle size in pixels.  Always allow at least
- * two scan lines.
- */
-#define ZLIB_MAX_RECT_SIZE (128*256)
-#define ZLIB_MAX_SIZE(min) ((( min * 2 ) > ZLIB_MAX_RECT_SIZE ) ? \
-			    ( min * 2 ) : ZLIB_MAX_RECT_SIZE )
-
-extern rfbBool rfbSendRectEncodingZlib(rfbClientPtr cl, int x, int y, int w,
-				    int h);
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-/* tight.c */
-
-#define TIGHT_DEFAULT_COMPRESSION  6
-
-extern rfbBool rfbTightDisableGradient;
-
-extern int rfbNumCodedRectsTight(rfbClientPtr cl, int x,int y,int w,int h);
-extern rfbBool rfbSendRectEncodingTight(rfbClientPtr cl, int x,int y,int w,int h);
-
-#endif
-#endif
-
-
-/* cursor.c */
-
-typedef struct rfbCursor {
-    /** set this to true if LibVNCServer has to free this cursor */
-    rfbBool cleanup, cleanupSource, cleanupMask, cleanupRichSource;
-    unsigned char *source;			/**< points to bits */
-    unsigned char *mask;			/**< points to bits */
-    unsigned short width, height, xhot, yhot;	/**< metrics */
-    unsigned short foreRed, foreGreen, foreBlue; /**< device-independent colour */
-    unsigned short backRed, backGreen, backBlue; /**< device-independent colour */
-    unsigned char *richSource; /**< source bytes for a rich cursor */
-    unsigned char *alphaSource; /**< source for alpha blending info */
-    rfbBool alphaPreMultiplied; /**< if richSource already has alpha applied */
-} rfbCursor, *rfbCursorPtr;
-extern unsigned char rfbReverseByte[0x100];
-
-extern rfbBool rfbSendCursorShape(rfbClientPtr cl/*, rfbScreenInfoPtr pScreen*/);
-extern rfbBool rfbSendCursorPos(rfbClientPtr cl);
-extern void rfbConvertLSBCursorBitmapOrMask(int width,int height,unsigned char* bitmap);
-extern rfbCursorPtr rfbMakeXCursor(int width,int height,char* cursorString,char* maskString);
-extern char* rfbMakeMaskForXCursor(int width,int height,char* cursorString);
-extern char* rfbMakeMaskFromAlphaSource(int width,int height,unsigned char* alphaSource);
-extern void rfbMakeXCursorFromRichCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr cursor);
-extern void rfbMakeRichCursorFromXCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr cursor);
-extern void rfbFreeCursor(rfbCursorPtr cursor);
-extern void rfbSetCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr c);
-
-/** cursor handling for the pointer */
-extern void rfbDefaultPtrAddEvent(int buttonMask,int x,int y,rfbClientPtr cl);
-
-/* zrle.c */
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-extern rfbBool rfbSendRectEncodingZRLE(rfbClientPtr cl, int x, int y, int w,int h);
-#endif
-
-/* stats.c */
-
-extern void rfbResetStats(rfbClientPtr cl);
-extern void rfbPrintStats(rfbClientPtr cl);
-
-/* font.c */
-
-typedef struct rfbFontData {
-  unsigned char* data;
-  /**
-    metaData is a 256*5 array:
-    for each character
-    (offset,width,height,x,y)
-  */
-  int* metaData;
-} rfbFontData,* rfbFontDataPtr;
-
-int rfbDrawChar(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,unsigned char c,rfbPixel colour);
-void rfbDrawString(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,const char* string,rfbPixel colour);
-/** if colour==backColour, background is transparent */
-int rfbDrawCharWithClip(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,unsigned char c,int x1,int y1,int x2,int y2,rfbPixel colour,rfbPixel backColour);
-void rfbDrawStringWithClip(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,const char* string,int x1,int y1,int x2,int y2,rfbPixel colour,rfbPixel backColour);
-int rfbWidthOfString(rfbFontDataPtr font,const char* string);
-int rfbWidthOfChar(rfbFontDataPtr font,unsigned char c);
-void rfbFontBBox(rfbFontDataPtr font,unsigned char c,int* x1,int* y1,int* x2,int* y2);
-/** this returns the smallest box enclosing any character of font. */
-void rfbWholeFontBBox(rfbFontDataPtr font,int *x1, int *y1, int *x2, int *y2);
-
-/** dynamically load a linux console font (4096 bytes, 256 glyphs a 8x16 */
-rfbFontDataPtr rfbLoadConsoleFont(char *filename);
-/** free a dynamically loaded font */
-void rfbFreeFont(rfbFontDataPtr font);
-
-/* draw.c */
-
-void rfbFillRect(rfbScreenInfoPtr s,int x1,int y1,int x2,int y2,rfbPixel col);
-void rfbDrawPixel(rfbScreenInfoPtr s,int x,int y,rfbPixel col);
-void rfbDrawLine(rfbScreenInfoPtr s,int x1,int y1,int x2,int y2,rfbPixel col);
-
-/* selbox.c */
-
-/** this opens a modal select box. list is an array of strings, the end marked
-   with a NULL.
-   It returns the index in the list or -1 if cancelled or something else
-   wasn't kosher. */
-typedef void (*SelectionChangedHookPtr)(int _index);
-extern int rfbSelectBox(rfbScreenInfoPtr rfbScreen,
-			rfbFontDataPtr font, char** list,
-			int x1, int y1, int x2, int y2,
-			rfbPixel foreColour, rfbPixel backColour,
-			int border,SelectionChangedHookPtr selChangedHook);
-
-/* cargs.c */
-
-extern void rfbUsage(void);
-extern void rfbPurgeArguments(int* argc,int* position,int count,char *argv[]);
-extern rfbBool rfbProcessArguments(rfbScreenInfoPtr rfbScreen,int* argc, char *argv[]);
-extern rfbBool rfbProcessSizeArguments(int* width,int* height,int* bpp,int* argc, char *argv[]);
-
-/* main.c */
-
-extern void rfbLogEnable(int enabled);
-typedef void (*rfbLogProc)(const char *format, ...);
-extern rfbLogProc rfbLog, rfbErr;
-extern void rfbLogPerror(const char *str);
-
-void rfbScheduleCopyRect(rfbScreenInfoPtr rfbScreen,int x1,int y1,int x2,int y2,int dx,int dy);
-void rfbScheduleCopyRegion(rfbScreenInfoPtr rfbScreen,sraRegionPtr copyRegion,int dx,int dy);
-
-void rfbDoCopyRect(rfbScreenInfoPtr rfbScreen,int x1,int y1,int x2,int y2,int dx,int dy);
-void rfbDoCopyRegion(rfbScreenInfoPtr rfbScreen,sraRegionPtr copyRegion,int dx,int dy);
-
-void rfbMarkRectAsModified(rfbScreenInfoPtr rfbScreen,int x1,int y1,int x2,int y2);
-void rfbMarkRegionAsModified(rfbScreenInfoPtr rfbScreen,sraRegionPtr modRegion);
-void rfbDoNothingWithClient(rfbClientPtr cl);
-enum rfbNewClientAction defaultNewClientHook(rfbClientPtr cl);
-void rfbRegisterProtocolExtension(rfbProtocolExtension* extension);
-void rfbUnregisterProtocolExtension(rfbProtocolExtension* extension);
-struct _rfbProtocolExtension* rfbGetExtensionIterator();
-void rfbReleaseExtensionIterator();
-rfbBool rfbEnableExtension(rfbClientPtr cl, rfbProtocolExtension* extension,
-	void* data);
-rfbBool rfbDisableExtension(rfbClientPtr cl, rfbProtocolExtension* extension);
-void* rfbGetExtensionClientData(rfbClientPtr cl, rfbProtocolExtension* extension);
-
-/** to check against plain passwords */
-rfbBool rfbCheckPasswordByList(rfbClientPtr cl,const char* response,int len);
-
-/* functions to make a vnc server */
-extern rfbScreenInfoPtr rfbGetScreen(int* argc,char** argv,
- int width,int height,int bitsPerSample,int samplesPerPixel,
- int bytesPerPixel);
-extern void rfbInitServer(rfbScreenInfoPtr rfbScreen);
-extern void rfbShutdownServer(rfbScreenInfoPtr rfbScreen,rfbBool disconnectClients);
-extern void rfbNewFramebuffer(rfbScreenInfoPtr rfbScreen,char *framebuffer,
- int width,int height, int bitsPerSample,int samplesPerPixel,
- int bytesPerPixel);
-
-extern void rfbScreenCleanup(rfbScreenInfoPtr screenInfo);
-extern void rfbSetServerVersionIdentity(rfbScreenInfoPtr screen, char *fmt, ...);
-
-/* functions to accept/refuse a client that has been put on hold
-   by a NewClientHookPtr function. Must not be called in other
-   situations. */
-extern void rfbStartOnHoldClient(rfbClientPtr cl);
-extern void rfbRefuseOnHoldClient(rfbClientPtr cl);
-
-/* call one of these two functions to service the vnc clients.
- usec are the microseconds the select on the fds waits.
- if you are using the event loop, set this to some value > 0, so the
- server doesn't get a high load just by listening.
- rfbProcessEvents() returns TRUE if an update was pending. */
-
-extern void rfbRunEventLoop(rfbScreenInfoPtr screenInfo, long usec, rfbBool runInBackground);
-extern rfbBool rfbProcessEvents(rfbScreenInfoPtr screenInfo,long usec);
-extern rfbBool rfbIsActive(rfbScreenInfoPtr screenInfo);
-
-/* TightVNC file transfer extension */
-void rfbRegisterTightVNCFileTransferExtension();
-void rfbUnregisterTightVNCFileTransferExtension();
-
-/* Statistics */
-extern char *messageNameServer2Client(uint32_t type, char *buf, int len);
-extern char *messageNameClient2Server(uint32_t type, char *buf, int len);
-extern char *encodingName(uint32_t enc, char *buf, int len);
-
-extern rfbStatList *rfbStatLookupEncoding(rfbClientPtr cl, uint32_t type);
-extern rfbStatList *rfbStatLookupMessage(rfbClientPtr cl, uint32_t type);
-
-/* Each call to rfbStatRecord* adds one to the rect count for that type */
-extern void rfbStatRecordEncodingSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbStatRecordEncodingSentAdd(rfbClientPtr cl, uint32_t type, int byteCount); /* Specifically for tight encoding */
-extern void rfbStatRecordEncodingRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbStatRecordMessageSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbStatRecordMessageRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbResetStats(rfbClientPtr cl);
-extern void rfbPrintStats(rfbClientPtr cl);
-
-extern int rfbStatGetSentBytes(rfbClientPtr cl);
-extern int rfbStatGetSentBytesIfRaw(rfbClientPtr cl);
-extern int rfbStatGetRcvdBytes(rfbClientPtr cl);
-extern int rfbStatGetRcvdBytesIfRaw(rfbClientPtr cl);
-extern int rfbStatGetMessageCountSent(rfbClientPtr cl, uint32_t type);
-extern int rfbStatGetMessageCountRcvd(rfbClientPtr cl, uint32_t type);
-extern int rfbStatGetEncodingCountSent(rfbClientPtr cl, uint32_t type);
-extern int rfbStatGetEncodingCountRcvd(rfbClientPtr cl, uint32_t type);
-
-/** Set which version you want to advertise 3.3, 3.6, 3.7 and 3.8 are currently supported*/
-extern void rfbSetProtocolVersion(rfbScreenInfoPtr rfbScreen, int major_, int minor_);
-
-/** send a TextChat message to a client */
-extern rfbBool rfbSendTextChatMessage(rfbClientPtr cl, uint32_t length, char *buffer);
-
-
-/*
- * Additions for Qt event loop integration
- * Original idea taken from vino.
- */
-rfbBool rfbProcessNewConnection(rfbScreenInfoPtr rfbScreen);
-rfbBool rfbUpdateClient(rfbClientPtr cl);
-
-
-#if(defined __cplusplus)
-}
-#endif
-
-/**
- * @}
- */
-
-
-/**
- @page libvncserver_doc LibVNCServer Documentation
- @section create_server Creating a server instance
- To make a server, you just have to initialise a server structure using the
- function rfbGetScreen(), like
- @code
-   rfbScreenInfoPtr screen =
-     rfbGetScreen(argc,argv,screenwidth,screenheight,8,3,bpp);
- @endcode
- where byte per pixel should be 1, 2 or 4. If performance doesn't matter,
- you may try bpp=3 (internally one cannot use native data types in this
- case; if you want to use this, look at pnmshow24.c).
-
- You then can set hooks and io functions (see @ref making_it_interactive) or other
- options (see @ref server_options).
-
- And you allocate the frame buffer like this:
- @code
-     screen->frameBuffer = (char*)malloc(screenwidth*screenheight*bpp);
- @endcode
- After that, you initialize the server, like
- @code
-   rfbInitServer(screen);
- @endcode
- You can use a blocking event loop, a background (pthread based) event loop,
- or implement your own using the rfbProcessEvents() function.
-
- @subsection server_options Optional Server Features
-
- These options have to be set between rfbGetScreen() and rfbInitServer().
-
- If you already have a socket to talk to, just set rfbScreenInfo::inetdSock
- (originally this is for inetd handling, but why not use it for your purpose?).
-
- To also start an HTTP server (running on port 5800+display_number), you have
- to set rfbScreenInfo::httpDir to a directory containing vncviewer.jar and
- index.vnc (like the included "classes" directory).
-
- @section making_it_interactive Making it interactive
-
- Whenever you draw something, you have to call
- @code
-  rfbMarkRectAsModified(screen,x1,y1,x2,y2).
- @endcode
- This tells LibVNCServer to send updates to all connected clients.
-
- There exist the following IO functions as members of rfbScreen:
- rfbScreenInfo::kbdAddEvent(), rfbScreenInfo::kbdReleaseAllKeys(), rfbScreenInfo::ptrAddEvent() and rfbScreenInfo::setXCutText()
-
- rfbScreenInfo::kbdAddEvent()
-   is called when a key is pressed.
- rfbScreenInfo::kbdReleaseAllKeys()
-   is not called at all (maybe in the future).
- rfbScreenInfo::ptrAddEvent()
-   is called when the mouse moves or a button is pressed.
-   WARNING: if you want to have proper cursor handling, call
-	rfbDefaultPtrAddEvent()
-   in your own function. This sets the coordinates of the cursor.
- rfbScreenInfo::setXCutText()
-   is called when the selection changes.
-
- There are only two hooks:
- rfbScreenInfo::newClientHook()
-   is called when a new client has connected.
- rfbScreenInfo::displayHook()
-   is called just before a frame buffer update is sent.
-
- You can also override the following methods:
- rfbScreenInfo::getCursorPtr()
-   This could be used to make an animated cursor (if you really want ...)
- rfbScreenInfo::setTranslateFunction()
-   If you insist on colour maps or something more obscure, you have to
-   implement this. Default is a trueColour mapping.
-
- @section cursor_handling Cursor handling
-
- The screen holds a pointer
-  rfbScreenInfo::cursor
- to the current cursor. Whenever you set it, remember that any dynamically
- created cursor (like return value from rfbMakeXCursor()) is not free'd!
-
- The rfbCursor structure consists mainly of a mask and a source. The rfbCursor::mask
- describes, which pixels are drawn for the cursor (a cursor needn't be
- rectangular). The rfbCursor::source describes, which colour those pixels should have.
-
- The standard is an XCursor: a cursor with a foreground and a background
- colour (stored in backRed,backGreen,backBlue and the same for foreground
- in a range from 0-0xffff). Therefore, the arrays "mask" and "source"
- contain pixels as single bits stored in bytes in MSB order. The rows are
- padded, such that each row begins with a new byte (i.e. a 10x4
- cursor's mask has 2x4 bytes, because 2 bytes are needed to hold 10 bits).
-
- It is however very easy to make a cursor like this:
- @code
- char* cur="    "
-           " xx "
-	   " x  "
-	   "    ";
- char* mask="xxxx"
-            "xxxx"
-            "xxxx"
-            "xxx ";
- rfbCursorPtr c=rfbMakeXCursor(4,4,cur,mask);
- @endcode
- You can even set rfbCursor::mask to NULL in this call and LibVNCServer will calculate
- a mask for you (dynamically, so you have to free it yourself).
-
- There is also an array named rfbCursor::richSource for colourful cursors. They have
- the same format as the frameBuffer (i.e. if the server is 32 bit,
- a 10x4 cursor has 4x10x4 bytes).
-
- @section screen_client_difference What is the difference between rfbScreenInfoPtr and rfbClientPtr?
-
- The rfbScreenInfoPtr is a pointer to a rfbScreenInfo structure, which
- holds information about the server, like pixel format, io functions,
- frame buffer etc. The rfbClientPtr is a pointer to an rfbClientRec structure, which holds
- information about a client, like pixel format, socket of the
- connection, etc. A server can have several clients, but needn't have any. So, if you
- have a server and three clients are connected, you have one instance
- of a rfbScreenInfo and three instances of rfbClientRec's.
-
- The rfbClientRec structure holds a member rfbClientRec::screen which points to the server.
- So, to access the server from the client structure, you use client->screen.
-
- To access all clients from a server be sure to use the provided iterator
-  rfbGetClientIterator()
- with
-  rfbClientIteratorNext()
- and
-  rfbReleaseClientIterator()
- to prevent thread clashes.
-
- @section example_code Example Code
-
- There are two documented examples included:
-  - example.c, a shared scribble sheet
-  - pnmshow.c, a program to show PNMs (pictures) over the net.
-
- The examples are not too well documented, but easy straight forward and a
- good starting point.
-
- Try example.c: it outputs on which port it listens (default: 5900), so it is
- display 0. To view, call @code	vncviewer :0 @endcode
- You should see a sheet with a gradient and "Hello World!" written on it. Try
- to paint something. Note that everytime you click, there is some bigger blot,
- whereas when you drag the mouse while clicked you draw a line. The size of the
- blot depends on the mouse button you click. Open a second vncviewer with
- the same parameters and watch it as you paint in the other window. This also
- works over internet. You just have to know either the name or the IP of your
- machine. Then it is @code vncviewer machine.where.example.runs.com:0 @endcode
- or similar for the remote client. Now you are ready to type something. Be sure
- that your mouse sits still, because everytime the mouse moves, the cursor is
- reset to the position of the pointer! If you are done with that demo, press
- the down or up arrows. If your viewer supports it, then the dimensions of the
- sheet change. Just press Escape in the viewer. Note that the server still
- runs, even if you closed both windows. When you reconnect now, everything you
- painted and wrote is still there. You can press "Page Up" for a blank page.
-
- The demo pnmshow.c is much simpler: you either provide a filename as argument
- or pipe a file through stdin. Note that the file has to be a raw pnm/ppm file,
- i.e. a truecolour graphics. Only the Escape key is implemented. This may be
- the best starting point if you want to learn how to use LibVNCServer. You
- are confronted with the fact that the bytes per pixel can only be 8, 16 or 32.
-*/
-
-#endif
diff --git a/libvncserver/rfb/rfbclient.h b/libvncserver/rfb/rfbclient.h
deleted file mode 100644
index 4402039..0000000
--- a/libvncserver/rfb/rfbclient.h
+++ /dev/null
@@ -1,430 +0,0 @@
-#ifndef RFBCLIENT_H
-#define RFBCLIENT_H
-
-/**
- * @defgroup libvncclient_api LibVNCClient API Reference
- * @{
- */
-
-/*
- *  Copyright (C) 2000, 2001 Const Kaplinsky.  All Rights Reserved.
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/**
- * @file rfbclient.h
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/time.h>
-#include <unistd.h>
-#include "rfbproto.h"
-#include "keysym.h"
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-#include <gnutls/gnutls.h>
-#endif
-
-#define rfbClientSwap16IfLE(s) \
-    (*(char *)&client->endianTest ? ((((s) & 0xff) << 8) | (((s) >> 8) & 0xff)) : (s))
-
-#define rfbClientSwap32IfLE(l) \
-    (*(char *)&client->endianTest ? ((((l) & 0xff000000) >> 24) | \
-			     (((l) & 0x00ff0000) >> 8)  | \
-			     (((l) & 0x0000ff00) << 8)  | \
-			     (((l) & 0x000000ff) << 24))  : (l))
-
-#define rfbClientSwap64IfLE(l) \
-    (*(char *)&client->endianTest ? ((((l) & 0xff00000000000000ULL) >> 56) | \
-			     (((l) & 0x00ff000000000000ULL) >> 40)  | \
-			     (((l) & 0x0000ff0000000000ULL) >> 24)  | \
-			     (((l) & 0x000000ff00000000ULL) >> 8)  | \
-			     (((l) & 0x00000000ff000000ULL) << 8)  | \
-			     (((l) & 0x0000000000ff0000ULL) << 24)  | \
-			     (((l) & 0x000000000000ff00ULL) << 40)  | \
-			     (((l) & 0x00000000000000ffULL) << 56))  : (l))
-
-#define FLASH_PORT_OFFSET 5400
-#define LISTEN_PORT_OFFSET 5500
-#define TUNNEL_PORT_OFFSET 5500
-#define SERVER_PORT_OFFSET 5900
-
-#define DEFAULT_SSH_CMD "/usr/bin/ssh"
-#define DEFAULT_TUNNEL_CMD  \
-  (DEFAULT_SSH_CMD " -f -L %L:localhost:%R %H sleep 20")
-#define DEFAULT_VIA_CMD     \
-  (DEFAULT_SSH_CMD " -f -L %L:%H:%R %G sleep 20")
-
-#if(defined __cplusplus)
-extern "C"
-{
-#endif
-
-/** vncrec */
-
-typedef struct {
-  FILE* file;
-  struct timeval tv;
-  rfbBool readTimestamp;
-  rfbBool doNotSleep;
-} rfbVNCRec;
-
-/** client data */
-
-typedef struct rfbClientData {
-	void* tag;
-	void* data;
-	struct rfbClientData* next;
-} rfbClientData;
-
-/** app data (belongs into rfbClient?) */
-
-typedef struct {
-  rfbBool shareDesktop;
-  rfbBool viewOnly;
-
-  const char* encodingsString;
-
-  rfbBool useBGR233;
-  int nColours;
-  rfbBool forceOwnCmap;
-  rfbBool forceTrueColour;
-  int requestedDepth;
-
-  int compressLevel;
-  int qualityLevel;
-  rfbBool enableJPEG;
-  rfbBool useRemoteCursor;
-  rfbBool palmVNC;  /**< use palmvnc specific SetScale (vs ultravnc) */
-  int scaleSetting; /**< 0 means no scale set, else 1/scaleSetting */
-} AppData;
-
-/** For GetCredentialProc callback function to return */
-typedef union _rfbCredential
-{
-  /** X509 (VeNCrypt) */
-  struct
-  {
-    char *x509CACertFile;
-    char *x509CACrlFile;
-    char *x509ClientCertFile;
-    char *x509ClientKeyFile;
-  } x509Credential;
-  /** Plain (VeNCrypt), MSLogon (UltraVNC) */
-  struct
-  {
-    char *username;
-    char *password;
-  } userCredential;
-} rfbCredential;
-
-#define rfbCredentialTypeX509 1
-#define rfbCredentialTypeUser 2
-
-struct _rfbClient;
-
-typedef void (*HandleTextChatProc)(struct _rfbClient* client, int value, char *text);
-typedef void (*HandleXvpMsgProc)(struct _rfbClient* client, uint8_t version, uint8_t opcode);
-typedef void (*HandleKeyboardLedStateProc)(struct _rfbClient* client, int value, int pad);
-typedef rfbBool (*HandleCursorPosProc)(struct _rfbClient* client, int x, int y);
-typedef void (*SoftCursorLockAreaProc)(struct _rfbClient* client, int x, int y, int w, int h);
-typedef void (*SoftCursorUnlockScreenProc)(struct _rfbClient* client);
-typedef void (*GotFrameBufferUpdateProc)(struct _rfbClient* client, int x, int y, int w, int h);
-typedef void (*FinishedFrameBufferUpdateProc)(struct _rfbClient* client);
-typedef char* (*GetPasswordProc)(struct _rfbClient* client);
-typedef rfbCredential* (*GetCredentialProc)(struct _rfbClient* client, int credentialType);
-typedef rfbBool (*MallocFrameBufferProc)(struct _rfbClient* client);
-typedef void (*GotXCutTextProc)(struct _rfbClient* client, const char *text, int textlen);
-typedef void (*BellProc)(struct _rfbClient* client);
-
-typedef void (*GotCursorShapeProc)(struct _rfbClient* client, int xhot, int yhot, int width, int height, int bytesPerPixel);
-typedef void (*GotCopyRectProc)(struct _rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y);
-
-typedef struct _rfbClient {
-	uint8_t* frameBuffer;
-	int width, height;
-
-	int endianTest;
-
-	AppData appData;
-
-	const char* programName;
-	char* serverHost;
-	int serverPort; /**< if -1, then use file recorded by vncrec */
-	rfbBool listenSpecified;
-	int listenPort, flashPort;
-
-	struct {
-		int x, y, w, h;
-	} updateRect;
-
-	/** Note that the CoRRE encoding uses this buffer and assumes it is big enough
-	   to hold 255 * 255 * 32 bits -> 260100 bytes.  640*480 = 307200 bytes.
-	   Hextile also assumes it is big enough to hold 16 * 16 * 32 bits.
-	   Tight encoding assumes BUFFER_SIZE is at least 16384 bytes. */
-
-#define RFB_BUFFER_SIZE (640*480)
-	char buffer[RFB_BUFFER_SIZE];
-
-	/* rfbproto.c */
-
-	int sock;
-	rfbBool canUseCoRRE;
-	rfbBool canUseHextile;
-	char *desktopName;
-	rfbPixelFormat format;
-	rfbServerInitMsg si;
-
-	/* listen.c */
-        int listenSock;
-
-	/* sockets.c */
-#define RFB_BUF_SIZE 8192
-	char buf[RFB_BUF_SIZE];
-	char *bufoutptr;
-	int buffered;
-
-	/* The zlib encoding requires expansion/decompression/deflation of the
-	   compressed data in the "buffer" above into another, result buffer.
-	   However, the size of the result buffer can be determined precisely
-	   based on the bitsPerPixel, height and width of the rectangle.  We
-	   allocate this buffer one time to be the full size of the buffer. */
-
-	/* Ultra Encoding uses this buffer too */
-	
-	int ultra_buffer_size;
-	char *ultra_buffer;
-
-	int raw_buffer_size;
-	char *raw_buffer;
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	z_stream decompStream;
-	rfbBool decompStreamInited;
-#endif
-
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	/*
-	 * Variables for the ``tight'' encoding implementation.
-	 */
-
-	/** Separate buffer for compressed data. */
-#define ZLIB_BUFFER_SIZE 30000
-	char zlib_buffer[ZLIB_BUFFER_SIZE];
-
-	/* Four independent compression streams for zlib library. */
-	z_stream zlibStream[4];
-	rfbBool zlibStreamActive[4];
-
-	/* Filter stuff. Should be initialized by filter initialization code. */
-	rfbBool cutZeros;
-	int rectWidth, rectColors;
-	char tightPalette[256*4];
-	uint8_t tightPrevRow[2048*3*sizeof(uint16_t)];
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-	/** JPEG decoder state. */
-	rfbBool jpegError;
-
-	struct jpeg_source_mgr* jpegSrcManager;
-	void* jpegBufferPtr;
-	size_t jpegBufferLen;
-
-#endif
-#endif
-
-
-	/* cursor.c */
-	uint8_t *rcSource, *rcMask;
-
-	/** private data pointer */
-	rfbClientData* clientData;
-
-	rfbVNCRec* vncRec;
-
-	/* Keyboard State support (is 'Caps Lock' set on the remote display???) */
-	int KeyboardLedStateEnabled;
-	int CurrentKeyboardLedState;
-
-	int canHandleNewFBSize;
-
-	/* hooks */
-	HandleTextChatProc         HandleTextChat;
-	HandleKeyboardLedStateProc HandleKeyboardLedState;
-	HandleCursorPosProc HandleCursorPos;
-	SoftCursorLockAreaProc SoftCursorLockArea;
-	SoftCursorUnlockScreenProc SoftCursorUnlockScreen;
-	GotFrameBufferUpdateProc GotFrameBufferUpdate;
-	FinishedFrameBufferUpdateProc FinishedFrameBufferUpdate;
-	/** the pointer returned by GetPassword will be freed after use! */
-	GetPasswordProc GetPassword;
-	MallocFrameBufferProc MallocFrameBuffer;
-	GotXCutTextProc GotXCutText;
-	BellProc Bell;
-
-	GotCursorShapeProc GotCursorShape;
-	GotCopyRectProc GotCopyRect;
-
-	/** Which messages are supported by the server
-	 * This is a *guess* for most servers.
-	 * (If we can even detect the type of server)
-	 *
-	 * If the server supports the "rfbEncodingSupportedMessages"
-	 * then this will be updated when the encoding is received to
-	 * accurately reflect the servers capabilities.
-	 */
-	rfbSupportedMessages supportedMessages;
-
-	/** negotiated protocol version */
-	int major, minor;
-
-	/** The selected security types */
-	uint32_t authScheme, subAuthScheme;
-
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-	/** The TLS session for Anonymous TLS and VeNCrypt */
-	gnutls_session_t tlsSession;
-#endif
-
-	/** To support security types that requires user input (except VNC password
-	 * authentication), for example VeNCrypt and MSLogon, this callback function
-	 * must be set before the authentication. Otherwise, it implicates that the
-	 * caller application does not support it and related security types should
-	 * be bypassed.
-	 */
-	GetCredentialProc GetCredential;
-
-	/** The 0-terminated security types supported by the client.
-	 * Set by function SetClientAuthSchemes() */
-	uint32_t *clientAuthSchemes;
-
-	/** When the server is a repeater, this specifies the final destination */
-	char *destHost;
-	int destPort;
-
-        /** the QoS IP DSCP for this client */
-        int QoS_DSCP;
-
-        /** hook to handle xvp server messages */
-	HandleXvpMsgProc           HandleXvpMsg;
-} rfbClient;
-
-/* cursor.c */
-
-extern rfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc);
-
-/* listen.c */
-
-extern void listenForIncomingConnections(rfbClient* viewer);
-extern int listenForIncomingConnectionsNoFork(rfbClient* viewer, int usec_timeout);
-
-/* rfbproto.c */
-
-extern rfbBool rfbEnableClientLogging;
-typedef void (*rfbClientLogProc)(const char *format, ...);
-extern rfbClientLogProc rfbClientLog,rfbClientErr;
-extern rfbBool ConnectToRFBServer(rfbClient* client,const char *hostname, int port);
-extern rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort);
-extern void SetClientAuthSchemes(rfbClient* client,const uint32_t *authSchemes, int size);
-extern rfbBool InitialiseRFBConnection(rfbClient* client);
-extern rfbBool SetFormatAndEncodings(rfbClient* client);
-extern rfbBool SendIncrementalFramebufferUpdateRequest(rfbClient* client);
-extern rfbBool SendFramebufferUpdateRequest(rfbClient* client,
-					 int x, int y, int w, int h,
-					 rfbBool incremental);
-extern rfbBool SendScaleSetting(rfbClient* client,int scaleSetting);
-extern rfbBool SendPointerEvent(rfbClient* client,int x, int y, int buttonMask);
-extern rfbBool SendKeyEvent(rfbClient* client,uint32_t key, rfbBool down);
-extern rfbBool SendClientCutText(rfbClient* client,char *str, int len);
-extern rfbBool HandleRFBServerMessage(rfbClient* client);
-
-extern rfbBool TextChatSend(rfbClient* client, char *text);
-extern rfbBool TextChatOpen(rfbClient* client);
-extern rfbBool TextChatClose(rfbClient* client);
-extern rfbBool TextChatFinish(rfbClient* client);
-extern rfbBool PermitServerInput(rfbClient* client, int enabled);
-extern rfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code);
-
-extern void PrintPixelFormat(rfbPixelFormat *format);
-
-extern rfbBool SupportsClient2Server(rfbClient* client, int messageType);
-extern rfbBool SupportsServer2Client(rfbClient* client, int messageType);
-
-/* client data */
-
-void rfbClientSetClientData(rfbClient* client, void* tag, void* data);
-void* rfbClientGetClientData(rfbClient* client, void* tag);
-
-/* protocol extensions */
-
-typedef struct _rfbClientProtocolExtension {
-	int* encodings;
-	/** returns TRUE if the encoding was handled */
-	rfbBool (*handleEncoding)(rfbClient* cl,
-		rfbFramebufferUpdateRectHeader* rect);
-	/** returns TRUE if it handled the message */
-	rfbBool (*handleMessage)(rfbClient* cl,
-		 rfbServerToClientMsg* message);
-	struct _rfbClientProtocolExtension* next;
-} rfbClientProtocolExtension;
-
-void rfbClientRegisterExtension(rfbClientProtocolExtension* e);
-
-/* sockets.c */
-
-extern rfbBool errorMessageOnReadFailure;
-
-extern rfbBool ReadFromRFBServer(rfbClient* client, char *out, unsigned int n);
-extern rfbBool WriteToRFBServer(rfbClient* client, char *buf, int n);
-extern int FindFreeTcpPort(void);
-extern int ListenAtTcpPort(int port);
-extern int ConnectClientToTcpAddr(unsigned int host, int port);
-extern int ConnectClientToTcpAddr6(const char *hostname, int port);
-extern int ConnectClientToUnixSock(const char *sockFile);
-extern int AcceptTcpConnection(int listenSock);
-extern rfbBool SetNonBlocking(int sock);
-extern rfbBool SetDSCP(int sock, int dscp);
-
-extern rfbBool StringToIPAddr(const char *str, unsigned int *addr);
-extern rfbBool SameMachine(int sock);
-extern int WaitForMessage(rfbClient* client,unsigned int usecs);
-
-/* vncviewer.c */
-rfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,int bytesPerPixel);
-rfbBool rfbInitClient(rfbClient* client,int* argc,char** argv);
-/** rfbClientCleanup() does not touch client->frameBuffer */
-void rfbClientCleanup(rfbClient* client);
-
-#if(defined __cplusplus)
-}
-#endif
-
-/**
- * @}
- */
-
-/**
- @page libvncclient_doc LibVNCClient Documentation
- @section example_code Example Code
- See SDLvncviewer.c for a rather complete client example.
-*/
-
-#endif
diff --git a/libvncserver/rfb/rfbproto.h b/libvncserver/rfb/rfbproto.h
deleted file mode 100644
index 07b7f0d..0000000
--- a/libvncserver/rfb/rfbproto.h
+++ /dev/null
@@ -1,1431 +0,0 @@
-#ifndef RFBPROTO_H
-#define RFBPROTO_H
-
-/**
- @mainpage
- @li @ref libvncserver_api
- @li @ref libvncserver_doc
-
-
- @li @ref libvncclient_api
- @li @ref libvncclient_doc
-
-*/
-
-/*
- *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin
- *  Copyright (C) 2000-2002 Constantin Kaplinsky.  All Rights Reserved.
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * rfbproto.h - header file for the RFB protocol version 3.3
- *
- * Uses types CARD<n> for an n-bit unsigned integer, INT<n> for an n-bit signed
- * integer (for n = 8, 16 and 32).
- *
- * All multiple byte integers are in big endian (network) order (most
- * significant byte first).  Unless noted otherwise there is no special
- * alignment of protocol structures.
- *
- *
- * Once the initial handshaking is done, all messages start with a type byte,
- * (usually) followed by message-specific data.  The order of definitions in
- * this file is as follows:
- *
- *  (1) Structures used in several types of message.
- *  (2) Structures used in the initial handshaking.
- *  (3) Message types.
- *  (4) Encoding types.
- *  (5) For each message type, the form of the data following the type byte.
- *      Sometimes this is defined by a single structure but the more complex
- *      messages have to be explained by comments.
- */
-
-
-#if defined(WIN32) && !defined(__MINGW32__)
-#define LIBVNCSERVER_WORDS_BIGENDIAN
-#define rfbBool int
-#include <sys/timeb.h>
-#include <winsock.h>
-#undef SOCKET
-#define SOCKET int
-#else
-#include <libvncserver-config.h>
-#include <stdint.h>
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#include <zlib.h>
-#ifdef __CHECKER__
-#undef Z_NULL
-#define Z_NULL NULL
-#endif
-#endif
-
-/* some autotool versions do not properly prefix
-   WORDS_BIGENDIAN, so do that manually */
-#ifdef WORDS_BIGENDIAN
-#define LIBVNCSERVER_WORDS_BIGENDIAN
-#endif
-
-/* MS compilers don't have strncasecmp */
-#ifdef _MSC_VER
-#define strncasecmp _strnicmp
-#endif
-
-#if !defined(WIN32) || defined(__MINGW32__)
-#define max(a,b) (((a)>(b))?(a):(b))
-#ifdef LIBVNCSERVER_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#endif
-#define SOCKET int
-typedef int8_t rfbBool;
-#undef FALSE
-#define FALSE 0
-#undef TRUE
-#define TRUE -1
-#endif
-
-typedef uint32_t rfbKeySym;
-typedef uint32_t rfbPixel;
-
-#ifdef LIBVNCSERVER_NEED_INADDR_T
-typedef uint32_t in_addr_t;
-#endif
-
-#ifndef INADDR_NONE
-#define                INADDR_NONE     ((in_addr_t) 0xffffffff)
-#endif
-
-#define MAX_ENCODINGS 21
-
-/*****************************************************************************
- *
- * Structures used in several messages
- *
- *****************************************************************************/
-
-/*-----------------------------------------------------------------------------
- * Structure used to specify a rectangle.  This structure is a multiple of 4
- * bytes so that it can be interspersed with 32-bit pixel data without
- * affecting alignment.
- */
-
-typedef struct {
-    uint16_t x;
-    uint16_t y;
-    uint16_t w;
-    uint16_t h;
-} rfbRectangle;
-
-#define sz_rfbRectangle 8
-
-
-/*-----------------------------------------------------------------------------
- * Structure used to specify pixel format.
- */
-
-typedef struct {
-
-    uint8_t bitsPerPixel;		/* 8,16,32 only */
-
-    uint8_t depth;		/* 8 to 32 */
-
-    uint8_t bigEndian;		/* True if multi-byte pixels are interpreted
-				   as big endian, or if single-bit-per-pixel
-				   has most significant bit of the byte
-				   corresponding to first (leftmost) pixel. Of
-				   course this is meaningless for 8 bits/pix */
-
-    uint8_t trueColour;		/* If false then we need a "colour map" to
-				   convert pixels to RGB.  If true, xxxMax and
-				   xxxShift specify bits used for red, green
-				   and blue */
-
-    /* the following fields are only meaningful if trueColour is true */
-
-    uint16_t redMax;		/* maximum red value (= 2^n - 1 where n is the
-				   number of bits used for red). Note this
-				   value is always in big endian order. */
-
-    uint16_t greenMax;		/* similar for green */
-
-    uint16_t blueMax;		/* and blue */
-
-    uint8_t redShift;		/* number of shifts needed to get the red
-				   value in a pixel to the least significant
-				   bit. To find the red value from a given
-				   pixel, do the following:
-				   1) Swap pixel value according to bigEndian
-				      (e.g. if bigEndian is false and host byte
-				      order is big endian, then swap).
-				   2) Shift right by redShift.
-				   3) AND with redMax (in host byte order).
-				   4) You now have the red value between 0 and
-				      redMax. */
-
-    uint8_t greenShift;		/* similar for green */
-
-    uint8_t blueShift;		/* and blue */
-
-    uint8_t pad1;
-    uint16_t pad2;
-
-} rfbPixelFormat;
-
-#define sz_rfbPixelFormat 16
-
-/* UltraVNC: Color settings values */
-#define rfbPFFullColors		0
-#define rfbPF256Colors		1
-#define rfbPF64Colors		2
-#define rfbPF8Colors		3
-#define rfbPF8GreyColors	4
-#define rfbPF4GreyColors	5
-#define rfbPF2GreyColors	6
-
-
-/*****************************************************************************
- *
- * Initial handshaking messages
- *
- *****************************************************************************/
-
-/*-----------------------------------------------------------------------------
- * Protocol Version
- *
- * The server always sends 12 bytes to start which identifies the latest RFB
- * protocol version number which it supports.  These bytes are interpreted
- * as a string of 12 ASCII characters in the format "RFB xxx.yyy\n" where
- * xxx and yyy are the major and minor version numbers (for version 3.3
- * this is "RFB 003.003\n").
- *
- * The client then replies with a similar 12-byte message giving the version
- * number of the protocol which should actually be used (which may be different
- * to that quoted by the server).
- *
- * It is intended that both clients and servers may provide some level of
- * backwards compatibility by this mechanism.  Servers in particular should
- * attempt to provide backwards compatibility, and even forwards compatibility
- * to some extent.  For example if a client demands version 3.1 of the
- * protocol, a 3.0 server can probably assume that by ignoring requests for
- * encoding types it doesn't understand, everything will still work OK.  This
- * will probably not be the case for changes in the major version number.
- *
- * The format string below can be used in sprintf or sscanf to generate or
- * decode the version string respectively.
- */
-
-#define rfbProtocolVersionFormat "RFB %03d.%03d\n"
-#define rfbProtocolMajorVersion 3
-#define rfbProtocolMinorVersion 8
-/* UltraVNC Viewer examines rfbProtocolMinorVersion number (4, and 6)
- * to identify if the server supports File Transfer
- */
-
-typedef char rfbProtocolVersionMsg[13];	/* allow extra byte for null */
-
-#define sz_rfbProtocolVersionMsg 12
-
-/*
- * Negotiation of the security type (protocol version 3.7)
- *
- * Once the protocol version has been decided, the server either sends a list
- * of supported security types, or informs the client about an error (when the
- * number of security types is 0).  Security type rfbSecTypeTight is used to
- * enable TightVNC-specific protocol extensions.  The value rfbSecTypeVncAuth
- * stands for classic VNC authentication.
- *
- * The client selects a particular security type from the list provided by the
- * server.
- */
-
-#define rfbSecTypeInvalid 0
-#define rfbSecTypeNone 1
-#define rfbSecTypeVncAuth 2
-
-
-/*-----------------------------------------------------------------------------
- * Authentication
- *
- * Once the protocol version has been decided, the server then sends a 32-bit
- * word indicating whether any authentication is needed on the connection.
- * The value of this word determines the authentication scheme in use.  For
- * version 3.0 of the protocol this may have one of the following values:
- */
-
-#define rfbConnFailed 0
-#define rfbNoAuth 1
-#define rfbVncAuth 2
-
-#define rfbRA2 5
-#define rfbRA2ne 6
-#define rfbSSPI 7
-#define rfbSSPIne 8
-#define rfbTight 16
-#define rfbUltra 17
-#define rfbTLS 18
-#define rfbVeNCrypt 19
-#define rfbARD 30
-#define rfbMSLogon 0xfffffffa
-
-#define rfbVeNCryptPlain 256
-#define rfbVeNCryptTLSNone 257
-#define rfbVeNCryptTLSVNC 258
-#define rfbVeNCryptTLSPlain 259
-#define rfbVeNCryptX509None 260
-#define rfbVeNCryptX509VNC 261
-#define rfbVeNCryptX509Plain 262
-#define rfbVeNCryptX509SASL 263
-#define rfbVeNCryptTLSSASL 264
-
-/*
- * rfbConnFailed:	For some reason the connection failed (e.g. the server
- *			cannot support the desired protocol version).  This is
- *			followed by a string describing the reason (where a
- *			string is specified as a 32-bit length followed by that
- *			many ASCII characters).
- *
- * rfbNoAuth:		No authentication is needed.
- *
- * rfbVncAuth:		The VNC authentication scheme is to be used.  A 16-byte
- *			challenge follows, which the client encrypts as
- *			appropriate using the password and sends the resulting
- *			16-byte response.  If the response is correct, the
- *			server sends the 32-bit word rfbVncAuthOK.  If a simple
- *			failure happens, the server sends rfbVncAuthFailed and
- *			closes the connection. If the server decides that too
- *			many failures have occurred, it sends rfbVncAuthTooMany
- *			and closes the connection.  In the latter case, the
- *			server should not allow an immediate reconnection by
- *			the client.
- */
-
-#define rfbVncAuthOK 0
-#define rfbVncAuthFailed 1
-#define rfbVncAuthTooMany 2
-
-
-/*-----------------------------------------------------------------------------
- * Client Initialisation Message
- *
- * Once the client and server are sure that they're happy to talk to one
- * another, the client sends an initialisation message.  At present this
- * message only consists of a boolean indicating whether the server should try
- * to share the desktop by leaving other clients connected, or give exclusive
- * access to this client by disconnecting all other clients.
- */
-
-typedef struct {
-    uint8_t shared;
-} rfbClientInitMsg;
-
-#define sz_rfbClientInitMsg 1
-
-
-/*-----------------------------------------------------------------------------
- * Server Initialisation Message
- *
- * After the client initialisation message, the server sends one of its own.
- * This tells the client the width and height of the server's framebuffer,
- * its pixel format and the name associated with the desktop.
- */
-
-typedef struct {
-    uint16_t framebufferWidth;
-    uint16_t framebufferHeight;
-    rfbPixelFormat format;	/* the server's preferred pixel format */
-    uint32_t nameLength;
-    /* followed by char name[nameLength] */
-} rfbServerInitMsg;
-
-#define sz_rfbServerInitMsg (8 + sz_rfbPixelFormat)
-
-
-/*
- * Following the server initialisation message it's up to the client to send
- * whichever protocol messages it wants.  Typically it will send a
- * SetPixelFormat message and a SetEncodings message, followed by a
- * FramebufferUpdateRequest.  From then on the server will send
- * FramebufferUpdate messages in response to the client's
- * FramebufferUpdateRequest messages.  The client should send
- * FramebufferUpdateRequest messages with incremental set to true when it has
- * finished processing one FramebufferUpdate and is ready to process another.
- * With a fast client, the rate at which FramebufferUpdateRequests are sent
- * should be regulated to avoid hogging the network.
- */
-
-
-
-/*****************************************************************************
- *
- * Message types
- *
- *****************************************************************************/
-
-/* server -> client */
-
-#define rfbFramebufferUpdate 0
-#define rfbSetColourMapEntries 1
-#define rfbBell 2
-#define rfbServerCutText 3
-/* Modif sf@2002 */
-#define rfbResizeFrameBuffer 4
-#define rfbPalmVNCReSizeFrameBuffer 0xF
-
-/* client -> server */
-
-#define rfbSetPixelFormat 0
-#define rfbFixColourMapEntries 1	/* not currently supported */
-#define rfbSetEncodings 2
-#define rfbFramebufferUpdateRequest 3
-#define rfbKeyEvent 4
-#define rfbPointerEvent 5
-#define rfbClientCutText 6
-/* Modif sf@2002 - actually bidirectionnal */
-#define rfbFileTransfer 7
-/* Modif sf@2002 */
-#define rfbSetScale 8
-/* Modif rdv@2002 */
-#define rfbSetServerInput	9
-/* Modif rdv@2002 */
-#define rfbSetSW	10
-/* Modif sf@2002 - TextChat - Bidirectionnal */
-#define rfbTextChat	11
-/* Modif cs@2005 */
-/* PalmVNC 1.4 & 2.0 SetScale Factor message */
-#define rfbPalmVNCSetScaleFactor 0xF
-/* Xvp message - bidirectional */
-#define rfbXvp 250
-
-
-
-
-/*****************************************************************************
- *
- * Encoding types
- *
- *****************************************************************************/
-
-#define rfbEncodingRaw 0
-#define rfbEncodingCopyRect 1
-#define rfbEncodingRRE 2
-#define rfbEncodingCoRRE 4
-#define rfbEncodingHextile 5
-#define rfbEncodingZlib 6
-#define rfbEncodingTight 7
-#define rfbEncodingZlibHex 8
-#define rfbEncodingUltra 9
-#define rfbEncodingZRLE 16
-#define rfbEncodingZYWRLE 17
-
-/* Cache & XOR-Zlib - rdv@2002 */
-#define rfbEncodingCache                 0xFFFF0000
-#define rfbEncodingCacheEnable           0xFFFF0001
-#define rfbEncodingXOR_Zlib              0xFFFF0002
-#define rfbEncodingXORMonoColor_Zlib     0xFFFF0003
-#define rfbEncodingXORMultiColor_Zlib    0xFFFF0004
-#define rfbEncodingSolidColor            0xFFFF0005
-#define rfbEncodingXOREnable             0xFFFF0006
-#define rfbEncodingCacheZip              0xFFFF0007
-#define rfbEncodingSolMonoZip            0xFFFF0008
-#define rfbEncodingUltraZip              0xFFFF0009
-
-/* Xvp pseudo-encoding */
-#define rfbEncodingXvp 			 0xFFFFFECB
-
-/*
- * Special encoding numbers:
- *   0xFFFFFF00 .. 0xFFFFFF0F -- encoding-specific compression levels;
- *   0xFFFFFF10 .. 0xFFFFFF1F -- mouse cursor shape data;
- *   0xFFFFFF20 .. 0xFFFFFF2F -- various protocol extensions;
- *   0xFFFFFF30 .. 0xFFFFFFDF -- not allocated yet;
- *   0xFFFFFFE0 .. 0xFFFFFFEF -- quality level for JPEG compressor;
- *   0xFFFFFFF0 .. 0xFFFFFFFF -- cross-encoding compression levels.
- */
-
-#define rfbEncodingCompressLevel0  0xFFFFFF00
-#define rfbEncodingCompressLevel1  0xFFFFFF01
-#define rfbEncodingCompressLevel2  0xFFFFFF02
-#define rfbEncodingCompressLevel3  0xFFFFFF03
-#define rfbEncodingCompressLevel4  0xFFFFFF04
-#define rfbEncodingCompressLevel5  0xFFFFFF05
-#define rfbEncodingCompressLevel6  0xFFFFFF06
-#define rfbEncodingCompressLevel7  0xFFFFFF07
-#define rfbEncodingCompressLevel8  0xFFFFFF08
-#define rfbEncodingCompressLevel9  0xFFFFFF09
-
-#define rfbEncodingXCursor         0xFFFFFF10
-#define rfbEncodingRichCursor      0xFFFFFF11
-#define rfbEncodingPointerPos      0xFFFFFF18
-
-#define rfbEncodingLastRect           0xFFFFFF20
-#define rfbEncodingNewFBSize          0xFFFFFF21
-
-#define rfbEncodingQualityLevel0   0xFFFFFFE0
-#define rfbEncodingQualityLevel1   0xFFFFFFE1
-#define rfbEncodingQualityLevel2   0xFFFFFFE2
-#define rfbEncodingQualityLevel3   0xFFFFFFE3
-#define rfbEncodingQualityLevel4   0xFFFFFFE4
-#define rfbEncodingQualityLevel5   0xFFFFFFE5
-#define rfbEncodingQualityLevel6   0xFFFFFFE6
-#define rfbEncodingQualityLevel7   0xFFFFFFE7
-#define rfbEncodingQualityLevel8   0xFFFFFFE8
-#define rfbEncodingQualityLevel9   0xFFFFFFE9
-
-
-/* LibVNCServer additions.   We claim 0xFFFE0000 - 0xFFFE00FF */
-#define rfbEncodingKeyboardLedState   0xFFFE0000
-#define rfbEncodingSupportedMessages  0xFFFE0001
-#define rfbEncodingSupportedEncodings 0xFFFE0002
-#define rfbEncodingServerIdentity     0xFFFE0003
-
-
-/*****************************************************************************
- *
- * Server -> client message definitions
- *
- *****************************************************************************/
-
-
-/*-----------------------------------------------------------------------------
- * FramebufferUpdate - a block of rectangles to be copied to the framebuffer.
- *
- * This message consists of a header giving the number of rectangles of pixel
- * data followed by the rectangles themselves.  The header is padded so that
- * together with the type byte it is an exact multiple of 4 bytes (to help
- * with alignment of 32-bit pixels):
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbFramebufferUpdate */
-    uint8_t pad;
-    uint16_t nRects;
-    /* followed by nRects rectangles */
-} rfbFramebufferUpdateMsg;
-
-#define sz_rfbFramebufferUpdateMsg 4
-
-/*
- * Each rectangle of pixel data consists of a header describing the position
- * and size of the rectangle and a type word describing the encoding of the
- * pixel data, followed finally by the pixel data.  Note that if the client has
- * not sent a SetEncodings message then it will only receive raw pixel data.
- * Also note again that this structure is a multiple of 4 bytes.
- */
-
-typedef struct {
-    rfbRectangle r;
-    uint32_t encoding;	/* one of the encoding types rfbEncoding... */
-} rfbFramebufferUpdateRectHeader;
-
-#define sz_rfbFramebufferUpdateRectHeader (sz_rfbRectangle + 4)
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Supported Messages Encoding.  This encoding does not contain any pixel data.
- * Instead, it contains 2 sets of bitflags.  These bitflags indicate what messages
- * are supported by the server.
- * rect->w contains byte count
- */
-
-typedef struct {
-  uint8_t client2server[32]; /* maximum of 256 message types (256/8)=32 */
-  uint8_t server2client[32]; /* maximum of 256 message types (256/8)=32 */
-} rfbSupportedMessages;
-
-#define sz_rfbSupportedMessages 64
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Supported Encodings Encoding.  This encoding does not contain any pixel data.
- * Instead, it contains a list of (uint32_t) Encodings supported by this server.
- * rect->w contains byte count
- * rect->h contains encoding count
- */
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Server Identity Encoding.  This encoding does not contain any pixel data.
- * Instead, it contains a text string containing information about the server.
- * ie: "x11vnc: 0.8.1 lastmod: 2006-04-25 (libvncserver 0.9pre)\0"
- * rect->w contains byte count
- */
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Raw Encoding.  Pixels are sent in top-to-bottom scanline order,
- * left-to-right within a scanline with no padding in between.
- */
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * KeyboardLedState Encoding.  The X coordinate contains the Locked Modifiers
- * so that a remote troubleshooter can identify that the users 'Caps Lock' 
- * is set...   (It helps a *lot* when the users are untrained)
- */
-#define rfbKeyboardMaskShift        1
-#define rfbKeyboardMaskCapsLock     2
-#define rfbKeyboardMaskControl      4
-#define rfbKeyboardMaskAlt          8
-#define rfbKeyboardMaskMeta        16
-#define rfbKeyboardMaskSuper       32
-#define rfbKeyboardMaskHyper       64
-#define rfbKeyboardMaskNumLock    128
-#define rfbKeyboardMaskScrollLock 256
-#define rfbKeyboardMaskAltGraph   512
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * CopyRect Encoding.  The pixels are specified simply by the x and y position
- * of the source rectangle.
- */
-
-typedef struct {
-    uint16_t srcX;
-    uint16_t srcY;
-} rfbCopyRect;
-
-#define sz_rfbCopyRect 4
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * RRE - Rise-and-Run-length Encoding.  We have an rfbRREHeader structure
- * giving the number of subrectangles following.  Finally the data follows in
- * the form [<bgpixel><subrect><subrect>...] where each <subrect> is
- * [<pixel><rfbRectangle>].
- */
-
-typedef struct {
-    uint32_t nSubrects;
-} rfbRREHeader;
-
-#define sz_rfbRREHeader 4
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * CoRRE - Compact RRE Encoding.  We have an rfbRREHeader structure giving
- * the number of subrectangles following.  Finally the data follows in the form
- * [<bgpixel><subrect><subrect>...] where each <subrect> is
- * [<pixel><rfbCoRRERectangle>].  This means that
- * the whole rectangle must be at most 255x255 pixels.
- */
-
-typedef struct {
-    uint8_t x;
-    uint8_t y;
-    uint8_t w;
-    uint8_t h;
-} rfbCoRRERectangle;
-
-#define sz_rfbCoRRERectangle 4
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Hextile Encoding.  The rectangle is divided up into "tiles" of 16x16 pixels,
- * starting at the top left going in left-to-right, top-to-bottom order.  If
- * the width of the rectangle is not an exact multiple of 16 then the width of
- * the last tile in each row will be correspondingly smaller.  Similarly if the
- * height is not an exact multiple of 16 then the height of each tile in the
- * final row will also be smaller.  Each tile begins with a "subencoding" type
- * byte, which is a mask made up of a number of bits.  If the Raw bit is set
- * then the other bits are irrelevant; w*h pixel values follow (where w and h
- * are the width and height of the tile).  Otherwise the tile is encoded in a
- * similar way to RRE, except that the position and size of each subrectangle
- * can be specified in just two bytes.  The other bits in the mask are as
- * follows:
- *
- * BackgroundSpecified - if set, a pixel value follows which specifies
- *    the background colour for this tile.  The first non-raw tile in a
- *    rectangle must have this bit set.  If this bit isn't set then the
- *    background is the same as the last tile.
- *
- * ForegroundSpecified - if set, a pixel value follows which specifies
- *    the foreground colour to be used for all subrectangles in this tile.
- *    If this bit is set then the SubrectsColoured bit must be zero.
- *
- * AnySubrects - if set, a single byte follows giving the number of
- *    subrectangles following.  If not set, there are no subrectangles (i.e.
- *    the whole tile is just solid background colour).
- *
- * SubrectsColoured - if set then each subrectangle is preceded by a pixel
- *    value giving the colour of that subrectangle.  If not set, all
- *    subrectangles are the same colour, the foreground colour;  if the
- *    ForegroundSpecified bit wasn't set then the foreground is the same as
- *    the last tile.
- *
- * The position and size of each subrectangle is specified in two bytes.  The
- * Pack macros below can be used to generate the two bytes from x, y, w, h,
- * and the Extract macros can be used to extract the x, y, w, h values from
- * the two bytes.
- */
-
-#define rfbHextileRaw			(1 << 0)
-#define rfbHextileBackgroundSpecified	(1 << 1)
-#define rfbHextileForegroundSpecified	(1 << 2)
-#define rfbHextileAnySubrects		(1 << 3)
-#define rfbHextileSubrectsColoured	(1 << 4)
-
-#define rfbHextilePackXY(x,y) (((x) << 4) | (y))
-#define rfbHextilePackWH(w,h) ((((w)-1) << 4) | ((h)-1))
-#define rfbHextileExtractX(byte) ((byte) >> 4)
-#define rfbHextileExtractY(byte) ((byte) & 0xf)
-#define rfbHextileExtractW(byte) (((byte) >> 4) + 1)
-#define rfbHextileExtractH(byte) (((byte) & 0xf) + 1)
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * zlib - zlib compressed Encoding.  We have an rfbZlibHeader structure
- * giving the number of bytes following.  Finally the data follows is
- * zlib compressed version of the raw pixel data as negotiated.
- * (NOTE: also used by Ultra Encoding)
- */
-
-typedef struct {
-    uint32_t nBytes;
-} rfbZlibHeader;
-
-#define sz_rfbZlibHeader 4
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Tight Encoding.
- *
- *-- The first byte of each Tight-encoded rectangle is a "compression control
- *   byte". Its format is as follows (bit 0 is the least significant one):
- *
- *   bit 0:    if 1, then compression stream 0 should be reset;
- *   bit 1:    if 1, then compression stream 1 should be reset;
- *   bit 2:    if 1, then compression stream 2 should be reset;
- *   bit 3:    if 1, then compression stream 3 should be reset;
- *   bits 7-4: if 1000 (0x08), then the compression type is "fill",
- *             if 1001 (0x09), then the compression type is "jpeg",
- *             if 0xxx, then the compression type is "basic",
- *             values greater than 1001 are not valid.
- *
- * If the compression type is "basic", then bits 6..4 of the
- * compression control byte (those xxx in 0xxx) specify the following:
- *
- *   bits 5-4:  decimal representation is the index of a particular zlib
- *              stream which should be used for decompressing the data;
- *   bit 6:     if 1, then a "filter id" byte is following this byte.
- *
- *-- The data that follows after the compression control byte described
- * above depends on the compression type ("fill", "jpeg" or "basic").
- *
- *-- If the compression type is "fill", then the only pixel value follows, in
- * client pixel format (see NOTE 1). This value applies to all pixels of the
- * rectangle.
- *
- *-- If the compression type is "jpeg", the following data stream looks like
- * this:
- *
- *   1..3 bytes:  data size (N) in compact representation;
- *   N bytes:     JPEG image.
- *
- * Data size is compactly represented in one, two or three bytes, according
- * to the following scheme:
- *
- *  0xxxxxxx                    (for values 0..127)
- *  1xxxxxxx 0yyyyyyy           (for values 128..16383)
- *  1xxxxxxx 1yyyyyyy zzzzzzzz  (for values 16384..4194303)
- *
- * Here each character denotes one bit, xxxxxxx are the least significant 7
- * bits of the value (bits 0-6), yyyyyyy are bits 7-13, and zzzzzzzz are the
- * most significant 8 bits (bits 14-21). For example, decimal value 10000
- * should be represented as two bytes: binary 10010000 01001110, or
- * hexadecimal 90 4E.
- *
- *-- If the compression type is "basic" and bit 6 of the compression control
- * byte was set to 1, then the next (second) byte specifies "filter id" which
- * tells the decoder what filter type was used by the encoder to pre-process
- * pixel data before the compression. The "filter id" byte can be one of the
- * following:
- *
- *   0:  no filter ("copy" filter);
- *   1:  "palette" filter;
- *   2:  "gradient" filter.
- *
- *-- If bit 6 of the compression control byte is set to 0 (no "filter id"
- * byte), or if the filter id is 0, then raw pixel values in the client
- * format (see NOTE 1) will be compressed. See below details on the
- * compression.
- *
- *-- The "gradient" filter pre-processes pixel data with a simple algorithm
- * which converts each color component to a difference between a "predicted"
- * intensity and the actual intensity. Such a technique does not affect
- * uncompressed data size, but helps to compress photo-like images better. 
- * Pseudo-code for converting intensities to differences is the following:
- *
- *   P[i,j] := V[i-1,j] + V[i,j-1] - V[i-1,j-1];
- *   if (P[i,j] < 0) then P[i,j] := 0;
- *   if (P[i,j] > MAX) then P[i,j] := MAX;
- *   D[i,j] := V[i,j] - P[i,j];
- *
- * Here V[i,j] is the intensity of a color component for a pixel at
- * coordinates (i,j). MAX is the maximum value of intensity for a color
- * component.
- *
- *-- The "palette" filter converts true-color pixel data to indexed colors
- * and a palette which can consist of 2..256 colors. If the number of colors
- * is 2, then each pixel is encoded in 1 bit, otherwise 8 bits is used to
- * encode one pixel. 1-bit encoding is performed such way that the most
- * significant bits correspond to the leftmost pixels, and each raw of pixels
- * is aligned to the byte boundary. When "palette" filter is used, the
- * palette is sent before the pixel data. The palette begins with an unsigned
- * byte which value is the number of colors in the palette minus 1 (i.e. 1
- * means 2 colors, 255 means 256 colors in the palette). Then follows the
- * palette itself which consist of pixel values in client pixel format (see
- * NOTE 1).
- *
- *-- The pixel data is compressed using the zlib library. But if the data
- * size after applying the filter but before the compression is less then 12,
- * then the data is sent as is, uncompressed. Four separate zlib streams
- * (0..3) can be used and the decoder should read the actual stream id from
- * the compression control byte (see NOTE 2).
- *
- * If the compression is not used, then the pixel data is sent as is,
- * otherwise the data stream looks like this:
- *
- *   1..3 bytes:  data size (N) in compact representation;
- *   N bytes:     zlib-compressed data.
- *
- * Data size is compactly represented in one, two or three bytes, just like
- * in the "jpeg" compression method (see above).
- *
- *-- NOTE 1. If the color depth is 24, and all three color components are
- * 8-bit wide, then one pixel in Tight encoding is always represented by
- * three bytes, where the first byte is red component, the second byte is
- * green component, and the third byte is blue component of the pixel color
- * value. This applies to colors in palettes as well.
- *
- *-- NOTE 2. The decoder must reset compression streams' states before
- * decoding the rectangle, if some of bits 0,1,2,3 in the compression control
- * byte are set to 1. Note that the decoder must reset zlib streams even if
- * the compression type is "fill" or "jpeg".
- *
- *-- NOTE 3. The "gradient" filter and "jpeg" compression may be used only
- * when bits-per-pixel value is either 16 or 32, not 8.
- *
- *-- NOTE 4. The width of any Tight-encoded rectangle cannot exceed 2048
- * pixels. If a rectangle is wider, it must be split into several rectangles
- * and each one should be encoded separately.
- *
- */
-
-#define rfbTightExplicitFilter         0x04
-#define rfbTightFill                   0x08
-#define rfbTightJpeg                   0x09
-#define rfbTightMaxSubencoding         0x09
-
-/* Filters to improve compression efficiency */
-#define rfbTightFilterCopy             0x00
-#define rfbTightFilterPalette          0x01
-#define rfbTightFilterGradient         0x02
-
-#endif
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * XCursor encoding. This is a special encoding used to transmit X-style
- * cursor shapes from server to clients. Note that for this encoding,
- * coordinates in rfbFramebufferUpdateRectHeader structure hold hotspot
- * position (r.x, r.y) and cursor size (r.w, r.h). If (w * h != 0), two RGB
- * samples are sent after header in the rfbXCursorColors structure. They
- * denote foreground and background colors of the cursor. If a client
- * supports only black-and-white cursors, it should ignore these colors and
- * assume that foreground is black and background is white. Next, two bitmaps
- * (1 bits per pixel) follow: first one with actual data (value 0 denotes
- * background color, value 1 denotes foreground color), second one with
- * transparency data (bits with zero value mean that these pixels are
- * transparent). Both bitmaps represent cursor data in a byte stream, from
- * left to right, from top to bottom, and each row is byte-aligned. Most
- * significant bits correspond to leftmost pixels. The number of bytes in
- * each row can be calculated as ((w + 7) / 8). If (w * h == 0), cursor
- * should be hidden (or default local cursor should be set by the client).
- */
-
-typedef struct {
-    uint8_t foreRed;
-    uint8_t foreGreen;
-    uint8_t foreBlue;
-    uint8_t backRed;
-    uint8_t backGreen;
-    uint8_t backBlue;
-} rfbXCursorColors;
-
-#define sz_rfbXCursorColors 6
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * RichCursor encoding. This is a special encoding used to transmit cursor
- * shapes from server to clients. It is similar to the XCursor encoding but
- * uses client pixel format instead of two RGB colors to represent cursor
- * image. For this encoding, coordinates in rfbFramebufferUpdateRectHeader
- * structure hold hotspot position (r.x, r.y) and cursor size (r.w, r.h).
- * After header, two pixmaps follow: first one with cursor image in current
- * client pixel format (like in raw encoding), second with transparency data
- * (1 bit per pixel, exactly the same format as used for transparency bitmap
- * in the XCursor encoding). If (w * h == 0), cursor should be hidden (or
- * default local cursor should be set by the client).
- */
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * ZRLE - encoding combining Zlib compression, tiling, palettisation and
- * run-length encoding.
- */
-
-typedef struct {
-    uint32_t length;
-} rfbZRLEHeader;
-
-#define sz_rfbZRLEHeader 4
-
-#define rfbZRLETileWidth 64
-#define rfbZRLETileHeight 64
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * ZLIBHEX - zlib compressed Hextile Encoding.  Essentially, this is the
- * hextile encoding with zlib compression on the tiles that can not be
- * efficiently encoded with one of the other hextile subencodings.  The
- * new zlib subencoding uses two bytes to specify the length of the
- * compressed tile and then the compressed data follows.  As with the
- * raw sub-encoding, the zlib subencoding invalidates the other
- * values, if they are also set.
- */
-
-#define rfbHextileZlibRaw		(1 << 5)
-#define rfbHextileZlibHex		(1 << 6)
-#define rfbHextileZlibMono		(1 << 7)
-
-
-/*-----------------------------------------------------------------------------
- * SetColourMapEntries - these messages are only sent if the pixel
- * format uses a "colour map" (i.e. trueColour false) and the client has not
- * fixed the entire colour map using FixColourMapEntries.  In addition they
- * will only start being sent after the client has sent its first
- * FramebufferUpdateRequest.  So if the client always tells the server to use
- * trueColour then it never needs to process this type of message.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbSetColourMapEntries */
-    uint8_t pad;
-    uint16_t firstColour;
-    uint16_t nColours;
-
-    /* Followed by nColours * 3 * uint16_t
-       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */
-
-} rfbSetColourMapEntriesMsg;
-
-#define sz_rfbSetColourMapEntriesMsg 6
-
-
-
-/*-----------------------------------------------------------------------------
- * Bell - ring a bell on the client if it has one.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbBell */
-} rfbBellMsg;
-
-#define sz_rfbBellMsg 1
-
-
-
-/*-----------------------------------------------------------------------------
- * ServerCutText - the server has new text in its cut buffer.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbServerCutText */
-    uint8_t pad1;
-    uint16_t pad2;
-    uint32_t length;
-    /* followed by char text[length] */
-} rfbServerCutTextMsg;
-
-#define sz_rfbServerCutTextMsg 8
-
-
-/*-----------------------------------------------------------------------------
- * //  Modif sf@2002
- * FileTransferMsg - The client sends FileTransfer message.
- * Bidirectional message - Files can be sent from client to server & vice versa
- */
-
-typedef struct _rfbFileTransferMsg {
-    uint8_t type;			/* always rfbFileTransfer */
-    uint8_t contentType;  /*  See defines below */
-    uint8_t contentParam;/*  Other possible content classification (Dir or File name, etc..) */
-    uint8_t pad;         /* It appears that UltraVNC *forgot* to Swap16IfLE(contentParam) */
-    uint32_t size;		/*  FileSize or packet index or error or other  */
-/*  uint32_t sizeH;		 Additional 32Bits params to handle big values. Only for V2 (we want backward compatibility between all V1 versions) */
-    uint32_t length;
-    /* followed by data char text[length] */
-} rfbFileTransferMsg;
-
-#define sz_rfbFileTransferMsg	12
-
-#define rfbFileTransferVersion  2 /*  v1 is the old FT version ( <= 1.0.0 RC18 versions) */
-
-/*  FileTransfer Content types and Params defines */
-#define rfbDirContentRequest	1 /*  Client asks for the content of a given Server directory */
-#define rfbDirPacket			2 /*  Full directory name or full file name. */
-								  /*  Null content means end of Directory */
-#define rfbFileTransferRequest	3 /*  Client asks the server for the transfer of a given file */
-#define rfbFileHeader			4 /*  First packet of a file transfer, containing file's features */
-#define rfbFilePacket			5 /*  One chunk of the file */
-#define rfbEndOfFile			6 /*  End of file transfer (the file has been received or error) */
-#define rfbAbortFileTransfer	7 /*  The file transfer must be aborted, whatever the state */
-#define rfbFileTransferOffer	8 /*  The client offers to send a file to the server */
-#define rfbFileAcceptHeader		9 /*  The server accepts or rejects the file */
-#define rfbCommand				10 /*  The Client sends a simple command (File Delete, Dir create etc...) */
-#define rfbCommandReturn		11 /*  The Client receives the server's answer about a simple command */
-#define rfbFileChecksums		12 /*  The zipped checksums of the destination file (Delta Transfer) */
-#define rfbFileTransferAccess	14 /*  Request FileTransfer authorization */
-
-								/*  rfbDirContentRequest client Request - content params  */
-#define rfbRDirContent			1 /*  Request a Server Directory contents */
-#define rfbRDrivesList			2 /*  Request the server's drives list */
-#define rfbRDirRecursiveList	3 /*  Request a server directory content recursive sorted list */
-#define rfbRDirRecursiveSize	4 /*  Request a server directory content recursive size */
-
-								/*  rfbDirPacket & rfbCommandReturn  server Answer - content params */
-#define rfbADirectory			1 /*  Reception of a directory name */
-#define rfbAFile				2 /*  Reception of a file name  */
-#define rfbADrivesList			3 /*  Reception of a list of drives */
-#define rfbADirCreate			4 /*  Response to a create dir command  */
-#define rfbADirDelete			5 /*  Response to a delete dir command  */
-#define rfbAFileCreate			6 /*  Response to a create file command  */
-#define rfbAFileDelete			7 /*  Response to a delete file command  */
-#define rfbAFileRename			8 /*  Response to a rename file command  */
-#define rfbADirRename			9 /*  Response to a rename dir command  */
-#define rfbADirRecursiveListItem	10 
-#define rfbADirRecursiveSize		11 
-
-								/*  rfbCommand Command - content params */
-#define rfbCDirCreate			1 /*  Request the server to create the given directory */
-#define rfbCDirDelete			2 /*  Request the server to delete the given directory */
-#define rfbCFileCreate			3 /*  Request the server to create the given file */
-#define rfbCFileDelete			4 /*  Request the server to delete the given file */
-#define rfbCFileRename			5 /*  Request the server to rename the given file  */
-#define rfbCDirRename			6 /*  Request the server to rename the given directory */
-
-								/*  Errors - content params or "size" field */
-#define rfbRErrorUnknownCmd     1  /*  Unknown FileTransfer command. */
-#define rfbRErrorCmd			0xFFFFFFFF/*  Error when a command fails on remote side (ret in "size" field) */
-
-#define sz_rfbBlockSize			8192  /*  Size of a File Transfer packet (before compression) */
-#define rfbZipDirectoryPrefix   "!UVNCDIR-\0" /*  Transfered directory are zipped in a file with this prefix. Must end with "-" */
-#define sz_rfbZipDirectoryPrefix 9 
-#define rfbDirPrefix			"[ "
-#define rfbDirSuffix			" ]"		
-
-
-
-/*-----------------------------------------------------------------------------
- * Modif sf@2002
- * TextChatMsg - Utilized to order the TextChat mode on server or client
- * Bidirectional message
- */
-
-typedef struct _rfbTextChatMsg {
-    uint8_t type;			/* always rfbTextChat */
-    uint8_t pad1;         /*  Could be used later as an additionnal param */
-    uint16_t pad2;		/*  Could be used later as text offset, for instance */
-    uint32_t length;      /*  Specific values for Open, close, finished (-1, -2, -3) */
-    /* followed by char text[length] */
-} rfbTextChatMsg;
-
-#define sz_rfbTextChatMsg 8
-
-#define rfbTextMaxSize		4096
-#define rfbTextChatOpen		0xFFFFFFFF 
-#define rfbTextChatClose	0xFFFFFFFE  
-#define rfbTextChatFinished 0xFFFFFFFD  
-
-
-/*-----------------------------------------------------------------------------
- * Xvp Message
- * Bidirectional message
- * A server which supports the xvp extension declares this by sending a message
- * with an Xvp_INIT xvp-message-code when it receives a request from the client
- * to use the xvp Pseudo-encoding. The server must specify in this message the
- * highest xvp-extension-version it supports: the client may assume that the
- * server supports all versions from 1 up to this value. The client is then
- * free to use any supported version. Currently, only version 1 is defined.
- *
- * A server which subsequently receives an xvp Client Message requesting an
- * operation which it is unable to perform, informs the client of this by
- * sending a message with an Xvp_FAIL xvp-message-code, and the same
- * xvp-extension-version as included in the client's operation request.
- *
- * A client supporting the xvp extension sends this to request that the server
- * initiate a clean shutdown, clean reboot or abrupt reset of the system whose
- * framebuffer the client is displaying.
- */
-
-
-typedef struct {
-    uint8_t type;			/* always rfbXvp */
-	uint8_t pad;
-	uint8_t version;	/* xvp extension version */
-	uint8_t code;      	/* xvp message code */
-} rfbXvpMsg;
-
-#define sz_rfbXvpMsg (4)
-
-/* server message codes */
-#define rfbXvp_Fail 0
-#define rfbXvp_Init 1
-/* client message codes */
-#define rfbXvp_Shutdown 2
-#define rfbXvp_Reboot 3
-#define rfbXvp_Reset 4
-
-
-/*-----------------------------------------------------------------------------
- * Modif sf@2002
- * ResizeFrameBuffer - The Client must change the size of its framebuffer  
- */
-
-typedef struct _rfbResizeFrameBufferMsg {
-    uint8_t type;			/* always rfbResizeFrameBuffer */
-	uint8_t pad1;
-	uint16_t framebufferWidth;	/*  FrameBuffer width */
-	uint16_t framebufferHeigth;	/*  FrameBuffer height */
-} rfbResizeFrameBufferMsg;
-
-#define sz_rfbResizeFrameBufferMsg 6
-
-
-/*-----------------------------------------------------------------------------
- * Copyright (C) 2001 Harakan Software
- * PalmVNC 1.4 & 2.? ResizeFrameBuffer message
- * ReSizeFrameBuffer - tell the RFB client to alter its framebuffer, either
- * due to a resize of the server desktop or a client-requested scaling factor.
- * The pixel format remains unchanged.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbReSizeFrameBuffer */
-	uint8_t pad1;
-	uint16_t desktop_w;	/* Desktop width */
-	uint16_t desktop_h;	/* Desktop height */
-	uint16_t buffer_w;	/* FrameBuffer width */
-	uint16_t buffer_h;	/* Framebuffer height */
-    uint16_t pad2;
-
-} rfbPalmVNCReSizeFrameBufferMsg;
-
-#define sz_rfbPalmVNCReSizeFrameBufferMsg (12)
-
-
-
-
-/*-----------------------------------------------------------------------------
- * Union of all server->client messages.
- */
-
-typedef union {
-    uint8_t type;
-    rfbFramebufferUpdateMsg fu;
-    rfbSetColourMapEntriesMsg scme;
-    rfbBellMsg b;
-    rfbServerCutTextMsg sct;
-	rfbResizeFrameBufferMsg rsfb;
-	rfbPalmVNCReSizeFrameBufferMsg prsfb; 
-	rfbFileTransferMsg ft;
-	rfbTextChatMsg tc;
-        rfbXvpMsg xvp;
-} rfbServerToClientMsg;
-
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * RDV Cache Encoding.  
- * special is not used at this point, can be used to reset cache or other specials
- * just put it to make sure we don't have to change the encoding again.  
- */
-
-typedef struct {
-    uint16_t special;
-} rfbCacheRect;
-
-#define sz_rfbCacheRect 2
-
-
-
-
-/*****************************************************************************
- *
- * Message definitions (client -> server)
- *
- *****************************************************************************/
-
-
-/*-----------------------------------------------------------------------------
- * SetPixelFormat - tell the RFB server the format in which the client wants
- * pixels sent.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbSetPixelFormat */
-    uint8_t pad1;
-    uint16_t pad2;
-    rfbPixelFormat format;
-} rfbSetPixelFormatMsg;
-
-#define sz_rfbSetPixelFormatMsg (sz_rfbPixelFormat + 4)
-
-
-/*-----------------------------------------------------------------------------
- * FixColourMapEntries - when the pixel format uses a "colour map", fix
- * read-only colour map entries.
- *
- *    ***************** NOT CURRENTLY SUPPORTED *****************
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbFixColourMapEntries */
-    uint8_t pad;
-    uint16_t firstColour;
-    uint16_t nColours;
-
-    /* Followed by nColours * 3 * uint16_t
-       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */
-
-} rfbFixColourMapEntriesMsg;
-
-#define sz_rfbFixColourMapEntriesMsg 6
-
-
-/*-----------------------------------------------------------------------------
- * SetEncodings - tell the RFB server which encoding types we accept.  Put them
- * in order of preference, if we have any.  We may always receive raw
- * encoding, even if we don't specify it here.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbSetEncodings */
-    uint8_t pad;
-    uint16_t nEncodings;
-    /* followed by nEncodings * uint32_t encoding types */
-} rfbSetEncodingsMsg;
-
-#define sz_rfbSetEncodingsMsg 4
-
-
-/*-----------------------------------------------------------------------------
- * FramebufferUpdateRequest - request for a framebuffer update.  If incremental
- * is true then the client just wants the changes since the last update.  If
- * false then it wants the whole of the specified rectangle.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbFramebufferUpdateRequest */
-    uint8_t incremental;
-    uint16_t x;
-    uint16_t y;
-    uint16_t w;
-    uint16_t h;
-} rfbFramebufferUpdateRequestMsg;
-
-#define sz_rfbFramebufferUpdateRequestMsg 10
-
-
-/*-----------------------------------------------------------------------------
- * KeyEvent - key press or release
- *
- * Keys are specified using the "keysym" values defined by the X Window System.
- * For most ordinary keys, the keysym is the same as the corresponding ASCII
- * value.  Other common keys are:
- *
- * BackSpace		0xff08
- * Tab			0xff09
- * Return or Enter	0xff0d
- * Escape		0xff1b
- * Insert		0xff63
- * Delete		0xffff
- * Home			0xff50
- * End			0xff57
- * Page Up		0xff55
- * Page Down		0xff56
- * Left			0xff51
- * Up			0xff52
- * Right		0xff53
- * Down			0xff54
- * F1			0xffbe
- * F2			0xffbf
- * ...			...
- * F12			0xffc9
- * Shift		0xffe1
- * Control		0xffe3
- * Meta			0xffe7
- * Alt			0xffe9
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbKeyEvent */
-    uint8_t down;			/* true if down (press), false if up */
-    uint16_t pad;
-    uint32_t key;			/* key is specified as an X keysym */
-} rfbKeyEventMsg;
-
-#define sz_rfbKeyEventMsg 8
-
-
-/*-----------------------------------------------------------------------------
- * PointerEvent - mouse/pen move and/or button press.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbPointerEvent */
-    uint8_t buttonMask;		/* bits 0-7 are buttons 1-8, 0=up, 1=down */
-    uint16_t x;
-    uint16_t y;
-} rfbPointerEventMsg;
-
-#define rfbButton1Mask 1
-#define rfbButton2Mask 2
-#define rfbButton3Mask 4
-#define rfbButton4Mask 8
-#define rfbButton5Mask 16
-/* RealVNC 335 method */
-#define rfbWheelUpMask rfbButton4Mask
-#define rfbWheelDownMask rfbButton5Mask
-
-#define sz_rfbPointerEventMsg 6
-
-
-
-/*-----------------------------------------------------------------------------
- * ClientCutText - the client has new text in its cut buffer.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbClientCutText */
-    uint8_t pad1;
-    uint16_t pad2;
-    uint32_t length;
-    /* followed by char text[length] */
-} rfbClientCutTextMsg;
-
-#define sz_rfbClientCutTextMsg 8
-
-
-
-/*-----------------------------------------------------------------------------
- * sf@2002 - Set Server Scale
- * SetServerScale - Server must change the scale of the client buffer.
- */
-
-typedef struct _rfbSetScaleMsg {
-    uint8_t type;			/* always rfbSetScale */
-    uint8_t scale;		/* Scale value 1<sv<n */
-    uint16_t pad;
-} rfbSetScaleMsg;
-
-#define sz_rfbSetScaleMsg 4
-
-
-/*-----------------------------------------------------------------------------
- * Copyright (C) 2001 Harakan Software
- * PalmVNC 1.4 & 2.? SetScale Factor message 
- * SetScaleFactor - tell the RFB server to alter the scale factor for the
- * client buffer.
- */
-typedef struct {
-    uint8_t type;			/* always rfbPalmVNCSetScaleFactor */
-
-    uint8_t scale;		/* Scale factor (positive non-zero integer) */
-    uint16_t pad2;
-} rfbPalmVNCSetScaleFactorMsg;
-
-#define sz_rfbPalmVNCSetScaleFactorMsg (4)
-
-
-/*-----------------------------------------------------------------------------
- * rdv@2002 - Set input status
- * SetServerInput - Server input is dis/enabled
- */
-
-typedef struct _rfbSetServerInputMsg {
-    uint8_t type;			/* always rfbSetScale */
-    uint8_t status;		/* Scale value 1<sv<n */
-    uint16_t pad;
-} rfbSetServerInputMsg;
-
-#define sz_rfbSetServerInputMsg 4
-
-/*-----------------------------------------------------------------------------
- * rdv@2002 - Set SW
- * SetSW - Server SW/full desktop
- */
-
-typedef struct _rfbSetSWMsg {
-    uint8_t type;			/* always rfbSetSW */
-    uint8_t status;		
-    uint16_t x;
-    uint16_t y;
-} rfbSetSWMsg;
-
-#define sz_rfbSetSWMsg 6
-
-
-
-/*-----------------------------------------------------------------------------
- * Union of all client->server messages.
- */
-
-typedef union {
-    uint8_t type;
-    rfbSetPixelFormatMsg spf;
-    rfbFixColourMapEntriesMsg fcme;
-    rfbSetEncodingsMsg se;
-    rfbFramebufferUpdateRequestMsg fur;
-    rfbKeyEventMsg ke;
-    rfbPointerEventMsg pe;
-    rfbClientCutTextMsg cct;
-	rfbSetScaleMsg ssc;
-	rfbPalmVNCSetScaleFactorMsg pssf;
-	rfbSetServerInputMsg sim;
-	rfbFileTransferMsg ft;
-	rfbSetSWMsg sw;
-	rfbTextChatMsg tc;
-        rfbXvpMsg xvp;
-} rfbClientToServerMsg;
-
-/* 
- * vncauth.h - describes the functions provided by the vncauth library.
- */
-
-#define MAXPWLEN 8
-#define CHALLENGESIZE 16
-
-extern int rfbEncryptAndStorePasswd(char *passwd, char *fname);
-extern char *rfbDecryptPasswdFromFile(char *fname);
-extern void rfbRandomBytes(unsigned char *bytes);
-extern void rfbEncryptBytes(unsigned char *bytes, char *passwd);
-
-
-#endif
diff --git a/libvncserver/rfb/rfbregion.h b/libvncserver/rfb/rfbregion.h
deleted file mode 100644
index 53da667..0000000
--- a/libvncserver/rfb/rfbregion.h
+++ /dev/null
@@ -1,65 +0,0 @@
-#ifndef SRAREGION_H
-#define SRAREGION_H
-
-/* -=- SRA - Simple Region Algorithm
- * A simple rectangular region implementation.
- * Copyright (c) 2001 James "Wez" Weatherall, Johannes E. Schindelin
- */
-
-/* -=- sraRect */
-
-typedef struct _rect {
-	int x1;
-	int y1;
-	int x2;
-	int y2;
-} sraRect;
-
-typedef struct sraRegion sraRegion;
-
-/* -=- Region manipulation functions */
-
-extern sraRegion *sraRgnCreate();
-extern sraRegion *sraRgnCreateRect(int x1, int y1, int x2, int y2);
-extern sraRegion *sraRgnCreateRgn(const sraRegion *src);
-
-extern void sraRgnDestroy(sraRegion *rgn);
-extern void sraRgnMakeEmpty(sraRegion *rgn);
-extern rfbBool sraRgnAnd(sraRegion *dst, const sraRegion *src);
-extern void sraRgnOr(sraRegion *dst, const sraRegion *src);
-extern rfbBool sraRgnSubtract(sraRegion *dst, const sraRegion *src);
-
-extern void sraRgnOffset(sraRegion *dst, int dx, int dy);
-
-extern rfbBool sraRgnPopRect(sraRegion *region, sraRect *rect,
-			  unsigned long flags);
-
-extern unsigned long sraRgnCountRects(const sraRegion *rgn);
-extern rfbBool sraRgnEmpty(const sraRegion *rgn);
-
-extern sraRegion *sraRgnBBox(const sraRegion *src);
-
-/* -=- rectangle iterator */
-
-typedef struct sraRectangleIterator {
-  rfbBool reverseX,reverseY;
-  int ptrSize,ptrPos;
-  struct sraSpan** sPtrs;
-} sraRectangleIterator;
-
-extern sraRectangleIterator *sraRgnGetIterator(sraRegion *s);
-extern sraRectangleIterator *sraRgnGetReverseIterator(sraRegion *s,rfbBool reverseX,rfbBool reverseY);
-extern rfbBool sraRgnIteratorNext(sraRectangleIterator *i,sraRect *r);
-extern void sraRgnReleaseIterator(sraRectangleIterator *i);
-
-void sraRgnPrint(const sraRegion *s);
-
-/* -=- Rectangle clipper (for speed) */
-
-extern rfbBool sraClipRect(int *x, int *y, int *w, int *h,
-			int cx, int cy, int cw, int ch);
-
-extern rfbBool sraClipRect2(int *x, int *y, int *x2, int *y2,
-			int cx, int cy, int cx2, int cy2);
-
-#endif
diff --git a/libvncserver/rfbregion.c b/libvncserver/rfbregion.c
deleted file mode 100644
index 5854336..0000000
--- a/libvncserver/rfbregion.c
+++ /dev/null
@@ -1,886 +0,0 @@
-/* -=- sraRegion.c
- * Copyright (c) 2001 James "Wez" Weatherall, Johannes E. Schindelin
- *
- * A general purpose region clipping library
- * Only deals with rectangular regions, though.
- */
-
-#include "rfb/rfb.h"
-#include "rfb/rfbregion.h"
-
-/* -=- Internal Span structure */
-
-struct sraRegion;
-
-typedef struct sraSpan {
-  struct sraSpan *_next;
-  struct sraSpan *_prev;
-  int start;
-  int end;
-  struct sraRegion *subspan;
-} sraSpan;
-
-typedef struct sraRegion {
-  sraSpan front;
-  sraSpan back;
-} sraSpanList;
-
-/* -=- Span routines */
-
-sraSpanList *sraSpanListDup(const sraSpanList *src);
-void sraSpanListDestroy(sraSpanList *list);
-
-static sraSpan *
-sraSpanCreate(int start, int end, const sraSpanList *subspan) {
-  sraSpan *item = (sraSpan*)malloc(sizeof(sraSpan));
-  item->_next = item->_prev = NULL;
-  item->start = start;
-  item->end = end;
-  item->subspan = sraSpanListDup(subspan);
-  return item;
-}
-
-static sraSpan *
-sraSpanDup(const sraSpan *src) {
-  sraSpan *span;
-  if (!src) return NULL;
-  span = sraSpanCreate(src->start, src->end, src->subspan);
-  return span;
-}
-
-static void
-sraSpanInsertAfter(sraSpan *newspan, sraSpan *after) {
-  newspan->_next = after->_next;
-  newspan->_prev = after;
-  after->_next->_prev = newspan;
-  after->_next = newspan;
-}
-
-static void
-sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {
-  newspan->_next = before;
-  newspan->_prev = before->_prev;
-  before->_prev->_next = newspan;
-  before->_prev = newspan;
-}
-
-static void
-sraSpanRemove(sraSpan *span) {
-  span->_prev->_next = span->_next;
-  span->_next->_prev = span->_prev;
-}
-
-static void
-sraSpanDestroy(sraSpan *span) {
-  if (span->subspan) sraSpanListDestroy(span->subspan);
-  free(span);
-}
-
-#ifdef DEBUG
-static void
-sraSpanCheck(const sraSpan *span, const char *text) {
-  /* Check the span is valid! */
-  if (span->start == span->end) {
-    printf(text); 
-    printf(":%d-%d\n", span->start, span->end);
-  }
-}
-#endif
-
-/* -=- SpanList routines */
-
-static void sraSpanPrint(const sraSpan *s);
-
-static void
-sraSpanListPrint(const sraSpanList *l) {
-  sraSpan *curr;
-  if (!l) {
-	  printf("NULL");
-	  return;
-  }
-  curr = l->front._next;
-  printf("[");
-  while (curr != &(l->back)) {
-    sraSpanPrint(curr);
-    curr = curr->_next;
-  }
-  printf("]");
-}
-
-void
-sraSpanPrint(const sraSpan *s) {
-  printf("(%d-%d)", (s->start), (s->end));
-  if (s->subspan)
-    sraSpanListPrint(s->subspan);
-}
-
-static sraSpanList *
-sraSpanListCreate(void) {
-  sraSpanList *item = (sraSpanList*)malloc(sizeof(sraSpanList));
-  item->front._next = &(item->back);
-  item->front._prev = NULL;
-  item->back._prev = &(item->front);
-  item->back._next = NULL;
-  return item;
-}
-
-sraSpanList *
-sraSpanListDup(const sraSpanList *src) {
-  sraSpanList *newlist;
-  sraSpan *newspan, *curr;
-
-  if (!src) return NULL;
-  newlist = sraSpanListCreate();
-  curr = src->front._next;
-  while (curr != &(src->back)) {
-    newspan = sraSpanDup(curr);
-    sraSpanInsertBefore(newspan, &(newlist->back));
-    curr = curr->_next;
-  }
-
-  return newlist;
-}
-
-void
-sraSpanListDestroy(sraSpanList *list) {
-  sraSpan *curr, *next;
-  while (list->front._next != &(list->back)) {
-    curr = list->front._next;
-    next = curr->_next;
-    sraSpanRemove(curr);
-    sraSpanDestroy(curr);
-    curr = next;
-  }
-  free(list);
-}
-
-static void
-sraSpanListMakeEmpty(sraSpanList *list) {
-  sraSpan *curr, *next;
-  while (list->front._next != &(list->back)) {
-    curr = list->front._next;
-    next = curr->_next;
-    sraSpanRemove(curr);
-    sraSpanDestroy(curr);
-    curr = next;
-  }
-  list->front._next = &(list->back);
-  list->front._prev = NULL;
-  list->back._prev = &(list->front);
-  list->back._next = NULL;
-}
-
-static rfbBool
-sraSpanListEqual(const sraSpanList *s1, const sraSpanList *s2) {
-  sraSpan *sp1, *sp2;
-
-  if (!s1) {
-    if (!s2) {
-      return 1;
-    } else {
-      rfbErr("sraSpanListEqual:incompatible spans (only one NULL!)\n");
-      return FALSE;
-    }
-  }
-
-  sp1 = s1->front._next;
-  sp2 = s2->front._next;
-  while ((sp1 != &(s1->back)) &&
-	 (sp2 != &(s2->back))) {
-    if ((sp1->start != sp2->start) ||
-	(sp1->end != sp2->end) ||
-	(!sraSpanListEqual(sp1->subspan, sp2->subspan))) {
-      return 0;
-    }
-    sp1 = sp1->_next;
-    sp2 = sp2->_next;
-  }
-
-  if ((sp1 == &(s1->back)) && (sp2 == &(s2->back))) {
-    return 1;
-  } else {
-    return 0;
-  }    
-}
-
-static rfbBool
-sraSpanListEmpty(const sraSpanList *list) {
-  return (list->front._next == &(list->back));
-}
-
-static unsigned long
-sraSpanListCount(const sraSpanList *list) {
-  sraSpan *curr = list->front._next;
-  unsigned long count = 0;
-  while (curr != &(list->back)) {
-    if (curr->subspan) {
-      count += sraSpanListCount(curr->subspan);
-    } else {
-      count += 1;
-    }
-    curr = curr->_next;
-  }
-  return count;
-}
-
-static void
-sraSpanMergePrevious(sraSpan *dest) {
-  sraSpan *prev = dest->_prev;
- 
-  while ((prev->_prev) &&
-	 (prev->end == dest->start) &&
-	 (sraSpanListEqual(prev->subspan, dest->subspan))) {
-    /*
-    printf("merge_prev:");
-    sraSpanPrint(prev);
-    printf(" & ");
-    sraSpanPrint(dest);
-    printf("\n");
-    */
-    dest->start = prev->start;
-    sraSpanRemove(prev);
-    sraSpanDestroy(prev);
-    prev = dest->_prev;
-  }
-}    
-
-static void
-sraSpanMergeNext(sraSpan *dest) {
-  sraSpan *next = dest->_next;
-  while ((next->_next) &&
-	 (next->start == dest->end) &&
-	 (sraSpanListEqual(next->subspan, dest->subspan))) {
-/*
-	  printf("merge_next:");
-    sraSpanPrint(dest);
-    printf(" & ");
-    sraSpanPrint(next);
-    printf("\n");
-	*/
-    dest->end = next->end;
-    sraSpanRemove(next);
-    sraSpanDestroy(next);
-    next = dest->_next;
-  }
-}
-
-static void
-sraSpanListOr(sraSpanList *dest, const sraSpanList *src) {
-  sraSpan *d_curr, *s_curr;
-  int s_start, s_end;
-
-  if (!dest) {
-    if (!src) {
-      return;
-    } else {
-      rfbErr("sraSpanListOr:incompatible spans (only one NULL!)\n");
-      return;
-    }
-  }
-
-  d_curr = dest->front._next;
-  s_curr = src->front._next;
-  s_start = s_curr->start;
-  s_end = s_curr->end;
-  while (s_curr != &(src->back)) {
-
-    /* - If we are at end of destination list OR
-       If the new span comes before the next destination one */
-    if ((d_curr == &(dest->back)) ||
-		(d_curr->start >= s_end)) {
-      /* - Add the span */
-      sraSpanInsertBefore(sraSpanCreate(s_start, s_end,
-					s_curr->subspan),
-			  d_curr);
-      if (d_curr != &(dest->back))
-	sraSpanMergePrevious(d_curr);
-      s_curr = s_curr->_next;
-      s_start = s_curr->start;
-      s_end = s_curr->end;
-    } else {
-
-      /* - If the new span overlaps the existing one */
-      if ((s_start < d_curr->end) &&
-	  (s_end > d_curr->start)) {
-
-	/* - Insert new span before the existing destination one? */
-	if (s_start < d_curr->start) {
-	  sraSpanInsertBefore(sraSpanCreate(s_start,
-					    d_curr->start,
-					    s_curr->subspan),
-			      d_curr);
-	  sraSpanMergePrevious(d_curr);
-	}
-
-	/* Split the existing span if necessary */
-	if (s_end < d_curr->end) {
-	  sraSpanInsertAfter(sraSpanCreate(s_end,
-					   d_curr->end,
-					   d_curr->subspan),
-			     d_curr);
-	  d_curr->end = s_end;
-	}
-	if (s_start > d_curr->start) {
-	  sraSpanInsertBefore(sraSpanCreate(d_curr->start,
-					    s_start,
-					    d_curr->subspan),
-			      d_curr);
-	  d_curr->start = s_start;
-	}
-
-	/* Recursively OR subspans */
-	sraSpanListOr(d_curr->subspan, s_curr->subspan);
-
-	/* Merge this span with previous or next? */
-	if (d_curr->_prev != &(dest->front))
-	  sraSpanMergePrevious(d_curr);
-	if (d_curr->_next != &(dest->back))
-	  sraSpanMergeNext(d_curr);
-
-	/* Move onto the next pair to compare */
-	if (s_end > d_curr->end) {
-	  s_start = d_curr->end;
-	  d_curr = d_curr->_next;
-	} else {
-	  s_curr = s_curr->_next;
-	  s_start = s_curr->start;
-	  s_end = s_curr->end;
-	}
-      } else {
-	/* - No overlap.  Move to the next destination span */
-	d_curr = d_curr->_next;
-      }
-    }
-  }
-}
-
-static rfbBool
-sraSpanListAnd(sraSpanList *dest, const sraSpanList *src) {
-  sraSpan *d_curr, *s_curr, *d_next;
-
-  if (!dest) {
-    if (!src) {
-      return 1;
-    } else {
-      rfbErr("sraSpanListAnd:incompatible spans (only one NULL!)\n");
-      return FALSE;
-    }
-  }
-
-  d_curr = dest->front._next;
-  s_curr = src->front._next;
-  while ((s_curr != &(src->back)) && (d_curr != &(dest->back))) {
-
-    /* - If we haven't reached a destination span yet then move on */
-    if (d_curr->start >= s_curr->end) {
-      s_curr = s_curr->_next;
-      continue;
-    }
-
-    /* - If we are beyond the current destination span then remove it */
-    if (d_curr->end <= s_curr->start) {
-      sraSpan *next = d_curr->_next;
-      sraSpanRemove(d_curr);
-      sraSpanDestroy(d_curr);
-      d_curr = next;
-      continue;
-    }
-
-    /* - If we partially overlap a span then split it up or remove bits */
-    if (s_curr->start > d_curr->start) {
-      /* - The top bit of the span does not match */
-      d_curr->start = s_curr->start;
-    }
-    if (s_curr->end < d_curr->end) {
-      /* - The end of the span does not match */
-      sraSpanInsertAfter(sraSpanCreate(s_curr->end,
-				       d_curr->end,
-				       d_curr->subspan),
-			 d_curr);
-      d_curr->end = s_curr->end;
-    }
-
-    /* - Now recursively process the affected span */
-    if (!sraSpanListAnd(d_curr->subspan, s_curr->subspan)) {
-      /* - The destination subspan is now empty, so we should remove it */
-		sraSpan *next = d_curr->_next;
-      sraSpanRemove(d_curr);
-      sraSpanDestroy(d_curr);
-      d_curr = next;
-    } else {
-      /* Merge this span with previous or next? */
-      if (d_curr->_prev != &(dest->front))
-	sraSpanMergePrevious(d_curr);
-
-      /* - Move on to the next span */
-      d_next = d_curr;
-      if (s_curr->end >= d_curr->end) {
-	d_next = d_curr->_next;
-      }
-      if (s_curr->end <= d_curr->end) {
-	s_curr = s_curr->_next;
-      }
-      d_curr = d_next;
-    }
-  }
-
-  while (d_curr != &(dest->back)) {
-    sraSpan *next = d_curr->_next;
-    sraSpanRemove(d_curr);
-    sraSpanDestroy(d_curr);
-    d_curr=next;
-  }
-
-  return !sraSpanListEmpty(dest);
-}
-
-static rfbBool
-sraSpanListSubtract(sraSpanList *dest, const sraSpanList *src) {
-  sraSpan *d_curr, *s_curr;
-
-  if (!dest) {
-    if (!src) {
-      return 1;
-    } else {
-      rfbErr("sraSpanListSubtract:incompatible spans (only one NULL!)\n");
-      return FALSE;
-    }
-  }
-
-  d_curr = dest->front._next;
-  s_curr = src->front._next;
-  while ((s_curr != &(src->back)) && (d_curr != &(dest->back))) {
-
-    /* - If we haven't reached a destination span yet then move on */
-    if (d_curr->start >= s_curr->end) {
-      s_curr = s_curr->_next;
-      continue;
-    }
-
-    /* - If we are beyond the current destination span then skip it */
-    if (d_curr->end <= s_curr->start) {
-      d_curr = d_curr->_next;
-      continue;
-    }
-
-    /* - If we partially overlap the current span then split it up */
-    if (s_curr->start > d_curr->start) {
-      sraSpanInsertBefore(sraSpanCreate(d_curr->start,
-					s_curr->start,
-					d_curr->subspan),
-			  d_curr);
-      d_curr->start = s_curr->start;
-    }
-    if (s_curr->end < d_curr->end) {
-      sraSpanInsertAfter(sraSpanCreate(s_curr->end,
-				       d_curr->end,
-				       d_curr->subspan),
-			 d_curr);
-      d_curr->end = s_curr->end;
-    }
-
-    /* - Now recursively process the affected span */
-    if ((!d_curr->subspan) || !sraSpanListSubtract(d_curr->subspan, s_curr->subspan)) {
-      /* - The destination subspan is now empty, so we should remove it */
-      sraSpan *next = d_curr->_next;
-      sraSpanRemove(d_curr);
-      sraSpanDestroy(d_curr);
-      d_curr = next;
-    } else {
-      /* Merge this span with previous or next? */
-      if (d_curr->_prev != &(dest->front))
-	sraSpanMergePrevious(d_curr);
-      if (d_curr->_next != &(dest->back))
-	sraSpanMergeNext(d_curr);
-
-      /* - Move on to the next span */
-      if (s_curr->end > d_curr->end) {
-	d_curr = d_curr->_next;
-      } else {
-	s_curr = s_curr->_next;
-      }
-    }
-  }
-
-  return !sraSpanListEmpty(dest);
-}
-
-/* -=- Region routines */
-
-sraRegion *
-sraRgnCreate(void) {
-  return (sraRegion*)sraSpanListCreate();
-}
-
-sraRegion *
-sraRgnCreateRect(int x1, int y1, int x2, int y2) {
-  sraSpanList *vlist, *hlist;
-  sraSpan *vspan, *hspan;
-
-  /* - Build the horizontal portion of the span */
-  hlist = sraSpanListCreate();
-  hspan = sraSpanCreate(x1, x2, NULL);
-  sraSpanInsertAfter(hspan, &(hlist->front));
-
-  /* - Build the vertical portion of the span */
-  vlist = sraSpanListCreate();
-  vspan = sraSpanCreate(y1, y2, hlist);
-  sraSpanInsertAfter(vspan, &(vlist->front));
-
-  sraSpanListDestroy(hlist);
-
-  return (sraRegion*)vlist;
-}
-
-sraRegion *
-sraRgnCreateRgn(const sraRegion *src) {
-  return (sraRegion*)sraSpanListDup((sraSpanList*)src);
-}
-
-void
-sraRgnDestroy(sraRegion *rgn) {
-  sraSpanListDestroy((sraSpanList*)rgn);
-}
-
-void
-sraRgnMakeEmpty(sraRegion *rgn) {
-  sraSpanListMakeEmpty((sraSpanList*)rgn);
-}
-
-/* -=- Boolean Region ops */
-
-rfbBool
-sraRgnAnd(sraRegion *dst, const sraRegion *src) {
-  return sraSpanListAnd((sraSpanList*)dst, (sraSpanList*)src);
-}
-
-void
-sraRgnOr(sraRegion *dst, const sraRegion *src) {
-  sraSpanListOr((sraSpanList*)dst, (sraSpanList*)src);
-}
-
-rfbBool
-sraRgnSubtract(sraRegion *dst, const sraRegion *src) {
-  return sraSpanListSubtract((sraSpanList*)dst, (sraSpanList*)src);
-}
-
-void
-sraRgnOffset(sraRegion *dst, int dx, int dy) {
-  sraSpan *vcurr, *hcurr;
-
-  vcurr = ((sraSpanList*)dst)->front._next;
-  while (vcurr != &(((sraSpanList*)dst)->back)) {
-    vcurr->start += dy;
-    vcurr->end += dy;
-    
-    hcurr = vcurr->subspan->front._next;
-    while (hcurr != &(vcurr->subspan->back)) {
-      hcurr->start += dx;
-      hcurr->end += dx;
-      hcurr = hcurr->_next;
-    }
-
-    vcurr = vcurr->_next;
-  }
-}
-
-sraRegion *sraRgnBBox(const sraRegion *src) {
-  int xmin=((unsigned int)(int)-1)>>1,ymin=xmin,xmax=1-xmin,ymax=xmax;
-  sraSpan *vcurr, *hcurr;
-
-  if(!src)
-    return sraRgnCreate();
-
-  vcurr = ((sraSpanList*)src)->front._next;
-  while (vcurr != &(((sraSpanList*)src)->back)) {
-    if(vcurr->start<ymin)
-      ymin=vcurr->start;
-    if(vcurr->end>ymax)
-      ymax=vcurr->end;
-    
-    hcurr = vcurr->subspan->front._next;
-    while (hcurr != &(vcurr->subspan->back)) {
-      if(hcurr->start<xmin)
-	xmin=hcurr->start;
-      if(hcurr->end>xmax)
-	xmax=hcurr->end;
-      hcurr = hcurr->_next;
-    }
-
-    vcurr = vcurr->_next;
-  }
-
-  if(xmax<xmin || ymax<ymin)
-    return sraRgnCreate();
-
-  return sraRgnCreateRect(xmin,ymin,xmax,ymax);
-}
-
-rfbBool
-sraRgnPopRect(sraRegion *rgn, sraRect *rect, unsigned long flags) {
-  sraSpan *vcurr, *hcurr;
-  sraSpan *vend, *hend;
-  rfbBool right2left = (flags & 2) == 2;
-  rfbBool bottom2top = (flags & 1) == 1;
-
-  /* - Pick correct order */
-  if (bottom2top) {
-    vcurr = ((sraSpanList*)rgn)->back._prev;
-    vend = &(((sraSpanList*)rgn)->front);
-  } else {
-    vcurr = ((sraSpanList*)rgn)->front._next;
-    vend = &(((sraSpanList*)rgn)->back);
-  }
-
-  if (vcurr != vend) {
-    rect->y1 = vcurr->start;
-    rect->y2 = vcurr->end;
-
-    /* - Pick correct order */
-    if (right2left) {
-      hcurr = vcurr->subspan->back._prev;
-      hend = &(vcurr->subspan->front);
-    } else {
-      hcurr = vcurr->subspan->front._next;
-      hend = &(vcurr->subspan->back);
-    }
-
-    if (hcurr != hend) {
-      rect->x1 = hcurr->start;
-      rect->x2 = hcurr->end;
-
-      sraSpanRemove(hcurr);
-      sraSpanDestroy(hcurr);
-      
-      if (sraSpanListEmpty(vcurr->subspan)) {
-	sraSpanRemove(vcurr);
-	sraSpanDestroy(vcurr);
-      }
-
-#if 0
-      printf("poprect:(%dx%d)-(%dx%d)\n",
-	     rect->x1, rect->y1, rect->x2, rect->y2);
-#endif
-      return 1;
-    }
-  }
-
-  return 0;
-}
-
-unsigned long
-sraRgnCountRects(const sraRegion *rgn) {
-  unsigned long count = sraSpanListCount((sraSpanList*)rgn);
-  return count;
-}
-
-rfbBool
-sraRgnEmpty(const sraRegion *rgn) {
-  return sraSpanListEmpty((sraSpanList*)rgn);
-}
-
-/* iterator stuff */
-sraRectangleIterator *sraRgnGetIterator(sraRegion *s)
-{
-  /* these values have to be multiples of 4 */
-#define DEFSIZE 4
-#define DEFSTEP 8
-  sraRectangleIterator *i =
-    (sraRectangleIterator*)malloc(sizeof(sraRectangleIterator));
-  if(!i)
-    return NULL;
-
-  /* we have to recurse eventually. So, the first sPtr is the pointer to
-     the sraSpan in the first level. the second sPtr is the pointer to
-     the sraRegion.back. The third and fourth sPtr are for the second
-     recursion level and so on. */
-  i->sPtrs = (sraSpan**)malloc(sizeof(sraSpan*)*DEFSIZE);
-  if(!i->sPtrs) {
-    free(i);
-    return NULL;
-  }
-  i->ptrSize = DEFSIZE;
-  i->sPtrs[0] = &(s->front);
-  i->sPtrs[1] = &(s->back);
-  i->ptrPos = 0;
-  i->reverseX = 0;
-  i->reverseY = 0;
-  return i;
-}
-
-sraRectangleIterator *sraRgnGetReverseIterator(sraRegion *s,rfbBool reverseX,rfbBool reverseY)
-{
-  sraRectangleIterator *i = sraRgnGetIterator(s);
-  if(reverseY) {
-    i->sPtrs[1] = &(s->front);
-    i->sPtrs[0] = &(s->back);
-  }
-  i->reverseX = reverseX;
-  i->reverseY = reverseY;
-  return(i);
-}
-
-static rfbBool sraReverse(sraRectangleIterator *i)
-{
-  return( ((i->ptrPos&2) && i->reverseX) ||
-     (!(i->ptrPos&2) && i->reverseY));
-}
-
-static sraSpan* sraNextSpan(sraRectangleIterator *i)
-{
-  if(sraReverse(i))
-    return(i->sPtrs[i->ptrPos]->_prev);
-  else
-    return(i->sPtrs[i->ptrPos]->_next);
-}
-
-rfbBool sraRgnIteratorNext(sraRectangleIterator* i,sraRect* r)
-{
-  /* is the subspan finished? */
-  while(sraNextSpan(i) == i->sPtrs[i->ptrPos+1]) {
-    i->ptrPos -= 2;
-    if(i->ptrPos < 0) /* the end */
-      return(0);
-  }
-
-  i->sPtrs[i->ptrPos] = sraNextSpan(i);
-
-  /* is this a new subspan? */
-  while(i->sPtrs[i->ptrPos]->subspan) {
-    if(i->ptrPos+2 > i->ptrSize) { /* array is too small */
-      i->ptrSize += DEFSTEP;
-      i->sPtrs = (sraSpan**)realloc(i->sPtrs, sizeof(sraSpan*)*i->ptrSize);
-    }
-    i->ptrPos =+ 2;
-    if(sraReverse(i)) {
-      i->sPtrs[i->ptrPos]   =   i->sPtrs[i->ptrPos-2]->subspan->back._prev;
-      i->sPtrs[i->ptrPos+1] = &(i->sPtrs[i->ptrPos-2]->subspan->front);
-    } else {
-      i->sPtrs[i->ptrPos]   =   i->sPtrs[i->ptrPos-2]->subspan->front._next;
-      i->sPtrs[i->ptrPos+1] = &(i->sPtrs[i->ptrPos-2]->subspan->back);
-    }
-  }
-
-  if((i->ptrPos%4)!=2) {
-    rfbErr("sraRgnIteratorNext: offset is wrong (%d%%4!=2)\n",i->ptrPos);
-    return FALSE;
-  }
-
-  r->y1 = i->sPtrs[i->ptrPos-2]->start;
-  r->y2 = i->sPtrs[i->ptrPos-2]->end;
-  r->x1 = i->sPtrs[i->ptrPos]->start;
-  r->x2 = i->sPtrs[i->ptrPos]->end;
-
-  return(-1);
-}
-
-void sraRgnReleaseIterator(sraRectangleIterator* i)
-{
-  free(i->sPtrs);
-  free(i);
-}
-
-void
-sraRgnPrint(const sraRegion *rgn) {
-	sraSpanListPrint((sraSpanList*)rgn);
-}
-
-rfbBool
-sraClipRect(int *x, int *y, int *w, int *h,
-	    int cx, int cy, int cw, int ch) {
-  if (*x < cx) {
-    *w -= (cx-*x);
-    *x = cx;
-  }
-  if (*y < cy) {
-    *h -= (cy-*y);
-    *y = cy;
-  }
-  if (*x+*w > cx+cw) {
-    *w = (cx+cw)-*x;
-  }
-  if (*y+*h > cy+ch) {
-    *h = (cy+ch)-*y;
-  }
-  return (*w>0) && (*h>0);
-}
-
-rfbBool
-sraClipRect2(int *x, int *y, int *x2, int *y2,
-	    int cx, int cy, int cx2, int cy2) {
-  if (*x < cx)
-    *x = cx;
-  if (*y < cy)
-    *y = cy;
-  if (*x >= cx2)
-    *x = cx2-1;
-  if (*y >= cy2)
-    *y = cy2-1;
-  if (*x2 <= cx)
-    *x2 = cx+1;
-  if (*y2 <= cy)
-    *y2 = cy+1;
-  if (*x2 > cx2)
-    *x2 = cx2;
-  if (*y2 > cy2)
-    *y2 = cy2;
-  return (*x2>*x) && (*y2>*y);
-}
-
-/* test */
-
-#ifdef SRA_TEST
-/* pipe the output to sort|uniq -u and you'll get the errors. */
-int main(int argc, char** argv)
-{
-  sraRegionPtr region, region1, region2;
-  sraRectangleIterator* i;
-  sraRect rect;
-  rfbBool b;
-
-  region = sraRgnCreateRect(10, 10, 600, 300);
-  region1 = sraRgnCreateRect(40, 50, 350, 200);
-  region2 = sraRgnCreateRect(0, 0, 20, 40);
-
-  sraRgnPrint(region);
-  printf("\n[(10-300)[(10-600)]]\n\n");
-
-  b = sraRgnSubtract(region, region1);
-  printf("%s ",b?"true":"false");
-  sraRgnPrint(region);
-  printf("\ntrue [(10-50)[(10-600)](50-200)[(10-40)(350-600)](200-300)[(10-600)]]\n\n");
-
-  sraRgnOr(region, region2);
-  printf("%ld\n6\n\n", sraRgnCountRects(region));
-
-  i = sraRgnGetIterator(region);
-  while(sraRgnIteratorNext(i, &rect))
-    printf("%dx%d+%d+%d ",
-	   rect.x2-rect.x1,rect.y2-rect.y1,
-	   rect.x1,rect.y1);
-  sraRgnReleaseIterator(i);
-  printf("\n20x10+0+0 600x30+0+10 590x10+10+40 30x150+10+50 250x150+350+50 590x100+10+200 \n\n");
-
-  i = sraRgnGetReverseIterator(region,1,0);
-  while(sraRgnIteratorNext(i, &rect))
-    printf("%dx%d+%d+%d ",
-	   rect.x2-rect.x1,rect.y2-rect.y1,
-	   rect.x1,rect.y1);
-  sraRgnReleaseIterator(i);
-  printf("\n20x10+0+0 600x30+0+10 590x10+10+40 250x150+350+50 30x150+10+50 590x100+10+200 \n\n");
-
-  i = sraRgnGetReverseIterator(region,1,1);
-  while(sraRgnIteratorNext(i, &rect))
-    printf("%dx%d+%d+%d ",
-	   rect.x2-rect.x1,rect.y2-rect.y1,
-	   rect.x1,rect.y1);
-  sraRgnReleaseIterator(i);
-  printf("\n590x100+10+200 250x150+350+50 30x150+10+50 590x10+10+40 600x30+0+10 20x10+0+0 \n\n");
-
-  sraRgnDestroy(region);
-  sraRgnDestroy(region1);
-  sraRgnDestroy(region2);
-
-  return(0);
-}
-#endif
diff --git a/libvncserver/rfbserver.c b/libvncserver/rfbserver.c
deleted file mode 100644
index 42465b1..0000000
--- a/libvncserver/rfbserver.c
+++ /dev/null
@@ -1,3326 +0,0 @@
-/*
- * rfbserver.c - deal with server-side of the RFB protocol.
- */
-
-/*
- *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin
- *  Copyright (C) 2002 RealVNC Ltd.
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#endif
-#include <string.h>
-#include "rfb/rfb.h"
-#include "rfb/rfbregion.h"
-#include "private.h"
-
-#ifdef LIBVNCSERVER_HAVE_FCNTL_H
-#include <fcntl.h>
-#endif
-
-#ifdef WIN32
-#define write(sock,buf,len) send(sock,buf,len,0)
-#else
-#ifdef LIBVNCSERVER_HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <pwd.h>
-#ifdef LIBVNCSERVER_HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <arpa/inet.h>
-#endif
-#endif
-
-#ifdef DEBUGPROTO
-#undef DEBUGPROTO
-#define DEBUGPROTO(x) x
-#else
-#define DEBUGPROTO(x)
-#endif
-#include <stdarg.h>
-#include <scale.h>
-/* stst() */
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-/* readdir() */
-#include <dirent.h>
-/* errno */
-#include <errno.h>
-/* strftime() */
-#include <time.h>
-
-#ifdef __MINGW32__
-static int compat_mkdir(const char *path, int mode)
-{
-	return mkdir(path);
-}
-#define mkdir compat_mkdir
-#endif
-
-static void rfbProcessClientProtocolVersion(rfbClientPtr cl);
-static void rfbProcessClientNormalMessage(rfbClientPtr cl);
-static void rfbProcessClientInitMessage(rfbClientPtr cl);
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-void rfbIncrClientRef(rfbClientPtr cl)
-{
-  LOCK(cl->refCountMutex);
-  cl->refCount++;
-  UNLOCK(cl->refCountMutex);
-}
-
-void rfbDecrClientRef(rfbClientPtr cl)
-{
-  LOCK(cl->refCountMutex);
-  cl->refCount--;
-  if(cl->refCount<=0) /* just to be sure also < 0 */
-    TSIGNAL(cl->deleteCond);
-  UNLOCK(cl->refCountMutex);
-}
-#else
-void rfbIncrClientRef(rfbClientPtr cl) {}
-void rfbDecrClientRef(rfbClientPtr cl) {}
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-static MUTEX(rfbClientListMutex);
-#endif
-
-struct rfbClientIterator {
-  rfbClientPtr next;
-  rfbScreenInfoPtr screen;
-  rfbBool closedToo;
-};
-
-void
-rfbClientListInit(rfbScreenInfoPtr rfbScreen)
-{
-    if(sizeof(rfbBool)!=1) {
-        /* a sanity check */
-        fprintf(stderr,"rfbBool's size is not 1 (%d)!\n",(int)sizeof(rfbBool));
-	/* we cannot continue, because rfbBool is supposed to be char everywhere */
-	exit(1);
-    }
-    rfbScreen->clientHead = NULL;
-    INIT_MUTEX(rfbClientListMutex);
-}
-
-rfbClientIteratorPtr
-rfbGetClientIterator(rfbScreenInfoPtr rfbScreen)
-{
-  rfbClientIteratorPtr i =
-    (rfbClientIteratorPtr)malloc(sizeof(struct rfbClientIterator));
-  i->next = NULL;
-  i->screen = rfbScreen;
-  i->closedToo = FALSE;
-  return i;
-}
-
-rfbClientIteratorPtr
-rfbGetClientIteratorWithClosed(rfbScreenInfoPtr rfbScreen)
-{
-  rfbClientIteratorPtr i =
-    (rfbClientIteratorPtr)malloc(sizeof(struct rfbClientIterator));
-  i->next = NULL;
-  i->screen = rfbScreen;
-  i->closedToo = TRUE;
-  return i;
-}
-
-rfbClientPtr
-rfbClientIteratorHead(rfbClientIteratorPtr i)
-{
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-  if(i->next != 0) {
-    rfbDecrClientRef(i->next);
-    rfbIncrClientRef(i->screen->clientHead);
-  }
-#endif
-  LOCK(rfbClientListMutex);
-  i->next = i->screen->clientHead;
-  UNLOCK(rfbClientListMutex);
-  return i->next;
-}
-
-rfbClientPtr
-rfbClientIteratorNext(rfbClientIteratorPtr i)
-{
-  if(i->next == 0) {
-    LOCK(rfbClientListMutex);
-    i->next = i->screen->clientHead;
-    UNLOCK(rfbClientListMutex);
-  } else {
-    IF_PTHREADS(rfbClientPtr cl = i->next);
-    i->next = i->next->next;
-    IF_PTHREADS(rfbDecrClientRef(cl));
-  }
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    if(!i->closedToo)
-      while(i->next && i->next->sock<0)
-        i->next = i->next->next;
-    if(i->next)
-      rfbIncrClientRef(i->next);
-#endif
-
-    return i->next;
-}
-
-void
-rfbReleaseClientIterator(rfbClientIteratorPtr iterator)
-{
-  IF_PTHREADS(if(iterator->next) rfbDecrClientRef(iterator->next));
-  free(iterator);
-}
-
-
-/*
- * rfbNewClientConnection is called from sockets.c when a new connection
- * comes in.
- */
-
-void
-rfbNewClientConnection(rfbScreenInfoPtr rfbScreen,
-                       int sock)
-{
-    rfbClientPtr cl;
-
-    cl = rfbNewClient(rfbScreen,sock);
-}
-
-
-/*
- * rfbReverseConnection is called to make an outward
- * connection to a "listening" RFB client.
- */
-
-rfbClientPtr
-rfbReverseConnection(rfbScreenInfoPtr rfbScreen,
-                     char *host,
-                     int port)
-{
-    int sock;
-    rfbClientPtr cl;
-
-    if ((sock = rfbConnect(rfbScreen, host, port)) < 0)
-        return (rfbClientPtr)NULL;
-
-    cl = rfbNewClient(rfbScreen, sock);
-
-    if (cl) {
-        cl->reverseConnection = TRUE;
-    }
-
-    return cl;
-}
-
-
-void
-rfbSetProtocolVersion(rfbScreenInfoPtr rfbScreen, int major_, int minor_)
-{
-    /* Permit the server to set the version to report */
-    /* TODO: sanity checking */
-    if ((major_==3) && (minor_ > 2 && minor_ < 9))
-    {
-      rfbScreen->protocolMajorVersion = major_;
-      rfbScreen->protocolMinorVersion = minor_;
-    }
-    else
-        rfbLog("rfbSetProtocolVersion(%d,%d) set to invalid values\n", major_, minor_);
-}
-
-/*
- * rfbNewClient is called when a new connection has been made by whatever
- * means.
- */
-
-static rfbClientPtr
-rfbNewTCPOrUDPClient(rfbScreenInfoPtr rfbScreen,
-                     int sock,
-                     rfbBool isUDP)
-{
-    rfbProtocolVersionMsg pv;
-    rfbClientIteratorPtr iterator;
-    rfbClientPtr cl,cl_;
-    struct sockaddr_in addr;
-    socklen_t addrlen = sizeof(struct sockaddr_in);
-    rfbProtocolExtension* extension;
-
-    cl = (rfbClientPtr)calloc(sizeof(rfbClientRec),1);
-
-    cl->screen = rfbScreen;
-    cl->sock = sock;
-    cl->viewOnly = FALSE;
-    /* setup pseudo scaling */
-    cl->scaledScreen = rfbScreen;
-    cl->scaledScreen->scaledScreenRefCount++;
-
-    rfbResetStats(cl);
-
-    cl->clientData = NULL;
-    cl->clientGoneHook = rfbDoNothingWithClient;
-
-    if(isUDP) {
-      rfbLog(" accepted UDP client\n");
-    } else {
-      int one=1;
-
-      getpeername(sock, (struct sockaddr *)&addr, &addrlen);
-      cl->host = strdup(inet_ntoa(addr.sin_addr));
-
-      rfbLog("  other clients:\n");
-      iterator = rfbGetClientIterator(rfbScreen);
-      while ((cl_ = rfbClientIteratorNext(iterator)) != NULL) {
-        rfbLog("     %s\n",cl_->host);
-      }
-      rfbReleaseClientIterator(iterator);
-
-      if(!rfbSetNonBlocking(sock)) {
-	close(sock);
-	return NULL;
-      }
-
-      if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
-		     (char *)&one, sizeof(one)) < 0) {
-	rfbLogPerror("setsockopt failed");
-	close(sock);
-	return NULL;
-      }
-
-      FD_SET(sock,&(rfbScreen->allFds));
-		rfbScreen->maxFd = max(sock,rfbScreen->maxFd);
-
-      INIT_MUTEX(cl->outputMutex);
-      INIT_MUTEX(cl->refCountMutex);
-      INIT_MUTEX(cl->sendMutex);
-      INIT_COND(cl->deleteCond);
-
-      cl->state = RFB_PROTOCOL_VERSION;
-
-      cl->reverseConnection = FALSE;
-      cl->readyForSetColourMapEntries = FALSE;
-      cl->useCopyRect = FALSE;
-      cl->preferredEncoding = -1;
-      cl->correMaxWidth = 48;
-      cl->correMaxHeight = 48;
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-      cl->zrleData = NULL;
-#endif
-
-      cl->copyRegion = sraRgnCreate();
-      cl->copyDX = 0;
-      cl->copyDY = 0;
-   
-      cl->modifiedRegion =
-	sraRgnCreateRect(0,0,rfbScreen->width,rfbScreen->height);
-
-      INIT_MUTEX(cl->updateMutex);
-      INIT_COND(cl->updateCond);
-
-      cl->requestedRegion = sraRgnCreate();
-
-      cl->format = cl->screen->serverFormat;
-      cl->translateFn = rfbTranslateNone;
-      cl->translateLookupTable = NULL;
-
-      LOCK(rfbClientListMutex);
-
-      IF_PTHREADS(cl->refCount = 0);
-      cl->next = rfbScreen->clientHead;
-      cl->prev = NULL;
-      if (rfbScreen->clientHead)
-        rfbScreen->clientHead->prev = cl;
-
-      rfbScreen->clientHead = cl;
-      UNLOCK(rfbClientListMutex);
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-      cl->tightQualityLevel = -1;
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-      cl->tightCompressLevel = TIGHT_DEFAULT_COMPRESSION;
-      {
-	int i;
-	for (i = 0; i < 4; i++)
-          cl->zsActive[i] = FALSE;
-      }
-#endif
-#endif
-
-      cl->fileTransfer.fd = -1;
-
-      cl->enableCursorShapeUpdates = FALSE;
-      cl->enableCursorPosUpdates = FALSE;
-      cl->useRichCursorEncoding = FALSE;
-      cl->enableLastRectEncoding = FALSE;
-      cl->enableKeyboardLedState = FALSE;
-      cl->enableSupportedMessages = FALSE;
-      cl->enableSupportedEncodings = FALSE;
-      cl->enableServerIdentity = FALSE;
-      cl->lastKeyboardLedState = -1;
-      cl->cursorX = rfbScreen->cursorX;
-      cl->cursorY = rfbScreen->cursorY;
-      cl->useNewFBSize = FALSE;
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-      cl->compStreamInited = FALSE;
-      cl->compStream.total_in = 0;
-      cl->compStream.total_out = 0;
-      cl->compStream.zalloc = Z_NULL;
-      cl->compStream.zfree = Z_NULL;
-      cl->compStream.opaque = Z_NULL;
-
-      cl->zlibCompressLevel = 5;
-#endif
-
-      cl->progressiveSliceY = 0;
-
-      cl->extensions = NULL;
-
-      cl->lastPtrX = -1;
-
-      sprintf(pv,rfbProtocolVersionFormat,rfbScreen->protocolMajorVersion, 
-              rfbScreen->protocolMinorVersion);
-
-      if (rfbWriteExact(cl, pv, sz_rfbProtocolVersionMsg) < 0) {
-        rfbLogPerror("rfbNewClient: write");
-        rfbCloseClient(cl);
-	rfbClientConnectionGone(cl);
-        return NULL;
-      }
-    }
-
-    for(extension = rfbGetExtensionIterator(); extension;
-	    extension=extension->next) {
-	void* data = NULL;
-	/* if the extension does not have a newClient method, it wants
-	 * to be initialized later. */
-	if(extension->newClient && extension->newClient(cl, &data))
-		rfbEnableExtension(cl, extension, data);
-    }
-    rfbReleaseExtensionIterator();
-
-    switch (cl->screen->newClientHook(cl)) {
-    case RFB_CLIENT_ON_HOLD:
-	    cl->onHold = TRUE;
-	    break;
-    case RFB_CLIENT_ACCEPT:
-	    cl->onHold = FALSE;
-	    break;
-    case RFB_CLIENT_REFUSE:
-	    rfbCloseClient(cl);
-	    rfbClientConnectionGone(cl);
-	    cl = NULL;
-	    break;
-    }
-    return cl;
-}
-
-rfbClientPtr
-rfbNewClient(rfbScreenInfoPtr rfbScreen,
-             int sock)
-{
-  return(rfbNewTCPOrUDPClient(rfbScreen,sock,FALSE));
-}
-
-rfbClientPtr
-rfbNewUDPClient(rfbScreenInfoPtr rfbScreen)
-{
-  return((rfbScreen->udpClient=
-	  rfbNewTCPOrUDPClient(rfbScreen,rfbScreen->udpSock,TRUE)));
-}
-
-/*
- * rfbClientConnectionGone is called from sockets.c just after a connection
- * has gone away.
- */
-
-void
-rfbClientConnectionGone(rfbClientPtr cl)
-{
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-    int i;
-#endif
-
-    LOCK(rfbClientListMutex);
-
-    if (cl->prev)
-        cl->prev->next = cl->next;
-    else
-        cl->screen->clientHead = cl->next;
-    if (cl->next)
-        cl->next->prev = cl->prev;
-
-    if(cl->sock>=0)
-	close(cl->sock);
-
-    if (cl->scaledScreen!=NULL)
-        cl->scaledScreen->scaledScreenRefCount--;
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    rfbFreeZrleData(cl);
-#endif
-
-    rfbFreeUltraData(cl);
-
-    /* free buffers holding pixel data before and after encoding */
-    free(cl->beforeEncBuf);
-    free(cl->afterEncBuf);
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    if(cl->screen->backgroundLoop != FALSE) {
-      int i;
-      do {
-	LOCK(cl->refCountMutex);
-	i=cl->refCount;
-	if(i>0)
-	  WAIT(cl->deleteCond,cl->refCountMutex);
-	UNLOCK(cl->refCountMutex);
-      } while(i>0);
-    }
-#endif
-
-    UNLOCK(rfbClientListMutex);
-
-    if(cl->sock>=0)
-       FD_CLR(cl->sock,&(cl->screen->allFds));
-
-    cl->clientGoneHook(cl);
-
-    rfbLog("Client %s gone\n",cl->host);
-    free(cl->host);
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    /* Release the compression state structures if any. */
-    if ( cl->compStreamInited ) {
-	deflateEnd( &(cl->compStream) );
-    }
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-    for (i = 0; i < 4; i++) {
-	if (cl->zsActive[i])
-	    deflateEnd(&cl->zsStruct[i]);
-    }
-#endif
-#endif
-
-    if (cl->screen->pointerClient == cl)
-        cl->screen->pointerClient = NULL;
-
-    sraRgnDestroy(cl->modifiedRegion);
-    sraRgnDestroy(cl->requestedRegion);
-    sraRgnDestroy(cl->copyRegion);
-
-    if (cl->translateLookupTable) free(cl->translateLookupTable);
-
-    TINI_COND(cl->updateCond);
-    TINI_MUTEX(cl->updateMutex);
-
-    /* make sure outputMutex is unlocked before destroying */
-    LOCK(cl->outputMutex);
-    UNLOCK(cl->outputMutex);
-    TINI_MUTEX(cl->outputMutex);
-
-    LOCK(cl->sendMutex);
-    UNLOCK(cl->sendMutex);
-    TINI_MUTEX(cl->sendMutex);
-
-    rfbPrintStats(cl);
-
-    free(cl);
-}
-
-
-/*
- * rfbProcessClientMessage is called when there is data to read from a client.
- */
-
-void
-rfbProcessClientMessage(rfbClientPtr cl)
-{
-    switch (cl->state) {
-    case RFB_PROTOCOL_VERSION:
-        rfbProcessClientProtocolVersion(cl);
-        return;
-    case RFB_SECURITY_TYPE:
-        rfbProcessClientSecurityType(cl);
-        return;
-    case RFB_AUTHENTICATION:
-        rfbAuthProcessClientMessage(cl);
-        return;
-    case RFB_INITIALISATION:
-        rfbProcessClientInitMessage(cl);
-        return;
-    default:
-        rfbProcessClientNormalMessage(cl);
-        return;
-    }
-}
-
-
-/*
- * rfbProcessClientProtocolVersion is called when the client sends its
- * protocol version.
- */
-
-static void
-rfbProcessClientProtocolVersion(rfbClientPtr cl)
-{
-    rfbProtocolVersionMsg pv;
-    int n, major_, minor_;
-
-    if ((n = rfbReadExact(cl, pv, sz_rfbProtocolVersionMsg)) <= 0) {
-        if (n == 0)
-            rfbLog("rfbProcessClientProtocolVersion: client gone\n");
-        else
-            rfbLogPerror("rfbProcessClientProtocolVersion: read");
-        rfbCloseClient(cl);
-        return;
-    }
-
-    pv[sz_rfbProtocolVersionMsg] = 0;
-    if (sscanf(pv,rfbProtocolVersionFormat,&major_,&minor_) != 2) {
-	rfbErr("rfbProcessClientProtocolVersion: not a valid RFB client: %s\n", pv);
-	rfbCloseClient(cl);
-	return;
-    }
-    rfbLog("Client Protocol Version %d.%d\n", major_, minor_);
-
-    if (major_ != rfbProtocolMajorVersion) {
-        rfbErr("RFB protocol version mismatch - server %d.%d, client %d.%d",
-                cl->screen->protocolMajorVersion, cl->screen->protocolMinorVersion,
-                major_,minor_);
-        rfbCloseClient(cl);
-        return;
-    }
-
-    /* Check for the minor version use either of the two standard version of RFB */
-    /*
-     * UltraVNC Viewer detects FileTransfer compatible servers via rfb versions
-     * 3.4, 3.6, 3.14, 3.16
-     * It's a bad method, but it is what they use to enable features...
-     * maintaining RFB version compatibility across multiple servers is a pain
-     * Should use something like ServerIdentity encoding
-     */
-    cl->protocolMajorVersion = major_;
-    cl->protocolMinorVersion = minor_;
-    
-    rfbLog("Protocol version sent %d.%d, using %d.%d\n",
-              major_, minor_, rfbProtocolMajorVersion, cl->protocolMinorVersion);
-
-    rfbAuthNewClient(cl);
-}
-
-
-void
-rfbClientSendString(rfbClientPtr cl, const char *reason)
-{
-    char *buf;
-    int len = strlen(reason);
-
-    rfbLog("rfbClientSendString(\"%s\")\n", reason);
-
-    buf = (char *)malloc(4 + len);
-    ((uint32_t *)buf)[0] = Swap32IfLE(len);
-    memcpy(buf + 4, reason, len);
-
-    if (rfbWriteExact(cl, buf, 4 + len) < 0)
-        rfbLogPerror("rfbClientSendString: write");
-    free(buf);
-
-    rfbCloseClient(cl);
-}
-
-/*
- * rfbClientConnFailed is called when a client connection has failed either
- * because it talks the wrong protocol or it has failed authentication.
- */
-
-void
-rfbClientConnFailed(rfbClientPtr cl,
-                    const char *reason)
-{
-    char *buf;
-    int len = strlen(reason);
-
-    rfbLog("rfbClientConnFailed(\"%s\")\n", reason);
-
-    buf = (char *)malloc(8 + len);
-    ((uint32_t *)buf)[0] = Swap32IfLE(rfbConnFailed);
-    ((uint32_t *)buf)[1] = Swap32IfLE(len);
-    memcpy(buf + 8, reason, len);
-
-    if (rfbWriteExact(cl, buf, 8 + len) < 0)
-        rfbLogPerror("rfbClientConnFailed: write");
-    free(buf);
-
-    rfbCloseClient(cl);
-}
-
-
-/*
- * rfbProcessClientInitMessage is called when the client sends its
- * initialisation message.
- */
-
-static void
-rfbProcessClientInitMessage(rfbClientPtr cl)
-{
-    rfbClientInitMsg ci;
-    union {
-        char buf[256];
-        rfbServerInitMsg si;
-    } u;
-    int len, n;
-    rfbClientIteratorPtr iterator;
-    rfbClientPtr otherCl;
-    rfbExtensionData* extension;
-
-    if ((n = rfbReadExact(cl, (char *)&ci,sz_rfbClientInitMsg)) <= 0) {
-        if (n == 0)
-            rfbLog("rfbProcessClientInitMessage: client gone\n");
-        else
-            rfbLogPerror("rfbProcessClientInitMessage: read");
-        rfbCloseClient(cl);
-        return;
-    }
-
-    memset(u.buf,0,sizeof(u.buf));
-
-    u.si.framebufferWidth = Swap16IfLE(cl->screen->width);
-    u.si.framebufferHeight = Swap16IfLE(cl->screen->height);
-    u.si.format = cl->screen->serverFormat;
-    u.si.format.redMax = Swap16IfLE(u.si.format.redMax);
-    u.si.format.greenMax = Swap16IfLE(u.si.format.greenMax);
-    u.si.format.blueMax = Swap16IfLE(u.si.format.blueMax);
-
-    strncpy(u.buf + sz_rfbServerInitMsg, cl->screen->desktopName, 127);
-    len = strlen(u.buf + sz_rfbServerInitMsg);
-    u.si.nameLength = Swap32IfLE(len);
-
-    if (rfbWriteExact(cl, u.buf, sz_rfbServerInitMsg + len) < 0) {
-        rfbLogPerror("rfbProcessClientInitMessage: write");
-        rfbCloseClient(cl);
-        return;
-    }
-
-    for(extension = cl->extensions; extension;) {
-	rfbExtensionData* next = extension->next;
-	if(extension->extension->init &&
-		!extension->extension->init(cl, extension->data))
-	    /* extension requested that it be removed */
-	    rfbDisableExtension(cl, extension->extension);
-	extension = next;
-    }
-
-    cl->state = RFB_NORMAL;
-
-    if (!cl->reverseConnection &&
-                        (cl->screen->neverShared || (!cl->screen->alwaysShared && !ci.shared))) {
-
-        if (cl->screen->dontDisconnect) {
-            iterator = rfbGetClientIterator(cl->screen);
-            while ((otherCl = rfbClientIteratorNext(iterator)) != NULL) {
-                if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {
-                    rfbLog("-dontdisconnect: Not shared & existing client\n");
-                    rfbLog("  refusing new client %s\n", cl->host);
-                    rfbCloseClient(cl);
-                    rfbReleaseClientIterator(iterator);
-                    return;
-                }
-            }
-            rfbReleaseClientIterator(iterator);
-        } else {
-            iterator = rfbGetClientIterator(cl->screen);
-            while ((otherCl = rfbClientIteratorNext(iterator)) != NULL) {
-                if ((otherCl != cl) && (otherCl->state == RFB_NORMAL)) {
-                    rfbLog("Not shared - closing connection to client %s\n",
-                           otherCl->host);
-                    rfbCloseClient(otherCl);
-                }
-            }
-            rfbReleaseClientIterator(iterator);
-        }
-    }
-}
-
-/* The values come in based on the scaled screen, we need to convert them to
- * values based on the man screen's coordinate system
- */
-static rfbBool rectSwapIfLEAndClip(uint16_t* x,uint16_t* y,uint16_t* w,uint16_t* h,
-		rfbClientPtr cl)
-{
-	int x1=Swap16IfLE(*x);
-	int y1=Swap16IfLE(*y);
-	int w1=Swap16IfLE(*w);
-	int h1=Swap16IfLE(*h);
-
-	rfbScaledCorrection(cl->scaledScreen, cl->screen, &x1, &y1, &w1, &h1, "rectSwapIfLEAndClip");
-	*x = x1;
-	*y = y1;
-	*w = w1;
-	*h = h1;
-
-	if(*w>cl->screen->width-*x)
-		*w=cl->screen->width-*x;
-	/* possible underflow */
-	if(*w>cl->screen->width-*x)
-		return FALSE;
-	if(*h>cl->screen->height-*y)
-		*h=cl->screen->height-*y;
-	if(*h>cl->screen->height-*y)
-		return FALSE;
-
-	return TRUE;
-}
-
-/*
- * Send keyboard state (PointerPos pseudo-encoding).
- */
-
-rfbBool
-rfbSendKeyboardLedState(rfbClientPtr cl)
-{
-    rfbFramebufferUpdateRectHeader rect;
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.encoding = Swap32IfLE(rfbEncodingKeyboardLedState);
-    rect.r.x = Swap16IfLE(cl->lastKeyboardLedState);
-    rect.r.y = 0;
-    rect.r.w = 0;
-    rect.r.h = 0;
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-        sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingKeyboardLedState, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);
-
-    if (!rfbSendUpdateBuf(cl))
-        return FALSE;
-
-    return TRUE;
-}
-
-
-#define rfbSetBit(buffer, position)  (buffer[(position & 255) / 8] |= (1 << (position % 8)))
-
-/*
- * Send rfbEncodingSupportedMessages.
- */
-
-rfbBool
-rfbSendSupportedMessages(rfbClientPtr cl)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    rfbSupportedMessages msgs;
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader
-                  + sz_rfbSupportedMessages > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.encoding = Swap32IfLE(rfbEncodingSupportedMessages);
-    rect.r.x = 0;
-    rect.r.y = 0;
-    rect.r.w = Swap16IfLE(sz_rfbSupportedMessages);
-    rect.r.h = 0;
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-        sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    memset((char *)&msgs, 0, sz_rfbSupportedMessages);
-    rfbSetBit(msgs.client2server, rfbSetPixelFormat);
-    rfbSetBit(msgs.client2server, rfbFixColourMapEntries);
-    rfbSetBit(msgs.client2server, rfbSetEncodings);
-    rfbSetBit(msgs.client2server, rfbFramebufferUpdateRequest);
-    rfbSetBit(msgs.client2server, rfbKeyEvent);
-    rfbSetBit(msgs.client2server, rfbPointerEvent);
-    rfbSetBit(msgs.client2server, rfbClientCutText);
-    rfbSetBit(msgs.client2server, rfbFileTransfer);
-    rfbSetBit(msgs.client2server, rfbSetScale);
-    /*rfbSetBit(msgs.client2server, rfbSetServerInput);  */
-    /*rfbSetBit(msgs.client2server, rfbSetSW);           */
-    /*rfbSetBit(msgs.client2server, rfbTextChat);        */
-    rfbSetBit(msgs.client2server, rfbPalmVNCSetScaleFactor);
-    rfbSetBit(msgs.client2server, rfbXvp);
-
-    rfbSetBit(msgs.server2client, rfbFramebufferUpdate);
-    rfbSetBit(msgs.server2client, rfbSetColourMapEntries);
-    rfbSetBit(msgs.server2client, rfbBell);
-    rfbSetBit(msgs.server2client, rfbServerCutText);
-    rfbSetBit(msgs.server2client, rfbResizeFrameBuffer);
-    rfbSetBit(msgs.server2client, rfbPalmVNCReSizeFrameBuffer);
-    rfbSetBit(msgs.server2client, rfbXvp);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&msgs, sz_rfbSupportedMessages);
-    cl->ublen += sz_rfbSupportedMessages;
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingSupportedMessages,
-        sz_rfbFramebufferUpdateRectHeader+sz_rfbSupportedMessages,
-        sz_rfbFramebufferUpdateRectHeader+sz_rfbSupportedMessages);
-    if (!rfbSendUpdateBuf(cl))
-        return FALSE;
-
-    return TRUE;
-}
-
-
-
-/*
- * Send rfbEncodingSupportedEncodings.
- */
-
-rfbBool
-rfbSendSupportedEncodings(rfbClientPtr cl)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    static uint32_t supported[] = {
-        rfbEncodingRaw,
-	rfbEncodingCopyRect,
-	rfbEncodingRRE,
-	rfbEncodingCoRRE,
-	rfbEncodingHextile,
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	rfbEncodingZlib,
-	rfbEncodingZRLE,
-	rfbEncodingZYWRLE,
-#endif
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-	rfbEncodingTight,
-#endif
-	rfbEncodingUltra,
-	rfbEncodingUltraZip,
-	rfbEncodingXCursor,
-	rfbEncodingRichCursor,
-	rfbEncodingPointerPos,
-	rfbEncodingLastRect,
-	rfbEncodingNewFBSize,
-	rfbEncodingKeyboardLedState,
-	rfbEncodingSupportedMessages,
-	rfbEncodingSupportedEncodings,
-	rfbEncodingServerIdentity,
-    };
-    uint32_t nEncodings = sizeof(supported) / sizeof(supported[0]), i;
-
-    /* think rfbSetEncodingsMsg */
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader
-                  + (nEncodings * sizeof(uint32_t)) > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.encoding = Swap32IfLE(rfbEncodingSupportedEncodings);
-    rect.r.x = 0;
-    rect.r.y = 0;
-    rect.r.w = Swap16IfLE(nEncodings * sizeof(uint32_t));
-    rect.r.h = Swap16IfLE(nEncodings);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-        sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    for (i = 0; i < nEncodings; i++) {
-        uint32_t encoding = Swap32IfLE(supported[i]);
-	memcpy(&cl->updateBuf[cl->ublen], (char *)&encoding, sizeof(encoding));
-	cl->ublen += sizeof(encoding);
-    }
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingSupportedEncodings,
-        sz_rfbFramebufferUpdateRectHeader+(nEncodings * sizeof(uint32_t)),
-        sz_rfbFramebufferUpdateRectHeader+(nEncodings * sizeof(uint32_t)));
-
-    if (!rfbSendUpdateBuf(cl))
-        return FALSE;
-
-    return TRUE;
-}
-
-
-void
-rfbSetServerVersionIdentity(rfbScreenInfoPtr screen, char *fmt, ...)
-{
-    char buffer[256];
-    va_list ap;
-    
-    va_start(ap, fmt);
-    vsnprintf(buffer, sizeof(buffer)-1, fmt, ap);
-    va_end(ap);
-    
-    if (screen->versionString!=NULL) free(screen->versionString);
-    screen->versionString = strdup(buffer);
-}
-
-/*
- * Send rfbEncodingServerIdentity.
- */
-
-rfbBool
-rfbSendServerIdentity(rfbClientPtr cl)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    char buffer[512];
-
-    /* tack on our library version */
-    snprintf(buffer,sizeof(buffer)-1, "%s (%s)", 
-        (cl->screen->versionString==NULL ? "unknown" : cl->screen->versionString),
-        LIBVNCSERVER_PACKAGE_STRING);
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader
-                  + (strlen(buffer)+1) > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.encoding = Swap32IfLE(rfbEncodingServerIdentity);
-    rect.r.x = 0;
-    rect.r.y = 0;
-    rect.r.w = Swap16IfLE(strlen(buffer)+1);
-    rect.r.h = 0;
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-        sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    memcpy(&cl->updateBuf[cl->ublen], buffer, strlen(buffer)+1);
-    cl->ublen += strlen(buffer)+1;
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingServerIdentity,
-        sz_rfbFramebufferUpdateRectHeader+strlen(buffer)+1,
-        sz_rfbFramebufferUpdateRectHeader+strlen(buffer)+1);
-    
-
-    if (!rfbSendUpdateBuf(cl))
-        return FALSE;
-
-    return TRUE;
-}
-
-/*
- * Send an xvp server message
- */
-
-rfbBool
-rfbSendXvp(rfbClientPtr cl, uint8_t version, uint8_t code)
-{
-    rfbXvpMsg xvp;
-
-    xvp.type = rfbXvp;
-    xvp.pad = 0;
-    xvp.version = version;
-    xvp.code = code;
-
-    LOCK(cl->sendMutex);
-    if (rfbWriteExact(cl, (char *)&xvp, sz_rfbXvpMsg) < 0) {
-      rfbLogPerror("rfbSendXvp: write");
-      rfbCloseClient(cl);
-    }
-    UNLOCK(cl->sendMutex);
-
-    rfbStatRecordMessageSent(cl, rfbXvp, sz_rfbXvpMsg, sz_rfbXvpMsg);
-
-    return TRUE;
-}
-
-
-rfbBool rfbSendTextChatMessage(rfbClientPtr cl, uint32_t length, char *buffer)
-{
-    rfbTextChatMsg tc;
-    int bytesToSend=0;
-
-    memset((char *)&tc, 0, sizeof(tc)); 
-    tc.type = rfbTextChat;
-    tc.length = Swap32IfLE(length);
-    
-    switch(length) {
-    case rfbTextChatOpen:
-    case rfbTextChatClose:
-    case rfbTextChatFinished:
-        bytesToSend=0;
-        break;
-    default:
-        bytesToSend=length;
-        if (bytesToSend>rfbTextMaxSize)
-            bytesToSend=rfbTextMaxSize;
-    }
-
-    if (cl->ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-    
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&tc, sz_rfbTextChatMsg);
-    cl->ublen += sz_rfbTextChatMsg;
-    if (bytesToSend>0) {
-        memcpy(&cl->updateBuf[cl->ublen], buffer, bytesToSend);
-        cl->ublen += bytesToSend;    
-    }
-    rfbStatRecordMessageSent(cl, rfbTextChat, sz_rfbTextChatMsg+bytesToSend, sz_rfbTextChatMsg+bytesToSend);
-
-    if (!rfbSendUpdateBuf(cl))
-        return FALSE;
-        
-    return TRUE;
-}
-
-#define FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(msg, cl, ret) \
-	if ((cl->screen->getFileTransferPermission != NULL \
-	    && cl->screen->getFileTransferPermission(cl) != TRUE) \
-	    || cl->screen->permitFileTransfer != TRUE) { \
-		rfbLog("%sUltra File Transfer is disabled, dropping client: %s\n", msg, cl->host); \
-		rfbCloseClient(cl); \
-		return ret; \
-	}
-
-int DB = 1;
-
-rfbBool rfbSendFileTransferMessage(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length, const char *buffer)
-{
-    rfbFileTransferMsg ft;
-    ft.type = rfbFileTransfer;
-    ft.contentType = contentType;
-    ft.contentParam = contentParam;
-    ft.pad          = 0; /* UltraVNC did not Swap16LE(ft.contentParam) (Looks like it might be BigEndian) */
-    ft.size         = Swap32IfLE(size);
-    ft.length       = Swap32IfLE(length);
-    
-    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("", cl, FALSE);
-    /*
-    rfbLog("rfbSendFileTransferMessage( %dtype, %dparam, %dsize, %dlen, %p)\n", contentType, contentParam, size, length, buffer);
-    */
-    LOCK(cl->sendMutex);
-    if (rfbWriteExact(cl, (char *)&ft, sz_rfbFileTransferMsg) < 0) {
-        rfbLogPerror("rfbSendFileTransferMessage: write");
-        rfbCloseClient(cl);
-        UNLOCK(cl->sendMutex);
-        return FALSE;
-    }
-
-    if (length>0)
-    {
-        if (rfbWriteExact(cl, buffer, length) < 0) {
-            rfbLogPerror("rfbSendFileTransferMessage: write");
-            rfbCloseClient(cl);
-            UNLOCK(cl->sendMutex);
-            return FALSE;
-        }
-    }
-    UNLOCK(cl->sendMutex);
-
-    rfbStatRecordMessageSent(cl, rfbFileTransfer, sz_rfbFileTransferMsg+length, sz_rfbFileTransferMsg+length);
-
-    return TRUE;
-}
-
-
-/*
- * UltraVNC uses Windows Structures
- */
-#define MAX_PATH 260
-
-typedef struct {
-    uint32_t dwLowDateTime;
-    uint32_t dwHighDateTime;
-} RFB_FILETIME; 
-
-typedef struct {
-    uint32_t dwFileAttributes;
-    RFB_FILETIME ftCreationTime;
-    RFB_FILETIME ftLastAccessTime;
-    RFB_FILETIME ftLastWriteTime;
-    uint32_t nFileSizeHigh;
-    uint32_t nFileSizeLow;
-    uint32_t dwReserved0;
-    uint32_t dwReserved1;
-    uint8_t  cFileName[ MAX_PATH ];
-    uint8_t  cAlternateFileName[ 14 ];
-} RFB_FIND_DATA;
-
-#define RFB_FILE_ATTRIBUTE_READONLY   0x1
-#define RFB_FILE_ATTRIBUTE_HIDDEN     0x2
-#define RFB_FILE_ATTRIBUTE_SYSTEM     0x4
-#define RFB_FILE_ATTRIBUTE_DIRECTORY  0x10
-#define RFB_FILE_ATTRIBUTE_ARCHIVE    0x20
-#define RFB_FILE_ATTRIBUTE_NORMAL     0x80
-#define RFB_FILE_ATTRIBUTE_TEMPORARY  0x100
-#define RFB_FILE_ATTRIBUTE_COMPRESSED 0x800
-
-rfbBool rfbFilenameTranslate2UNIX(rfbClientPtr cl, char *path, char *unixPath)
-{
-    int x;
-    char *home=NULL;
-
-    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("", cl, FALSE);
-
-    /* C: */
-    if (path[0]=='C' && path[1]==':')
-      strcpy(unixPath, &path[2]);
-    else
-    {
-      home = getenv("HOME");
-      if (home!=NULL)
-      {
-        strcpy(unixPath, home);
-        strcat(unixPath,"/");
-        strcat(unixPath, path);
-      }
-      else
-        strcpy(unixPath, path);
-    }
-    for (x=0;x<strlen(unixPath);x++)
-      if (unixPath[x]=='\\') unixPath[x]='/';
-    return TRUE;
-}
-
-rfbBool rfbFilenameTranslate2DOS(rfbClientPtr cl, char *unixPath, char *path)
-{
-    int x;
-
-    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("", cl, FALSE);
-
-    sprintf(path,"C:%s", unixPath);
-    for (x=2;x<strlen(path);x++)
-        if (path[x]=='/') path[x]='\\';
-    return TRUE;
-}
-
-rfbBool rfbSendDirContent(rfbClientPtr cl, int length, char *buffer)
-{
-    char retfilename[MAX_PATH];
-    char path[MAX_PATH];
-    struct stat statbuf;
-    RFB_FIND_DATA win32filename;
-    int nOptLen = 0, retval=0;
-    DIR *dirp=NULL;
-    struct dirent *direntp=NULL;
-
-    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("", cl, FALSE);
-
-    /* Client thinks we are Winblows */
-    rfbFilenameTranslate2UNIX(cl, buffer, path);
-
-    if (DB) rfbLog("rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent: \"%s\"->\"%s\"\n",buffer, path);
-
-    dirp=opendir(path);
-    if (dirp==NULL)
-        return rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, 0, NULL);
-    /* send back the path name (necessary for links) */
-    if (rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, length, buffer)==FALSE) return FALSE;
-    for (direntp=readdir(dirp); direntp!=NULL; direntp=readdir(dirp))
-    {
-        /* get stats */
-        snprintf(retfilename,sizeof(retfilename),"%s/%s", path, direntp->d_name);
-        retval = stat(retfilename, &statbuf);
-
-        if (retval==0)
-        {
-            memset((char *)&win32filename, 0, sizeof(win32filename));
-            win32filename.dwFileAttributes = Swap32IfBE(RFB_FILE_ATTRIBUTE_NORMAL);
-            if (S_ISDIR(statbuf.st_mode))
-              win32filename.dwFileAttributes = Swap32IfBE(RFB_FILE_ATTRIBUTE_DIRECTORY);
-            win32filename.ftCreationTime.dwLowDateTime = Swap32IfBE(statbuf.st_ctime);   /* Intel Order */
-            win32filename.ftCreationTime.dwHighDateTime = 0;
-            win32filename.ftLastAccessTime.dwLowDateTime = Swap32IfBE(statbuf.st_atime); /* Intel Order */
-            win32filename.ftLastAccessTime.dwHighDateTime = 0;
-            win32filename.ftLastWriteTime.dwLowDateTime = Swap32IfBE(statbuf.st_mtime);  /* Intel Order */
-            win32filename.ftLastWriteTime.dwHighDateTime = 0;
-            win32filename.nFileSizeLow = Swap32IfBE(statbuf.st_size); /* Intel Order */
-            win32filename.nFileSizeHigh = 0;
-            win32filename.dwReserved0 = 0;
-            win32filename.dwReserved1 = 0;
-
-            /* If this had the full path, we would need to translate to DOS format ("C:\") */
-            /* rfbFilenameTranslate2DOS(cl, retfilename, win32filename.cFileName); */
-            strcpy((char *)win32filename.cFileName, direntp->d_name);
-            
-            /* Do not show hidden files (but show how to move up the tree) */
-            if ((strcmp(direntp->d_name, "..")==0) || (direntp->d_name[0]!='.'))
-            {
-                nOptLen = sizeof(RFB_FIND_DATA) - MAX_PATH - 14 + strlen((char *)win32filename.cFileName);
-                /*
-                rfbLog("rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent: Sending \"%s\"\n", (char *)win32filename.cFileName);
-                */
-                if (rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADirectory, 0, nOptLen, (char *)&win32filename)==FALSE)
-                {
-                    closedir(dirp);
-                    return FALSE;
-                }
-            }
-        }
-    }
-    closedir(dirp);
-    /* End of the transfer */
-    return rfbSendFileTransferMessage(cl, rfbDirPacket, 0, 0, 0, NULL);
-}
-
-
-char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)
-{
-    char *buffer=NULL;
-    int   n=0;
-
-    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("", cl, NULL);
-    /*
-    rfbLog("rfbProcessFileTransferReadBuffer(%dlen)\n", length);
-    */
-    if (length>0) {
-        buffer=malloc(length+1);
-        if (buffer!=NULL) {
-            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {
-                if (n != 0)
-                    rfbLogPerror("rfbProcessFileTransferReadBuffer: read");
-                rfbCloseClient(cl);
-                /* NOTE: don't forget to free(buffer) if you return early! */
-                if (buffer!=NULL) free(buffer);
-                return NULL;
-            }
-            /* Null Terminate */
-            buffer[length]=0;
-        }
-    }
-    return buffer;
-}
-
-
-rfbBool rfbSendFileTransferChunk(rfbClientPtr cl)
-{
-    /* Allocate buffer for compression */
-    unsigned char readBuf[sz_rfbBlockSize];
-    int bytesRead=0;
-    int retval=0;
-    fd_set wfds;
-    struct timeval tv;
-    int n;
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    unsigned char compBuf[sz_rfbBlockSize + 1024];
-    unsigned long nMaxCompSize = sizeof(compBuf);
-    int nRetC = 0;
-#endif
-
-    /*
-     * Don't close the client if we get into this one because 
-     * it is called from many places to service file transfers.
-     * Note that permitFileTransfer is checked first.
-     */
-    if (cl->screen->permitFileTransfer != TRUE ||
-       (cl->screen->getFileTransferPermission != NULL
-        && cl->screen->getFileTransferPermission(cl) != TRUE)) { 
-		return TRUE;
-    }
-
-    /* If not sending, or no file open...   Return as if we sent something! */
-    if ((cl->fileTransfer.fd!=-1) && (cl->fileTransfer.sending==1))
-    {
-	FD_ZERO(&wfds);
-        FD_SET(cl->sock, &wfds);
-
-        /* return immediately */
-	tv.tv_sec = 0; 
-	tv.tv_usec = 0;
-	n = select(cl->sock + 1, NULL, &wfds, NULL, &tv);
-
-	if (n<0) {
-#ifdef WIN32
-	    errno=WSAGetLastError();
-#endif
-            rfbLog("rfbSendFileTransferChunk() select failed: %s\n", strerror(errno));
-	}
-        /* We have space on the transmit queue */
-	if (n > 0)
-	{
-            bytesRead = read(cl->fileTransfer.fd, readBuf, sz_rfbBlockSize);
-            switch (bytesRead) {
-            case 0:
-                /*
-                rfbLog("rfbSendFileTransferChunk(): End-Of-File Encountered\n");
-                */
-                retval = rfbSendFileTransferMessage(cl, rfbEndOfFile, 0, 0, 0, NULL);
-                close(cl->fileTransfer.fd);
-                cl->fileTransfer.fd = -1;
-                cl->fileTransfer.sending   = 0;
-                cl->fileTransfer.receiving = 0;
-                return retval;
-            case -1:
-                /* TODO : send an error msg to the client... */
-#ifdef WIN32
-	        errno=WSAGetLastError();
-#endif
-                rfbLog("rfbSendFileTransferChunk(): %s\n",strerror(errno));
-                retval = rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, 0, 0, NULL);
-                close(cl->fileTransfer.fd);
-                cl->fileTransfer.fd = -1;
-                cl->fileTransfer.sending   = 0;
-                cl->fileTransfer.receiving = 0;
-                return retval;
-            default:
-                /*
-                rfbLog("rfbSendFileTransferChunk(): Read %d bytes\n", bytesRead);
-                */
-                if (!cl->fileTransfer.compressionEnabled)
-                    return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);
-                else
-                {
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-                    nRetC = compress(compBuf, &nMaxCompSize, readBuf, bytesRead);
-                    /*
-                    rfbLog("Compressed the packet from %d -> %d bytes\n", nMaxCompSize, bytesRead);
-                    */
-                    
-                    if ((nRetC==0) && (nMaxCompSize<bytesRead))
-                        return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 1, nMaxCompSize, (char *)compBuf);
-                    else
-                        return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);
-#else
-                    /* We do not support compression of the data stream */
-                    return  rfbSendFileTransferMessage(cl, rfbFilePacket, 0, 0, bytesRead, (char *)readBuf);
-#endif
-                }
-            }
-        }
-    }
-    return TRUE;
-}
-
-rfbBool rfbProcessFileTransfer(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length)
-{
-    char *buffer=NULL, *p=NULL;
-    int retval=0;
-    char filename1[MAX_PATH];
-    char filename2[MAX_PATH];
-    char szFileTime[MAX_PATH];
-    struct stat statbuf;
-    uint32_t sizeHtmp=0;
-    int n=0;
-    char timespec[64];
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    unsigned char compBuff[sz_rfbBlockSize];
-    unsigned long nRawBytes = sz_rfbBlockSize;
-    int nRet = 0;
-#endif
-
-    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN("", cl, FALSE);
-        
-    /*
-    rfbLog("rfbProcessFileTransfer(%dtype, %dparam, %dsize, %dlen)\n", contentType, contentParam, size, length);
-    */
-
-    switch (contentType) {
-    case rfbDirContentRequest:
-        switch (contentParam) {
-        case rfbRDrivesList: /* Client requests the List of Local Drives */
-            /*
-            rfbLog("rfbProcessFileTransfer() rfbDirContentRequest: rfbRDrivesList:\n");
-            */
-            /* Format when filled : "C:\<NULL>D:\<NULL>....Z:\<NULL><NULL>
-             *
-             * We replace the "\" char following the drive letter and ":"
-             * with a char corresponding to the type of drive
-             * We obtain something like "C:l<NULL>D:c<NULL>....Z:n\<NULL><NULL>"
-             *  Isn't it ugly ?
-             * DRIVE_FIXED = 'l'     (local?)
-             * DRIVE_REMOVABLE = 'f' (floppy?)
-             * DRIVE_CDROM = 'c'
-             * DRIVE_REMOTE = 'n'
-             */
-            
-            /* in unix, there are no 'drives'  (We could list mount points though)
-             * We fake the root as a "C:" for the Winblows users
-             */
-            filename2[0]='C';
-            filename2[1]=':';
-            filename2[2]='l';
-            filename2[3]=0;
-            filename2[4]=0;
-            retval = rfbSendFileTransferMessage(cl, rfbDirPacket, rfbADrivesList, 0, 5, filename2);
-            if (buffer!=NULL) free(buffer);
-            return retval;
-            break;
-        case rfbRDirContent: /* Client requests the content of a directory */
-            /*
-            rfbLog("rfbProcessFileTransfer() rfbDirContentRequest: rfbRDirContent\n");
-            */
-            if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;
-            retval = rfbSendDirContent(cl, length, buffer);
-            if (buffer!=NULL) free(buffer);
-            return retval;
-        }
-        break;
-
-    case rfbDirPacket:
-        rfbLog("rfbProcessFileTransfer() rfbDirPacket\n");
-        break;
-    case rfbFileAcceptHeader:
-        rfbLog("rfbProcessFileTransfer() rfbFileAcceptHeader\n");
-        break;
-    case rfbCommandReturn:
-        rfbLog("rfbProcessFileTransfer() rfbCommandReturn\n");
-        break;
-    case rfbFileChecksums:
-        /* Destination file already exists - the viewer sends the checksums */
-        rfbLog("rfbProcessFileTransfer() rfbFileChecksums\n");
-        break;
-    case rfbFileTransferAccess:
-        rfbLog("rfbProcessFileTransfer() rfbFileTransferAccess\n");
-        break;
-
-    /*
-     * sending from the server to the viewer
-     */
-
-    case rfbFileTransferRequest:
-        /*
-        rfbLog("rfbProcessFileTransfer() rfbFileTransferRequest:\n");
-        */
-        /* add some space to the end of the buffer as we will be adding a timespec to it */
-        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;
-        /* The client requests a File */
-        rfbFilenameTranslate2UNIX(cl, buffer, filename1);
-        cl->fileTransfer.fd=open(filename1, O_RDONLY, 0744);
-
-        /*
-        */
-        if (DB) rfbLog("rfbProcessFileTransfer() rfbFileTransferRequest(\"%s\"->\"%s\") Open: %s fd=%d\n", buffer, filename1, (cl->fileTransfer.fd==-1?"Failed":"Success"), cl->fileTransfer.fd);
-        
-        if (cl->fileTransfer.fd!=-1) {
-            if (fstat(cl->fileTransfer.fd, &statbuf)!=0) {
-                close(cl->fileTransfer.fd);
-                cl->fileTransfer.fd=-1;
-            }
-            else
-            {
-              /* Add the File Time Stamp to the filename */
-              strftime(timespec, sizeof(timespec), "%m/%d/%Y %H:%M",gmtime(&statbuf.st_ctime));
-              buffer=realloc(buffer, length + strlen(timespec) + 2); /* comma, and Null term */
-              if (buffer==NULL) {
-                  rfbLog("rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\n", length + strlen(timespec) + 2);
-                  return FALSE;
-              }
-              strcat(buffer,",");
-              strcat(buffer, timespec);
-              length = strlen(buffer);
-              if (DB) rfbLog("rfbProcessFileTransfer() buffer is now: \"%s\"\n", buffer);
-            }
-        }
-
-        /* The viewer supports compression if size==1 */
-        cl->fileTransfer.compressionEnabled = (size==1);
-
-        /*
-        rfbLog("rfbProcessFileTransfer() rfbFileTransferRequest(\"%s\"->\"%s\")%s\n", buffer, filename1, (size==1?" <Compression Enabled>":""));
-        */
-
-        /* File Size in bytes, 0xFFFFFFFF (-1) means error */
-        retval = rfbSendFileTransferMessage(cl, rfbFileHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : statbuf.st_size), length, buffer);
-
-        if (cl->fileTransfer.fd==-1)
-        {
-            if (buffer!=NULL) free(buffer);
-            return retval;
-        }
-        /* setup filetransfer stuff */
-        cl->fileTransfer.fileSize = statbuf.st_size;
-        cl->fileTransfer.numPackets = statbuf.st_size / sz_rfbBlockSize;
-        cl->fileTransfer.receiving = 0;
-        cl->fileTransfer.sending = 0; /* set when we receive a rfbFileHeader: */
-
-        /* TODO: finish 64-bit file size support */
-        sizeHtmp = 0;        
-        LOCK(cl->sendMutex);
-        if (rfbWriteExact(cl, (char *)&sizeHtmp, 4) < 0) {
-          rfbLogPerror("rfbProcessFileTransfer: write");
-          rfbCloseClient(cl);
-          UNLOCK(cl->sendMutex);
-          if (buffer!=NULL) free(buffer);
-          return FALSE;
-        }
-        UNLOCK(cl->sendMutex);
-        break;
-
-    case rfbFileHeader:
-        /* Destination file (viewer side) is ready for reception (size > 0) or not (size = -1) */
-        if (size==-1) {
-            rfbLog("rfbProcessFileTransfer() rfbFileHeader (error, aborting)\n");
-            close(cl->fileTransfer.fd);
-            cl->fileTransfer.fd=-1;
-            return TRUE;
-        }
-
-        /*
-        rfbLog("rfbProcessFileTransfer() rfbFileHeader (%d bytes of a file)\n", size);
-        */
-
-        /* Starts the transfer! */
-        cl->fileTransfer.sending=1;
-        return rfbSendFileTransferChunk(cl);
-        break;
-
-
-    /*
-     * sending from the viewer to the server
-     */
-
-    case rfbFileTransferOffer:
-        /* client is sending a file to us */
-        /* buffer contains full path name (plus FileTime) */
-        /* size contains size of the file */
-        /*
-        rfbLog("rfbProcessFileTransfer() rfbFileTransferOffer:\n");
-        */
-        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;
-
-        /* Parse the FileTime */
-        p = strrchr(buffer, ',');
-        if (p!=NULL) {
-            *p = '\0';
-            strcpy(szFileTime, p+1);
-        } else
-            szFileTime[0]=0;
-
-
-
-        /* Need to read in sizeHtmp */
-        if ((n = rfbReadExact(cl, (char *)&sizeHtmp, 4)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessFileTransfer: read sizeHtmp");
-            rfbCloseClient(cl);
-            /* NOTE: don't forget to free(buffer) if you return early! */
-            if (buffer!=NULL) free(buffer);
-            return FALSE;
-        }
-        sizeHtmp = Swap32IfLE(sizeHtmp);
-        
-        rfbFilenameTranslate2UNIX(cl, buffer, filename1);
-
-        /* If the file exists... We can send a rfbFileChecksums back to the client before we send an rfbFileAcceptHeader */
-        /* TODO: Delta Transfer */
-
-        cl->fileTransfer.fd=open(filename1, O_CREAT|O_WRONLY|O_TRUNC, 0744);
-        if (DB) rfbLog("rfbProcessFileTransfer() rfbFileTransferOffer(\"%s\"->\"%s\") %s %s fd=%d\n", buffer, filename1, (cl->fileTransfer.fd==-1?"Failed":"Success"), (cl->fileTransfer.fd==-1?strerror(errno):""), cl->fileTransfer.fd);
-        /*
-        */
-        
-        /* File Size in bytes, 0xFFFFFFFF (-1) means error */
-        retval = rfbSendFileTransferMessage(cl, rfbFileAcceptHeader, 0, (cl->fileTransfer.fd==-1 ? -1 : 0), length, buffer);
-        if (cl->fileTransfer.fd==-1) {
-            free(buffer);
-            return retval;
-        }
-        
-        /* setup filetransfer stuff */
-        cl->fileTransfer.fileSize = size;
-        cl->fileTransfer.numPackets = size / sz_rfbBlockSize;
-        cl->fileTransfer.receiving = 1;
-        cl->fileTransfer.sending = 0;
-        break;
-
-    case rfbFilePacket:
-        /*
-        rfbLog("rfbProcessFileTransfer() rfbFilePacket:\n");
-        */
-        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;
-        if (cl->fileTransfer.fd!=-1) {
-            /* buffer contains the contents of the file */
-            if (size==0)
-                retval=write(cl->fileTransfer.fd, buffer, length);
-            else
-            {
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-                /* compressed packet */
-                nRet = uncompress(compBuff,&nRawBytes,(const unsigned char*)buffer, length);
-                retval=write(cl->fileTransfer.fd, (char*)compBuff, nRawBytes);
-#else
-                /* Write the file out as received... */
-                retval=write(cl->fileTransfer.fd, buffer, length);
-#endif
-            }
-            if (retval==-1)
-            {
-                close(cl->fileTransfer.fd);
-                cl->fileTransfer.fd=-1;
-                cl->fileTransfer.sending   = 0;
-                cl->fileTransfer.receiving = 0;
-            }
-        }
-        break;
-
-    case rfbEndOfFile:
-        if (DB) rfbLog("rfbProcessFileTransfer() rfbEndOfFile\n");
-        /*
-        */
-        if (cl->fileTransfer.fd!=-1)
-            close(cl->fileTransfer.fd);
-        cl->fileTransfer.fd=-1;
-        cl->fileTransfer.sending   = 0;
-        cl->fileTransfer.receiving = 0;
-        break;
-
-    case rfbAbortFileTransfer:
-        if (DB) rfbLog("rfbProcessFileTransfer() rfbAbortFileTransfer\n");
-        /*
-        */
-        if (cl->fileTransfer.fd!=-1)
-        {
-            close(cl->fileTransfer.fd);
-            cl->fileTransfer.fd=-1;
-            cl->fileTransfer.sending   = 0;
-            cl->fileTransfer.receiving = 0;
-        }
-        else
-        {
-            /* We use this message for FileTransfer rights (<=RC18 versions)
-             * The client asks for FileTransfer permission
-             */
-            if (contentParam == 0)
-            {
-                rfbLog("rfbProcessFileTransfer() File Transfer Permission DENIED! (Client Version <=RC18)\n");
-                /* Old method for FileTransfer handshake perimssion (<=RC18) (Deny it)*/
-                return rfbSendFileTransferMessage(cl, rfbAbortFileTransfer, 0, -1, 0, "");
-            }
-            /* New method is allowed */
-            if (cl->screen->getFileTransferPermission!=NULL)
-            {
-                if (cl->screen->getFileTransferPermission(cl)==TRUE)
-                {
-                    rfbLog("rfbProcessFileTransfer() File Transfer Permission Granted!\n");
-                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, ""); /* Permit */
-                }
-                else
-                {
-                    rfbLog("rfbProcessFileTransfer() File Transfer Permission DENIED!\n");
-                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, ""); /* Deny */
-                }
-            }
-            else
-            {
-                if (cl->screen->permitFileTransfer)
-                {
-                    rfbLog("rfbProcessFileTransfer() File Transfer Permission Granted!\n");
-                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, 1 , 0, ""); /* Permit */
-                }
-                else
-                {
-                    rfbLog("rfbProcessFileTransfer() File Transfer Permission DENIED by default!\n");
-                    return rfbSendFileTransferMessage(cl, rfbFileTransferAccess, 0, -1 , 0, ""); /* DEFAULT: DENY (for security) */
-                }
-                
-            }
-        }
-        break;
-
-
-    case rfbCommand:
-        /*
-        rfbLog("rfbProcessFileTransfer() rfbCommand:\n");
-        */
-        if ((buffer = rfbProcessFileTransferReadBuffer(cl, length))==NULL) return FALSE;
-        switch (contentParam) {
-        case rfbCDirCreate:  /* Client requests the creation of a directory */
-            rfbFilenameTranslate2UNIX(cl, buffer, filename1);
-            retval = mkdir(filename1, 0755);
-            if (DB) rfbLog("rfbProcessFileTransfer() rfbCommand: rfbCDirCreate(\"%s\"->\"%s\") %s\n", buffer, filename1, (retval==-1?"Failed":"Success"));
-            /*
-            */
-            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbADirCreate, retval, length, buffer);
-            if (buffer!=NULL) free(buffer);
-            return retval;
-        case rfbCFileDelete: /* Client requests the deletion of a file */
-            rfbFilenameTranslate2UNIX(cl, buffer, filename1);
-            if (stat(filename1,&statbuf)==0)
-            {
-                if (S_ISDIR(statbuf.st_mode))
-                    retval = rmdir(filename1);
-                else
-                    retval = unlink(filename1);
-            }
-            else retval=-1;
-            retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileDelete, retval, length, buffer);
-            if (buffer!=NULL) free(buffer);
-            return retval;
-        case rfbCFileRename: /* Client requests the Renaming of a file/directory */
-            p = strrchr(buffer, '*');
-            if (p != NULL)
-            {
-                /* Split into 2 filenames ('*' is a seperator) */
-                *p = '\0';
-                rfbFilenameTranslate2UNIX(cl, buffer, filename1);
-                rfbFilenameTranslate2UNIX(cl, p+1,    filename2);
-                retval = rename(filename1,filename2);
-                if (DB) rfbLog("rfbProcessFileTransfer() rfbCommand: rfbCFileRename(\"%s\"->\"%s\" -->> \"%s\"->\"%s\") %s\n", buffer, filename1, p+1, filename2, (retval==-1?"Failed":"Success"));
-                /*
-                */
-                /* Restore the buffer so the reply is good */
-                *p = '*';
-                retval = rfbSendFileTransferMessage(cl, rfbCommandReturn, rfbAFileRename, retval, length, buffer);
-                if (buffer!=NULL) free(buffer);
-                return retval;
-            }
-            break;
-        }
-    
-        break;
-    }
-
-    /* NOTE: don't forget to free(buffer) if you return early! */
-    if (buffer!=NULL) free(buffer);
-    return TRUE;
-}
-
-/*
- * rfbProcessClientNormalMessage is called when the client has sent a normal
- * protocol message.
- */
-
-static void
-rfbProcessClientNormalMessage(rfbClientPtr cl)
-{
-    int n=0;
-    rfbClientToServerMsg msg;
-    char *str;
-    int i;
-    uint32_t enc=0;
-    uint32_t lastPreferredEncoding = -1;
-    char encBuf[64];
-    char encBuf2[64];
-
-    if ((n = rfbReadExact(cl, (char *)&msg, 1)) <= 0) {
-        if (n != 0)
-            rfbLogPerror("rfbProcessClientNormalMessage: read");
-        rfbCloseClient(cl);
-        return;
-    }
-
-    switch (msg.type) {
-
-    case rfbSetPixelFormat:
-
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                           sz_rfbSetPixelFormatMsg - 1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-
-        cl->format.bitsPerPixel = msg.spf.format.bitsPerPixel;
-        cl->format.depth = msg.spf.format.depth;
-        cl->format.bigEndian = (msg.spf.format.bigEndian ? TRUE : FALSE);
-        cl->format.trueColour = (msg.spf.format.trueColour ? TRUE : FALSE);
-        cl->format.redMax = Swap16IfLE(msg.spf.format.redMax);
-        cl->format.greenMax = Swap16IfLE(msg.spf.format.greenMax);
-        cl->format.blueMax = Swap16IfLE(msg.spf.format.blueMax);
-        cl->format.redShift = msg.spf.format.redShift;
-        cl->format.greenShift = msg.spf.format.greenShift;
-        cl->format.blueShift = msg.spf.format.blueShift;
-
-	cl->readyForSetColourMapEntries = TRUE;
-        cl->screen->setTranslateFunction(cl);
-
-        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);
-
-        return;
-
-
-    case rfbFixColourMapEntries:
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                           sz_rfbFixColourMapEntriesMsg - 1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetPixelFormatMsg, sz_rfbSetPixelFormatMsg);
-        rfbLog("rfbProcessClientNormalMessage: %s",
-                "FixColourMapEntries unsupported\n");
-        rfbCloseClient(cl);
-        return;
-
-
-    /* NOTE: Some clients send us a set of encodings (ie: PointerPos) designed to enable/disable features...
-     * We may want to look into this...
-     * Example:
-     *     case rfbEncodingXCursor:
-     *         cl->enableCursorShapeUpdates = TRUE;
-     *
-     * Currently: cl->enableCursorShapeUpdates can *never* be turned off...
-     */
-    case rfbSetEncodings:
-    {
-
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                           sz_rfbSetEncodingsMsg - 1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-
-        msg.se.nEncodings = Swap16IfLE(msg.se.nEncodings);
-
-        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4),sz_rfbSetEncodingsMsg+(msg.se.nEncodings*4));
-
-        /*
-         * UltraVNC Client has the ability to adapt to changing network environments
-         * So, let's give it a change to tell us what it wants now!
-         */
-        if (cl->preferredEncoding!=-1)
-            lastPreferredEncoding = cl->preferredEncoding;
-
-        /* Reset all flags to defaults (allows us to switch between PointerPos and Server Drawn Cursors) */
-        cl->preferredEncoding=-1;
-        cl->useCopyRect              = FALSE;
-        cl->useNewFBSize             = FALSE;
-        cl->cursorWasChanged         = FALSE;
-        cl->useRichCursorEncoding    = FALSE;
-        cl->enableCursorPosUpdates   = FALSE;
-        cl->enableCursorShapeUpdates = FALSE;
-        cl->enableCursorShapeUpdates = FALSE;
-        cl->enableLastRectEncoding   = FALSE;
-        cl->enableKeyboardLedState   = FALSE;
-        cl->enableSupportedMessages  = FALSE;
-        cl->enableSupportedEncodings = FALSE;
-        cl->enableServerIdentity     = FALSE;
-
-
-        for (i = 0; i < msg.se.nEncodings; i++) {
-            if ((n = rfbReadExact(cl, (char *)&enc, 4)) <= 0) {
-                if (n != 0)
-                    rfbLogPerror("rfbProcessClientNormalMessage: read");
-                rfbCloseClient(cl);
-                return;
-            }
-            enc = Swap32IfLE(enc);
-
-            switch (enc) {
-
-            case rfbEncodingCopyRect:
-		cl->useCopyRect = TRUE;
-                break;
-            case rfbEncodingRaw:
-            case rfbEncodingRRE:
-            case rfbEncodingCoRRE:
-            case rfbEncodingHextile:
-            case rfbEncodingUltra:
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	    case rfbEncodingZlib:
-            case rfbEncodingZRLE:
-            case rfbEncodingZYWRLE:
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-	    case rfbEncodingTight:
-#endif
-#endif
-            /* The first supported encoding is the 'preferred' encoding */
-                if (cl->preferredEncoding == -1)
-                    cl->preferredEncoding = enc;
-
-
-                break;
-	    case rfbEncodingXCursor:
-		if(!cl->screen->dontConvertRichCursorToXCursor) {
-		    rfbLog("Enabling X-style cursor updates for client %s\n",
-			   cl->host);
-		    /* if cursor was drawn, hide the cursor */
-		    if(!cl->enableCursorShapeUpdates)
-		        rfbRedrawAfterHideCursor(cl,NULL);
-
-		    cl->enableCursorShapeUpdates = TRUE;
-		    cl->cursorWasChanged = TRUE;
-		}
-		break;
-	    case rfbEncodingRichCursor:
-	        rfbLog("Enabling full-color cursor updates for client %s\n",
-		       cl->host);
-		/* if cursor was drawn, hide the cursor */
-		if(!cl->enableCursorShapeUpdates)
-		    rfbRedrawAfterHideCursor(cl,NULL);
-
-	        cl->enableCursorShapeUpdates = TRUE;
-	        cl->useRichCursorEncoding = TRUE;
-	        cl->cursorWasChanged = TRUE;
-	        break;
-	    case rfbEncodingPointerPos:
-		if (!cl->enableCursorPosUpdates) {
-		    rfbLog("Enabling cursor position updates for client %s\n",
-			   cl->host);
-		    cl->enableCursorPosUpdates = TRUE;
-		    cl->cursorWasMoved = TRUE;
-		}
-	        break;
-	    case rfbEncodingLastRect:
-		if (!cl->enableLastRectEncoding) {
-		    rfbLog("Enabling LastRect protocol extension for client "
-			   "%s\n", cl->host);
-		    cl->enableLastRectEncoding = TRUE;
-		}
-		break;
-	    case rfbEncodingNewFBSize:
-		if (!cl->useNewFBSize) {
-		    rfbLog("Enabling NewFBSize protocol extension for client "
-			   "%s\n", cl->host);
-		    cl->useNewFBSize = TRUE;
-		}
-		break;
-            case rfbEncodingKeyboardLedState:
-                if (!cl->enableKeyboardLedState) {
-                  rfbLog("Enabling KeyboardLedState protocol extension for client "
-                          "%s\n", cl->host);
-                  cl->enableKeyboardLedState = TRUE;
-                }
-                break;           
-            case rfbEncodingSupportedMessages:
-                if (!cl->enableSupportedMessages) {
-                  rfbLog("Enabling SupportedMessages protocol extension for client "
-                          "%s\n", cl->host);
-                  cl->enableSupportedMessages = TRUE;
-                }
-                break;           
-            case rfbEncodingSupportedEncodings:
-                if (!cl->enableSupportedEncodings) {
-                  rfbLog("Enabling SupportedEncodings protocol extension for client "
-                          "%s\n", cl->host);
-                  cl->enableSupportedEncodings = TRUE;
-                }
-                break;           
-            case rfbEncodingServerIdentity:
-                if (!cl->enableServerIdentity) {
-                  rfbLog("Enabling ServerIdentity protocol extension for client "
-                          "%s\n", cl->host);
-                  cl->enableServerIdentity = TRUE;
-                }
-                break;
-	    case rfbEncodingXvp:
-	        rfbLog("Enabling Xvp protocol extension for client "
-		        "%s\n", cl->host);
-		if (!rfbSendXvp(cl, 1, rfbXvp_Init)) {
-		  rfbCloseClient(cl);
-		  return;
-		}
-                break;
-            default:
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-		if ( enc >= (uint32_t)rfbEncodingCompressLevel0 &&
-		     enc <= (uint32_t)rfbEncodingCompressLevel9 ) {
-		    cl->zlibCompressLevel = enc & 0x0F;
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-		    cl->tightCompressLevel = enc & 0x0F;
-		    rfbLog("Using compression level %d for client %s\n",
-			   cl->tightCompressLevel, cl->host);
-#endif
-		} else if ( enc >= (uint32_t)rfbEncodingQualityLevel0 &&
-			    enc <= (uint32_t)rfbEncodingQualityLevel9 ) {
-		    cl->tightQualityLevel = enc & 0x0F;
-		    rfbLog("Using image quality level %d for client %s\n",
-			   cl->tightQualityLevel, cl->host);
-		} else
-#endif
-		{
-			rfbExtensionData* e;
-			for(e = cl->extensions; e;) {
-				rfbExtensionData* next = e->next;
-				if(e->extension->enablePseudoEncoding &&
-					e->extension->enablePseudoEncoding(cl,
-						&e->data, (int)enc))
-					/* ext handles this encoding */
-					break;
-				e = next;
-			}
-			if(e == NULL) {
-				rfbBool handled = FALSE;
-				/* if the pseudo encoding is not handled by the
-				   enabled extensions, search through all
-				   extensions. */
-				rfbProtocolExtension* e;
-
-				for(e = rfbGetExtensionIterator(); e;) {
-					int* encs = e->pseudoEncodings;
-					while(encs && *encs!=0) {
-						if(*encs==(int)enc) {
-							void* data = NULL;
-							if(!e->enablePseudoEncoding(cl, &data, (int)enc)) {
-								rfbLog("Installed extension pretends to handle pseudo encoding 0x%x, but does not!\n",(int)enc);
-							} else {
-								rfbEnableExtension(cl, e, data);
-								handled = TRUE;
-								e = NULL;
-								break;
-							}
-						}
-						encs++;
-					}
-
-					if(e)
-						e = e->next;
-				}
-				rfbReleaseExtensionIterator();
-
-				if(!handled)
-					rfbLog("rfbProcessClientNormalMessage: "
-					    "ignoring unsupported encoding type %s\n",
-					    encodingName(enc,encBuf,sizeof(encBuf)));
-			}
-		}
-            }
-        }
-
-
-
-        if (cl->preferredEncoding == -1) {
-            if (lastPreferredEncoding==-1) {
-                cl->preferredEncoding = rfbEncodingRaw;
-                rfbLog("Defaulting to %s encoding for client %s\n", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);
-            }
-            else {
-                cl->preferredEncoding = lastPreferredEncoding;
-                rfbLog("Sticking with %s encoding for client %s\n", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);
-            }
-        }
-        else
-        {
-          if (lastPreferredEncoding==-1) {
-              rfbLog("Using %s encoding for client %s\n", encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)),cl->host);
-          } else {
-              rfbLog("Switching from %s to %s Encoding for client %s\n", 
-                  encodingName(lastPreferredEncoding,encBuf2,sizeof(encBuf2)),
-                  encodingName(cl->preferredEncoding,encBuf,sizeof(encBuf)), cl->host);
-          }
-        }
-        
-	if (cl->enableCursorPosUpdates && !cl->enableCursorShapeUpdates) {
-	  rfbLog("Disabling cursor position updates for client %s\n",
-		 cl->host);
-	  cl->enableCursorPosUpdates = FALSE;
-	}
-
-        return;
-    }
-
-
-    case rfbFramebufferUpdateRequest:
-    {
-        sraRegionPtr tmpRegion;
-
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                           sz_rfbFramebufferUpdateRequestMsg-1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-
-        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbFramebufferUpdateRequestMsg,sz_rfbFramebufferUpdateRequestMsg);
-
-        /* The values come in based on the scaled screen, we need to convert them to
-         * values based on the main screen's coordinate system
-         */
-	if(!rectSwapIfLEAndClip(&msg.fur.x,&msg.fur.y,&msg.fur.w,&msg.fur.h,cl))
-	{
-	        rfbLog("Warning, ignoring rfbFramebufferUpdateRequest: %dXx%dY-%dWx%dH\n",msg.fur.x, msg.fur.y, msg.fur.w, msg.fur.h);
-		return;
-        }
- 
-        
-	tmpRegion =
-	  sraRgnCreateRect(msg.fur.x,
-			   msg.fur.y,
-			   msg.fur.x+msg.fur.w,
-			   msg.fur.y+msg.fur.h);
-
-        LOCK(cl->updateMutex);
-	sraRgnOr(cl->requestedRegion,tmpRegion);
-
-	if (!cl->readyForSetColourMapEntries) {
-	    /* client hasn't sent a SetPixelFormat so is using server's */
-	    cl->readyForSetColourMapEntries = TRUE;
-	    if (!cl->format.trueColour) {
-		if (!rfbSetClientColourMap(cl, 0, 0)) {
-		    sraRgnDestroy(tmpRegion);
-		    TSIGNAL(cl->updateCond);
-		    UNLOCK(cl->updateMutex);
-		    return;
-		}
-	    }
-	}
-
-       if (!msg.fur.incremental) {
-	    sraRgnOr(cl->modifiedRegion,tmpRegion);
-	    sraRgnSubtract(cl->copyRegion,tmpRegion);
-       }
-       TSIGNAL(cl->updateCond);
-       UNLOCK(cl->updateMutex);
-
-       sraRgnDestroy(tmpRegion);
-
-       return;
-    }
-
-    case rfbKeyEvent:
-
-	if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-			   sz_rfbKeyEventMsg - 1)) <= 0) {
-	    if (n != 0)
-		rfbLogPerror("rfbProcessClientNormalMessage: read");
-	    rfbCloseClient(cl);
-	    return;
-	}
-
-	rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbKeyEventMsg, sz_rfbKeyEventMsg);
-
-	if(!cl->viewOnly) {
-	    cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);
-	}
-
-        return;
-
-
-    case rfbPointerEvent:
-
-	if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-			   sz_rfbPointerEventMsg - 1)) <= 0) {
-	    if (n != 0)
-		rfbLogPerror("rfbProcessClientNormalMessage: read");
-	    rfbCloseClient(cl);
-	    return;
-	}
-
-	rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbPointerEventMsg, sz_rfbPointerEventMsg);
-	
-	if (cl->screen->pointerClient && cl->screen->pointerClient != cl)
-	    return;
-
-	if (msg.pe.buttonMask == 0)
-	    cl->screen->pointerClient = NULL;
-	else
-	    cl->screen->pointerClient = cl;
-
-	if(!cl->viewOnly) {
-	    if (msg.pe.buttonMask != cl->lastPtrButtons ||
-		    cl->screen->deferPtrUpdateTime == 0) {
-		cl->screen->ptrAddEvent(msg.pe.buttonMask,
-			ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x)), 
-			ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y)),
-			cl);
-		cl->lastPtrButtons = msg.pe.buttonMask;
-	    } else {
-		cl->lastPtrX = ScaleX(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.x));
-		cl->lastPtrY = ScaleY(cl->scaledScreen, cl->screen, Swap16IfLE(msg.pe.y));
-		cl->lastPtrButtons = msg.pe.buttonMask;
-	    }
-      }      
-      return;
-
-
-    case rfbFileTransfer:
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                              sz_rfbFileTransferMsg - 1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-        msg.ft.size         = Swap32IfLE(msg.ft.size);
-        msg.ft.length       = Swap32IfLE(msg.ft.length);
-        /* record statistics in rfbProcessFileTransfer as length is filled with garbage when it is not valid */
-        rfbProcessFileTransfer(cl, msg.ft.contentType, msg.ft.contentParam, msg.ft.size, msg.ft.length);
-        return;
-
-    case rfbSetSW:
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                              sz_rfbSetSWMsg - 1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-        msg.sw.x = Swap16IfLE(msg.sw.x);
-        msg.sw.y = Swap16IfLE(msg.sw.y);
-        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetSWMsg, sz_rfbSetSWMsg);
-        /* msg.sw.status is not initialized in the ultraVNC viewer and contains random numbers (why???) */
-
-        rfbLog("Received a rfbSetSingleWindow(%d x, %d y)\n", msg.sw.x, msg.sw.y);
-        if (cl->screen->setSingleWindow!=NULL)
-            cl->screen->setSingleWindow(cl, msg.sw.x, msg.sw.y);
-        return;
-
-    case rfbSetServerInput:
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                              sz_rfbSetServerInputMsg - 1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-        rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetServerInputMsg, sz_rfbSetServerInputMsg);
-
-        /* msg.sim.pad is not initialized in the ultraVNC viewer and contains random numbers (why???) */
-        /* msg.sim.pad = Swap16IfLE(msg.sim.pad); */
-
-        rfbLog("Received a rfbSetServerInput(%d status)\n", msg.sim.status);
-        if (cl->screen->setServerInput!=NULL)
-            cl->screen->setServerInput(cl, msg.sim.status);
-        return;
-        
-    case rfbTextChat:
-        if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-                              sz_rfbTextChatMsg - 1)) <= 0) {
-            if (n != 0)
-                rfbLogPerror("rfbProcessClientNormalMessage: read");
-            rfbCloseClient(cl);
-            return;
-        }
-        
-        msg.tc.pad2   = Swap16IfLE(msg.tc.pad2);
-        msg.tc.length = Swap32IfLE(msg.tc.length);
-
-        switch (msg.tc.length) {
-        case rfbTextChatOpen:
-        case rfbTextChatClose:
-        case rfbTextChatFinished:
-            /* commands do not have text following */
-            /* Why couldn't they have used the pad byte??? */
-            str=NULL;
-            rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg, sz_rfbTextChatMsg);
-            break;
-        default:
-            if ((msg.tc.length>0) && (msg.tc.length<rfbTextMaxSize))
-            {
-                str = (char *)malloc(msg.tc.length);
-                if (str==NULL)
-                {
-                    rfbLog("Unable to malloc %d bytes for a TextChat Message\n", msg.tc.length);
-                    rfbCloseClient(cl);
-                    return;
-                }
-                if ((n = rfbReadExact(cl, str, msg.tc.length)) <= 0) {
-                    if (n != 0)
-                        rfbLogPerror("rfbProcessClientNormalMessage: read");
-                    free(str);
-                    rfbCloseClient(cl);
-                    return;
-                }
-                rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbTextChatMsg+msg.tc.length, sz_rfbTextChatMsg+msg.tc.length);
-            }
-            else
-            {
-                /* This should never happen */
-                rfbLog("client sent us a Text Message that is too big %d>%d\n", msg.tc.length, rfbTextMaxSize);
-                rfbCloseClient(cl);
-                return;
-            }
-        }
-
-        /* Note: length can be commands: rfbTextChatOpen, rfbTextChatClose, and rfbTextChatFinished
-         * at which point, the str is NULL (as it is not sent)
-         */
-        if (cl->screen->setTextChat!=NULL)
-            cl->screen->setTextChat(cl, msg.tc.length, str);
-
-        free(str);
-        return;
-
-
-    case rfbClientCutText:
-
-	if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-			   sz_rfbClientCutTextMsg - 1)) <= 0) {
-	    if (n != 0)
-		rfbLogPerror("rfbProcessClientNormalMessage: read");
-	    rfbCloseClient(cl);
-	    return;
-	}
-
-	msg.cct.length = Swap32IfLE(msg.cct.length);
-
-	str = (char *)malloc(msg.cct.length);
-
-	if ((n = rfbReadExact(cl, str, msg.cct.length)) <= 0) {
-	    if (n != 0)
-	        rfbLogPerror("rfbProcessClientNormalMessage: read");
-	    free(str);
-	    rfbCloseClient(cl);
-	    return;
-	}
-	rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbClientCutTextMsg+msg.cct.length, sz_rfbClientCutTextMsg+msg.cct.length);
-	if(!cl->viewOnly) {
-	    cl->screen->setXCutText(str, msg.cct.length, cl);
-	}
-	free(str);
-
-        return;
-
-    case rfbPalmVNCSetScaleFactor:
-      cl->PalmVNC = TRUE;
-      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-          sz_rfbSetScaleMsg - 1)) <= 0) {
-          if (n != 0)
-            rfbLogPerror("rfbProcessClientNormalMessage: read");
-          rfbCloseClient(cl);
-          return;
-      }
-      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);
-      rfbLog("rfbSetScale(%d)\n", msg.ssc.scale);
-      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);
-
-      rfbSendNewScaleSize(cl);
-      return;
-      
-    case rfbSetScale:
-
-      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-          sz_rfbSetScaleMsg - 1)) <= 0) {
-          if (n != 0)
-            rfbLogPerror("rfbProcessClientNormalMessage: read");
-          rfbCloseClient(cl);
-          return;
-      }
-      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbSetScaleMsg, sz_rfbSetScaleMsg);
-      rfbLog("rfbSetScale(%d)\n", msg.ssc.scale);
-      rfbScalingSetup(cl,cl->screen->width/msg.ssc.scale, cl->screen->height/msg.ssc.scale);
-
-      rfbSendNewScaleSize(cl);
-      return;
-
-    case rfbXvp:
-
-      if ((n = rfbReadExact(cl, ((char *)&msg) + 1,
-          sz_rfbXvpMsg - 1)) <= 0) {
-          if (n != 0)
-            rfbLogPerror("rfbProcessClientNormalMessage: read");
-          rfbCloseClient(cl);
-          return;
-      }
-      rfbStatRecordMessageRcvd(cl, msg.type, sz_rfbXvpMsg, sz_rfbXvpMsg);
-
-      /* only version when is defined, so echo back a fail */
-      if(msg.xvp.version != 1) {
-	rfbSendXvp(cl, msg.xvp.version, rfbXvp_Fail);
-      }
-      else {
-	/* if the hook exists and fails, send a fail msg */
-	if(cl->screen->xvpHook && !cl->screen->xvpHook(cl, msg.xvp.version, msg.xvp.code))
-	  rfbSendXvp(cl, 1, rfbXvp_Fail);
-      }
-      return;
-
-    default:
-	{
-	    rfbExtensionData *e,*next;
-
-	    for(e=cl->extensions; e;) {
-		next = e->next;
-		if(e->extension->handleMessage &&
-			e->extension->handleMessage(cl, e->data, &msg))
-                {
-                    rfbStatRecordMessageRcvd(cl, msg.type, 0, 0); /* Extension should handle this */
-		    return;
-                }
-		e = next;
-	    }
-
-	    rfbLog("rfbProcessClientNormalMessage: unknown message type %d\n",
-		    msg.type);
-	    rfbLog(" ... closing connection\n");
-	    rfbCloseClient(cl);
-	    return;
-	}
-    }
-}
-
-
-
-/*
- * rfbSendFramebufferUpdate - send the currently pending framebuffer update to
- * the RFB client.
- * givenUpdateRegion is not changed.
- */
-
-rfbBool
-rfbSendFramebufferUpdate(rfbClientPtr cl,
-                         sraRegionPtr givenUpdateRegion)
-{
-    sraRectangleIterator* i=NULL;
-    sraRect rect;
-    int nUpdateRegionRects;
-    rfbFramebufferUpdateMsg *fu = (rfbFramebufferUpdateMsg *)cl->updateBuf;
-    sraRegionPtr updateRegion,updateCopyRegion,tmpRegion;
-    int dx, dy;
-    rfbBool sendCursorShape = FALSE;
-    rfbBool sendCursorPos = FALSE;
-    rfbBool sendKeyboardLedState = FALSE;
-    rfbBool sendSupportedMessages = FALSE;
-    rfbBool sendSupportedEncodings = FALSE;
-    rfbBool sendServerIdentity = FALSE;
-    rfbBool result = TRUE;
-    
-
-    if(cl->screen->displayHook)
-      cl->screen->displayHook(cl);
-
-    /*
-     * If framebuffer size was changed and the client supports NewFBSize
-     * encoding, just send NewFBSize marker and return.
-     */
-
-    if (cl->useNewFBSize && cl->newFBSizePending) {
-      LOCK(cl->updateMutex);
-      cl->newFBSizePending = FALSE;
-      UNLOCK(cl->updateMutex);
-      fu->type = rfbFramebufferUpdate;
-      fu->nRects = Swap16IfLE(1);
-      cl->ublen = sz_rfbFramebufferUpdateMsg;
-      if (!rfbSendNewFBSize(cl, cl->scaledScreen->width, cl->scaledScreen->height)) {
-	if(cl->screen->displayFinishedHook)
-	  cl->screen->displayFinishedHook(cl, FALSE);
-        return FALSE;
-      }
-      result = rfbSendUpdateBuf(cl);
-      if(cl->screen->displayFinishedHook)
-	cl->screen->displayFinishedHook(cl, result);
-      return result;
-    }
-    
-    /*
-     * If this client understands cursor shape updates, cursor should be
-     * removed from the framebuffer. Otherwise, make sure it's put up.
-     */
-
-    if (cl->enableCursorShapeUpdates) {
-      if (cl->cursorWasChanged && cl->readyForSetColourMapEntries)
-	  sendCursorShape = TRUE;
-    }
-
-    /*
-     * Do we plan to send cursor position update?
-     */
-
-    if (cl->enableCursorPosUpdates && cl->cursorWasMoved)
-      sendCursorPos = TRUE;
-
-    /*
-     * Do we plan to send a keyboard state update?
-     */
-    if ((cl->enableKeyboardLedState) &&
-	(cl->screen->getKeyboardLedStateHook!=NULL))
-    {
-        int x;
-        x=cl->screen->getKeyboardLedStateHook(cl->screen);
-        if (x!=cl->lastKeyboardLedState)
-        {
-            sendKeyboardLedState = TRUE;
-            cl->lastKeyboardLedState=x;
-        }
-    }
-
-    /*
-     * Do we plan to send a rfbEncodingSupportedMessages?
-     */
-    if (cl->enableSupportedMessages)
-    {
-        sendSupportedMessages = TRUE;
-        /* We only send this message ONCE <per setEncodings message received>
-         * (We disable it here)
-         */
-        cl->enableSupportedMessages = FALSE;
-    }
-    /*
-     * Do we plan to send a rfbEncodingSupportedEncodings?
-     */
-    if (cl->enableSupportedEncodings)
-    {
-        sendSupportedEncodings = TRUE;
-        /* We only send this message ONCE <per setEncodings message received>
-         * (We disable it here)
-         */
-        cl->enableSupportedEncodings = FALSE;
-    }
-    /*
-     * Do we plan to send a rfbEncodingServerIdentity?
-     */
-    if (cl->enableServerIdentity)
-    {
-        sendServerIdentity = TRUE;
-        /* We only send this message ONCE <per setEncodings message received>
-         * (We disable it here)
-         */
-        cl->enableServerIdentity = FALSE;
-    }
-
-    LOCK(cl->updateMutex);
-
-    /*
-     * The modifiedRegion may overlap the destination copyRegion.  We remove
-     * any overlapping bits from the copyRegion (since they'd only be
-     * overwritten anyway).
-     */
-    
-    sraRgnSubtract(cl->copyRegion,cl->modifiedRegion);
-
-    /*
-     * The client is interested in the region requestedRegion.  The region
-     * which should be updated now is the intersection of requestedRegion
-     * and the union of modifiedRegion and copyRegion.  If it's empty then
-     * no update is needed.
-     */
-
-    updateRegion = sraRgnCreateRgn(givenUpdateRegion);
-    if(cl->screen->progressiveSliceHeight>0) {
-	    int height=cl->screen->progressiveSliceHeight,
-	    	y=cl->progressiveSliceY;
-	    sraRegionPtr bbox=sraRgnBBox(updateRegion);
-	    sraRect rect;
-	    if(sraRgnPopRect(bbox,&rect,0)) {
-		sraRegionPtr slice;
-		if(y<rect.y1 || y>=rect.y2)
-		    y=rect.y1;
-	    	slice=sraRgnCreateRect(0,y,cl->screen->width,y+height);
-		sraRgnAnd(updateRegion,slice);
-		sraRgnDestroy(slice);
-	    }
-	    sraRgnDestroy(bbox);
-	    y+=height;
-	    if(y>=cl->screen->height)
-		    y=0;
-	    cl->progressiveSliceY=y;
-    }
-
-    sraRgnOr(updateRegion,cl->copyRegion);
-    if(!sraRgnAnd(updateRegion,cl->requestedRegion) &&
-       sraRgnEmpty(updateRegion) &&
-       (cl->enableCursorShapeUpdates ||
-	(cl->cursorX == cl->screen->cursorX && cl->cursorY == cl->screen->cursorY)) &&
-       !sendCursorShape && !sendCursorPos && !sendKeyboardLedState &&
-       !sendSupportedMessages && !sendSupportedEncodings && !sendServerIdentity) {
-      sraRgnDestroy(updateRegion);
-      UNLOCK(cl->updateMutex);
-      if(cl->screen->displayFinishedHook)
-	cl->screen->displayFinishedHook(cl, TRUE);
-      return TRUE;
-    }
-
-    /*
-     * We assume that the client doesn't have any pixel data outside the
-     * requestedRegion.  In other words, both the source and destination of a
-     * copy must lie within requestedRegion.  So the region we can send as a
-     * copy is the intersection of the copyRegion with both the requestedRegion
-     * and the requestedRegion translated by the amount of the copy.  We set
-     * updateCopyRegion to this.
-     */
-
-    updateCopyRegion = sraRgnCreateRgn(cl->copyRegion);
-    sraRgnAnd(updateCopyRegion,cl->requestedRegion);
-    tmpRegion = sraRgnCreateRgn(cl->requestedRegion);
-    sraRgnOffset(tmpRegion,cl->copyDX,cl->copyDY);
-    sraRgnAnd(updateCopyRegion,tmpRegion);
-    sraRgnDestroy(tmpRegion);
-    dx = cl->copyDX;
-    dy = cl->copyDY;
-
-    /*
-     * Next we remove updateCopyRegion from updateRegion so that updateRegion
-     * is the part of this update which is sent as ordinary pixel data (i.e not
-     * a copy).
-     */
-
-    sraRgnSubtract(updateRegion,updateCopyRegion);
-
-    /*
-     * Finally we leave modifiedRegion to be the remainder (if any) of parts of
-     * the screen which are modified but outside the requestedRegion.  We also
-     * empty both the requestedRegion and the copyRegion - note that we never
-     * carry over a copyRegion for a future update.
-     */
-
-     sraRgnOr(cl->modifiedRegion,cl->copyRegion);
-     sraRgnSubtract(cl->modifiedRegion,updateRegion);
-     sraRgnSubtract(cl->modifiedRegion,updateCopyRegion);
-
-     sraRgnMakeEmpty(cl->requestedRegion);
-     sraRgnMakeEmpty(cl->copyRegion);
-     cl->copyDX = 0;
-     cl->copyDY = 0;
-   
-     UNLOCK(cl->updateMutex);
-   
-    if (!cl->enableCursorShapeUpdates) {
-      if(cl->cursorX != cl->screen->cursorX || cl->cursorY != cl->screen->cursorY) {
-	rfbRedrawAfterHideCursor(cl,updateRegion);
-	LOCK(cl->screen->cursorMutex);
-	cl->cursorX = cl->screen->cursorX;
-	cl->cursorY = cl->screen->cursorY;
-	UNLOCK(cl->screen->cursorMutex);
-	rfbRedrawAfterHideCursor(cl,updateRegion);
-      }
-      rfbShowCursor(cl);
-    }
-
-    /*
-     * Now send the update.
-     */
-    
-    rfbStatRecordMessageSent(cl, rfbFramebufferUpdate, 0, 0);
-    if (cl->preferredEncoding == rfbEncodingCoRRE) {
-        nUpdateRegionRects = 0;
-
-        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){
-            int x = rect.x1;
-            int y = rect.y1;
-            int w = rect.x2 - x;
-            int h = rect.y2 - y;
-	    int rectsPerRow, rows;
-            /* We need to count the number of rects in the scaled screen */
-            if (cl->screen!=cl->scaledScreen)
-                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "rfbSendFramebufferUpdate");
-	    rectsPerRow = (w-1)/cl->correMaxWidth+1;
-	    rows = (h-1)/cl->correMaxHeight+1;
-	    nUpdateRegionRects += rectsPerRow*rows;
-        }
-	sraRgnReleaseIterator(i); i=NULL;
-    } else if (cl->preferredEncoding == rfbEncodingUltra) {
-        nUpdateRegionRects = 0;
-        
-        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){
-            int x = rect.x1;
-            int y = rect.y1;
-            int w = rect.x2 - x;
-            int h = rect.y2 - y;
-            /* We need to count the number of rects in the scaled screen */
-            if (cl->screen!=cl->scaledScreen)
-                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "rfbSendFramebufferUpdate");
-            nUpdateRegionRects += (((h-1) / (ULTRA_MAX_SIZE( w ) / w)) + 1);
-          }
-        sraRgnReleaseIterator(i); i=NULL;
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    } else if (cl->preferredEncoding == rfbEncodingZlib) {
-	nUpdateRegionRects = 0;
-
-        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){
-            int x = rect.x1;
-            int y = rect.y1;
-            int w = rect.x2 - x;
-            int h = rect.y2 - y;
-            /* We need to count the number of rects in the scaled screen */
-            if (cl->screen!=cl->scaledScreen)
-                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "rfbSendFramebufferUpdate");
-	    nUpdateRegionRects += (((h-1) / (ZLIB_MAX_SIZE( w ) / w)) + 1);
-	}
-	sraRgnReleaseIterator(i); i=NULL;
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-    } else if (cl->preferredEncoding == rfbEncodingTight) {
-	nUpdateRegionRects = 0;
-
-        for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){
-            int x = rect.x1;
-            int y = rect.y1;
-            int w = rect.x2 - x;
-            int h = rect.y2 - y;
-            int n;
-            /* We need to count the number of rects in the scaled screen */
-            if (cl->screen!=cl->scaledScreen)
-                rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "rfbSendFramebufferUpdate");
-	    n = rfbNumCodedRectsTight(cl, x, y, w, h);
-	    if (n == 0) {
-		nUpdateRegionRects = 0xFFFF;
-		break;
-	    }
-	    nUpdateRegionRects += n;
-	}
-	sraRgnReleaseIterator(i); i=NULL;
-#endif
-#endif
-    } else {
-        nUpdateRegionRects = sraRgnCountRects(updateRegion);
-    }
-
-    fu->type = rfbFramebufferUpdate;
-    if (nUpdateRegionRects != 0xFFFF) {
-	if(cl->screen->maxRectsPerUpdate>0
-	   /* CoRRE splits the screen into smaller squares */
-	   && cl->preferredEncoding != rfbEncodingCoRRE
-	   /* Ultra encoding splits rectangles up into smaller chunks */
-           && cl->preferredEncoding != rfbEncodingUltra
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	   /* Zlib encoding splits rectangles up into smaller chunks */
-	   && cl->preferredEncoding != rfbEncodingZlib
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-	   /* Tight encoding counts the rectangles differently */
-	   && cl->preferredEncoding != rfbEncodingTight
-#endif
-#endif
-	   && nUpdateRegionRects>cl->screen->maxRectsPerUpdate) {
-	    sraRegion* newUpdateRegion = sraRgnBBox(updateRegion);
-	    sraRgnDestroy(updateRegion);
-	    updateRegion = newUpdateRegion;
-	    nUpdateRegionRects = sraRgnCountRects(updateRegion);
-	}
-	fu->nRects = Swap16IfLE((uint16_t)(sraRgnCountRects(updateCopyRegion) +
-					   nUpdateRegionRects +
-					   !!sendCursorShape + !!sendCursorPos + !!sendKeyboardLedState +
-					   !!sendSupportedMessages + !!sendSupportedEncodings + !!sendServerIdentity));
-    } else {
-	fu->nRects = 0xFFFF;
-    }
-    cl->ublen = sz_rfbFramebufferUpdateMsg;
-
-   if (sendCursorShape) {
-	cl->cursorWasChanged = FALSE;
-	if (!rfbSendCursorShape(cl))
-	    goto updateFailed;
-    }
-   
-   if (sendCursorPos) {
-	cl->cursorWasMoved = FALSE;
-	if (!rfbSendCursorPos(cl))
-	        goto updateFailed;
-   }
-   
-   if (sendKeyboardLedState) {
-       if (!rfbSendKeyboardLedState(cl))
-           goto updateFailed;
-   }
-
-   if (sendSupportedMessages) {
-       if (!rfbSendSupportedMessages(cl))
-           goto updateFailed;
-   }
-   if (sendSupportedEncodings) {
-       if (!rfbSendSupportedEncodings(cl))
-           goto updateFailed;
-   }
-   if (sendServerIdentity) {
-       if (!rfbSendServerIdentity(cl))
-           goto updateFailed;
-   }
-
-    if (!sraRgnEmpty(updateCopyRegion)) {
-	if (!rfbSendCopyRegion(cl,updateCopyRegion,dx,dy))
-	        goto updateFailed;
-    }
-
-    for(i = sraRgnGetIterator(updateRegion); sraRgnIteratorNext(i,&rect);){
-        int x = rect.x1;
-        int y = rect.y1;
-        int w = rect.x2 - x;
-        int h = rect.y2 - y;
-
-        /* We need to count the number of rects in the scaled screen */
-        if (cl->screen!=cl->scaledScreen)
-            rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "rfbSendFramebufferUpdate");
-
-        switch (cl->preferredEncoding) {
-	case -1:
-        case rfbEncodingRaw:
-            if (!rfbSendRectEncodingRaw(cl, x, y, w, h))
-	        goto updateFailed;
-            break;
-        case rfbEncodingRRE:
-            if (!rfbSendRectEncodingRRE(cl, x, y, w, h))
-	        goto updateFailed;
-            break;
-        case rfbEncodingCoRRE:
-            if (!rfbSendRectEncodingCoRRE(cl, x, y, w, h))
-	        goto updateFailed;
-	    break;
-        case rfbEncodingHextile:
-            if (!rfbSendRectEncodingHextile(cl, x, y, w, h))
-	        goto updateFailed;
-            break;
-        case rfbEncodingUltra:
-            if (!rfbSendRectEncodingUltra(cl, x, y, w, h))
-                goto updateFailed;
-            break;
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	case rfbEncodingZlib:
-	    if (!rfbSendRectEncodingZlib(cl, x, y, w, h))
-	        goto updateFailed;
-	    break;
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-	case rfbEncodingTight:
-	    if (!rfbSendRectEncodingTight(cl, x, y, w, h))
-	        goto updateFailed;
-	    break;
-#endif
-#endif
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-       case rfbEncodingZRLE:
-       case rfbEncodingZYWRLE:
-           if (!rfbSendRectEncodingZRLE(cl, x, y, w, h))
-	       goto updateFailed;
-           break;
-#endif
-        }
-    }
-    if (i) {
-        sraRgnReleaseIterator(i);
-        i = NULL;
-    }
-
-    if ( nUpdateRegionRects == 0xFFFF &&
-	 !rfbSendLastRectMarker(cl) )
-	    goto updateFailed;
-
-    if (!rfbSendUpdateBuf(cl)) {
-updateFailed:
-	result = FALSE;
-    }
-
-    if (!cl->enableCursorShapeUpdates) {
-      rfbHideCursor(cl);
-    }
-
-    if(i)
-        sraRgnReleaseIterator(i);
-    sraRgnDestroy(updateRegion);
-    sraRgnDestroy(updateCopyRegion);
-
-    if(cl->screen->displayFinishedHook)
-      cl->screen->displayFinishedHook(cl, result);
-    return result;
-}
-
-
-/*
- * Send the copy region as a string of CopyRect encoded rectangles.
- * The only slightly tricky thing is that we should send the messages in
- * the correct order so that an earlier CopyRect will not corrupt the source
- * of a later one.
- */
-
-rfbBool
-rfbSendCopyRegion(rfbClientPtr cl,
-                  sraRegionPtr reg,
-                  int dx,
-                  int dy)
-{
-    int x, y, w, h;
-    rfbFramebufferUpdateRectHeader rect;
-    rfbCopyRect cr;
-    sraRectangleIterator* i;
-    sraRect rect1;
-
-    /* printf("copyrect: "); sraRgnPrint(reg); putchar('\n');fflush(stdout); */
-    i = sraRgnGetReverseIterator(reg,dx>0,dy>0);
-
-    /* correct for the scale of the screen */
-    dx = ScaleX(cl->screen, cl->scaledScreen, dx);
-    dy = ScaleX(cl->screen, cl->scaledScreen, dy);
-
-    while(sraRgnIteratorNext(i,&rect1)) {
-      x = rect1.x1;
-      y = rect1.y1;
-      w = rect1.x2 - x;
-      h = rect1.y2 - y;
-
-      /* correct for scaling (if necessary) */
-      rfbScaledCorrection(cl->screen, cl->scaledScreen, &x, &y, &w, &h, "copyrect");
-
-      rect.r.x = Swap16IfLE(x);
-      rect.r.y = Swap16IfLE(y);
-      rect.r.w = Swap16IfLE(w);
-      rect.r.h = Swap16IfLE(h);
-      rect.encoding = Swap32IfLE(rfbEncodingCopyRect);
-
-      memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-	     sz_rfbFramebufferUpdateRectHeader);
-      cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-      cr.srcX = Swap16IfLE(x - dx);
-      cr.srcY = Swap16IfLE(y - dy);
-
-      memcpy(&cl->updateBuf[cl->ublen], (char *)&cr, sz_rfbCopyRect);
-      cl->ublen += sz_rfbCopyRect;
-
-      rfbStatRecordEncodingSent(cl, rfbEncodingCopyRect, sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect,
-          w * h  * (cl->scaledScreen->bitsPerPixel / 8));
-    }
-    sraRgnReleaseIterator(i);
-
-    return TRUE;
-}
-
-/*
- * Send a given rectangle in raw encoding (rfbEncodingRaw).
- */
-
-rfbBool
-rfbSendRectEncodingRaw(rfbClientPtr cl,
-                       int x,
-                       int y,
-                       int w,
-                       int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    int nlines;
-    int bytesPerLine = w * (cl->format.bitsPerPixel / 8);
-    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)
-                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));
-
-    /* Flush the buffer to guarantee correct alignment for translateFn(). */
-    if (cl->ublen > 0) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.r.x = Swap16IfLE(x);
-    rect.r.y = Swap16IfLE(y);
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-    rect.encoding = Swap32IfLE(rfbEncodingRaw);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingRaw, sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h,
-        sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h);
-
-    nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;
-
-    while (TRUE) {
-        if (nlines > h)
-            nlines = h;
-
-        (*cl->translateFn)(cl->translateLookupTable,
-			   &(cl->screen->serverFormat),
-                           &cl->format, fbptr, &cl->updateBuf[cl->ublen],
-                           cl->scaledScreen->paddedWidthInBytes, w, nlines);
-
-        cl->ublen += nlines * bytesPerLine;
-        h -= nlines;
-
-        if (h == 0)     /* rect fitted in buffer, do next one */
-            return TRUE;
-
-        /* buffer full - flush partial rect and do another nlines */
-
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-
-        fbptr += (cl->scaledScreen->paddedWidthInBytes * nlines);
-
-        nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;
-        if (nlines == 0) {
-            rfbErr("rfbSendRectEncodingRaw: send buffer too small for %d "
-                   "bytes per line\n", bytesPerLine);
-            rfbCloseClient(cl);
-            return FALSE;
-        }
-    }
-}
-
-
-
-/*
- * Send an empty rectangle with encoding field set to value of
- * rfbEncodingLastRect to notify client that this is the last
- * rectangle in framebuffer update ("LastRect" extension of RFB
- * protocol).
- */
-
-rfbBool
-rfbSendLastRectMarker(rfbClientPtr cl)
-{
-    rfbFramebufferUpdateRectHeader rect;
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {
-	if (!rfbSendUpdateBuf(cl))
-	    return FALSE;
-    }
-
-    rect.encoding = Swap32IfLE(rfbEncodingLastRect);
-    rect.r.x = 0;
-    rect.r.y = 0;
-    rect.r.w = 0;
-    rect.r.h = 0;
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingLastRect, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);
-
-    return TRUE;
-}
-
-
-/*
- * Send NewFBSize pseudo-rectangle. This tells the client to change
- * its framebuffer size.
- */
-
-rfbBool
-rfbSendNewFBSize(rfbClientPtr cl,
-                 int w,
-                 int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {
-	if (!rfbSendUpdateBuf(cl))
-	    return FALSE;
-    }
-
-    if (cl->PalmVNC==TRUE)
-        rfbLog("Sending rfbEncodingNewFBSize in response to a PalmVNC style framebuffer resize (%dx%d)\n", w, h);
-    else
-        rfbLog("Sending rfbEncodingNewFBSize for resize to (%dx%d)\n", w, h);
-
-    rect.encoding = Swap32IfLE(rfbEncodingNewFBSize);
-    rect.r.x = 0;
-    rect.r.y = 0;
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-           sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingNewFBSize, sz_rfbFramebufferUpdateRectHeader, sz_rfbFramebufferUpdateRectHeader);
-
-    return TRUE;
-}
-
-
-/*
- * Send the contents of cl->updateBuf.  Returns 1 if successful, -1 if
- * not (errno should be set).
- */
-
-rfbBool
-rfbSendUpdateBuf(rfbClientPtr cl)
-{
-    if(cl->sock<0)
-      return FALSE;
-
-    if (rfbWriteExact(cl, cl->updateBuf, cl->ublen) < 0) {
-        rfbLogPerror("rfbSendUpdateBuf: write");
-        rfbCloseClient(cl);
-        return FALSE;
-    }
-
-    cl->ublen = 0;
-    return TRUE;
-}
-
-/*
- * rfbSendSetColourMapEntries sends a SetColourMapEntries message to the
- * client, using values from the currently installed colormap.
- */
-
-rfbBool
-rfbSendSetColourMapEntries(rfbClientPtr cl,
-                           int firstColour,
-                           int nColours)
-{
-    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];
-    char *wbuf = buf;
-    rfbSetColourMapEntriesMsg *scme;
-    uint16_t *rgb;
-    rfbColourMap* cm = &cl->screen->colourMap;
-    int i, len;
-
-    if (nColours > 256) {
-	/* some rare hardware has, e.g., 4096 colors cells: PseudoColor:12 */
-    	wbuf = (char *) malloc(sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2);
-    }
-
-    scme = (rfbSetColourMapEntriesMsg *)wbuf;
-    rgb = (uint16_t *)(&wbuf[sz_rfbSetColourMapEntriesMsg]);
-
-    scme->type = rfbSetColourMapEntries;
-
-    scme->firstColour = Swap16IfLE(firstColour);
-    scme->nColours = Swap16IfLE(nColours);
-
-    len = sz_rfbSetColourMapEntriesMsg;
-
-    for (i = 0; i < nColours; i++) {
-      if(i<(int)cm->count) {
-	if(cm->is16) {
-	  rgb[i*3] = Swap16IfLE(cm->data.shorts[i*3]);
-	  rgb[i*3+1] = Swap16IfLE(cm->data.shorts[i*3+1]);
-	  rgb[i*3+2] = Swap16IfLE(cm->data.shorts[i*3+2]);
-	} else {
-	  rgb[i*3] = Swap16IfLE((unsigned short)cm->data.bytes[i*3]);
-	  rgb[i*3+1] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+1]);
-	  rgb[i*3+2] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+2]);
-	}
-      }
-    }
-
-    len += nColours * 3 * 2;
-
-    LOCK(cl->sendMutex);
-    if (rfbWriteExact(cl, wbuf, len) < 0) {
-	rfbLogPerror("rfbSendSetColourMapEntries: write");
-	rfbCloseClient(cl);
-        if (wbuf != buf) free(wbuf);
-        UNLOCK(cl->sendMutex);
-	return FALSE;
-    }
-    UNLOCK(cl->sendMutex);
-
-    rfbStatRecordMessageSent(cl, rfbSetColourMapEntries, len, len);
-    if (wbuf != buf) free(wbuf);
-    return TRUE;
-}
-
-/*
- * rfbSendBell sends a Bell message to all the clients.
- */
-
-void
-rfbSendBell(rfbScreenInfoPtr rfbScreen)
-{
-    rfbClientIteratorPtr i;
-    rfbClientPtr cl;
-    rfbBellMsg b;
-
-    i = rfbGetClientIterator(rfbScreen);
-    while((cl=rfbClientIteratorNext(i))) {
-	b.type = rfbBell;
-        LOCK(cl->sendMutex);
-	if (rfbWriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {
-	    rfbLogPerror("rfbSendBell: write");
-	    rfbCloseClient(cl);
-	}
-        UNLOCK(cl->sendMutex);
-    }
-    rfbStatRecordMessageSent(cl, rfbBell, sz_rfbBellMsg, sz_rfbBellMsg);
-    rfbReleaseClientIterator(i);
-}
-
-
-/*
- * rfbSendServerCutText sends a ServerCutText message to all the clients.
- */
-
-void
-rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)
-{
-    rfbClientPtr cl;
-    rfbServerCutTextMsg sct;
-    rfbClientIteratorPtr iterator;
-
-    iterator = rfbGetClientIterator(rfbScreen);
-    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {
-        sct.type = rfbServerCutText;
-        sct.length = Swap32IfLE(len);
-        LOCK(cl->sendMutex);
-        if (rfbWriteExact(cl, (char *)&sct,
-                       sz_rfbServerCutTextMsg) < 0) {
-            rfbLogPerror("rfbSendServerCutText: write");
-            rfbCloseClient(cl);
-            UNLOCK(cl->sendMutex);
-            continue;
-        }
-        if (rfbWriteExact(cl, str, len) < 0) {
-            rfbLogPerror("rfbSendServerCutText: write");
-            rfbCloseClient(cl);
-        }
-        UNLOCK(cl->sendMutex);
-        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);
-    }
-    rfbReleaseClientIterator(iterator);
-}
-
-/*****************************************************************************
- *
- * UDP can be used for keyboard and pointer events when the underlying
- * network is highly reliable.  This is really here to support ORL's
- * videotile, whose TCP implementation doesn't like sending lots of small
- * packets (such as 100s of pen readings per second!).
- */
-
-static unsigned char ptrAcceleration = 50;
-
-void
-rfbNewUDPConnection(rfbScreenInfoPtr rfbScreen,
-                    int sock)
-{
-  if (write(sock, (char*) &ptrAcceleration, 1) < 0) {
-	rfbLogPerror("rfbNewUDPConnection: write");
-    }
-}
-
-/*
- * Because UDP is a message based service, we can't read the first byte and
- * then the rest of the packet separately like we do with TCP.  We will always
- * get a whole packet delivered in one go, so we ask read() for the maximum
- * number of bytes we can possibly get.
- */
-
-void
-rfbProcessUDPInput(rfbScreenInfoPtr rfbScreen)
-{
-    int n;
-    rfbClientPtr cl=rfbScreen->udpClient;
-    rfbClientToServerMsg msg;
-
-    if((!cl) || cl->onHold)
-      return;
-
-    if ((n = read(rfbScreen->udpSock, (char *)&msg, sizeof(msg))) <= 0) {
-	if (n < 0) {
-	    rfbLogPerror("rfbProcessUDPInput: read");
-	}
-	rfbDisconnectUDPSock(rfbScreen);
-	return;
-    }
-
-    switch (msg.type) {
-
-    case rfbKeyEvent:
-	if (n != sz_rfbKeyEventMsg) {
-	    rfbErr("rfbProcessUDPInput: key event incorrect length\n");
-	    rfbDisconnectUDPSock(rfbScreen);
-	    return;
-	}
-	cl->screen->kbdAddEvent(msg.ke.down, (rfbKeySym)Swap32IfLE(msg.ke.key), cl);
-	break;
-
-    case rfbPointerEvent:
-	if (n != sz_rfbPointerEventMsg) {
-	    rfbErr("rfbProcessUDPInput: ptr event incorrect length\n");
-	    rfbDisconnectUDPSock(rfbScreen);
-	    return;
-	}
-	cl->screen->ptrAddEvent(msg.pe.buttonMask,
-		    Swap16IfLE(msg.pe.x), Swap16IfLE(msg.pe.y), cl);
-	break;
-
-    default:
-	rfbErr("rfbProcessUDPInput: unknown message type %d\n",
-	       msg.type);
-	rfbDisconnectUDPSock(rfbScreen);
-    }
-}
-
-
diff --git a/libvncserver/rre.c b/libvncserver/rre.c
deleted file mode 100644
index 8454b00..0000000
--- a/libvncserver/rre.c
+++ /dev/null
@@ -1,309 +0,0 @@
-/*
- * rre.c
- *
- * Routines to implement Rise-and-Run-length Encoding (RRE).  This
- * code is based on krw's original javatel rfbserver.
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-/*
- * cl->beforeEncBuf contains pixel data in the client's format.
- * cl->afterEncBuf contains the RRE encoded version.  If the RRE encoded version is
- * larger than the raw data or if it exceeds cl->afterEncBufSize then
- * raw encoding is used instead.
- */
-
-static int subrectEncode8(rfbClientPtr cl, uint8_t *data, int w, int h);
-static int subrectEncode16(rfbClientPtr cl, uint16_t *data, int w, int h);
-static int subrectEncode32(rfbClientPtr cl, uint32_t *data, int w, int h);
-static uint32_t getBgColour(char *data, int size, int bpp);
-
-
-/*
- * rfbSendRectEncodingRRE - send a given rectangle using RRE encoding.
- */
-
-rfbBool
-rfbSendRectEncodingRRE(rfbClientPtr cl,
-                       int x,
-                       int y,
-                       int w,
-                       int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    rfbRREHeader hdr;
-    int nSubrects;
-    int i;
-    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)
-                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));
-
-    int maxRawSize = (cl->scaledScreen->width * cl->scaledScreen->height
-                      * (cl->format.bitsPerPixel / 8));
-
-    if (cl->beforeEncBufSize < maxRawSize) {
-        cl->beforeEncBufSize = maxRawSize;
-        if (cl->beforeEncBuf == NULL)
-            cl->beforeEncBuf = (char *)malloc(cl->beforeEncBufSize);
-        else
-            cl->beforeEncBuf = (char *)realloc(cl->beforeEncBuf, cl->beforeEncBufSize);
-    }
-
-    if (cl->afterEncBufSize < maxRawSize) {
-        cl->afterEncBufSize = maxRawSize;
-        if (cl->afterEncBuf == NULL)
-            cl->afterEncBuf = (char *)malloc(cl->afterEncBufSize);
-        else
-            cl->afterEncBuf = (char *)realloc(cl->afterEncBuf, cl->afterEncBufSize);
-    }
-
-    (*cl->translateFn)(cl->translateLookupTable,
-		       &(cl->screen->serverFormat),
-                       &cl->format, fbptr, cl->beforeEncBuf,
-                       cl->scaledScreen->paddedWidthInBytes, w, h);
-
-    switch (cl->format.bitsPerPixel) {
-    case 8:
-        nSubrects = subrectEncode8(cl, (uint8_t *)cl->beforeEncBuf, w, h);
-        break;
-    case 16:
-        nSubrects = subrectEncode16(cl, (uint16_t *)cl->beforeEncBuf, w, h);
-        break;
-    case 32:
-        nSubrects = subrectEncode32(cl, (uint32_t *)cl->beforeEncBuf, w, h);
-        break;
-    default:
-        rfbLog("getBgColour: bpp %d?\n",cl->format.bitsPerPixel);
-        return FALSE;
-    }
-        
-    if (nSubrects < 0) {
-
-        /* RRE encoding was too large, use raw */
-
-        return rfbSendRectEncodingRaw(cl, x, y, w, h);
-    }
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingRRE,
-                              sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader + cl->afterEncBufLen,
-                              sz_rfbFramebufferUpdateRectHeader + w * h * (cl->format.bitsPerPixel / 8));
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader
-        > UPDATE_BUF_SIZE)
-    {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.r.x = Swap16IfLE(x);
-    rect.r.y = Swap16IfLE(y);
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-    rect.encoding = Swap32IfLE(rfbEncodingRRE);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-           sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    hdr.nSubrects = Swap32IfLE(nSubrects);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbRREHeader);
-    cl->ublen += sz_rfbRREHeader;
-
-    for (i = 0; i < cl->afterEncBufLen;) {
-
-        int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;
-
-        if (i + bytesToCopy > cl->afterEncBufLen) {
-            bytesToCopy = cl->afterEncBufLen - i;
-        }
-
-        memcpy(&cl->updateBuf[cl->ublen], &cl->afterEncBuf[i], bytesToCopy);
-
-        cl->ublen += bytesToCopy;
-        i += bytesToCopy;
-
-        if (cl->ublen == UPDATE_BUF_SIZE) {
-            if (!rfbSendUpdateBuf(cl))
-                return FALSE;
-        }
-    }
-
-    return TRUE;
-}
-
-
-
-/*
- * subrectEncode() encodes the given multicoloured rectangle as a background 
- * colour overwritten by single-coloured rectangles.  It returns the number 
- * of subrectangles in the encoded buffer, or -1 if subrect encoding won't
- * fit in the buffer.  It puts the encoded rectangles in cl->afterEncBuf.  The
- * single-colour rectangle partition is not optimal, but does find the biggest
- * horizontal or vertical rectangle top-left anchored to each consecutive 
- * coordinate position.
- *
- * The coding scheme is simply [<bgcolour><subrect><subrect>...] where each 
- * <subrect> is [<colour><x><y><w><h>].
- */
-
-#define DEFINE_SUBRECT_ENCODE(bpp)                                            \
-static int                                                                    \
- subrectEncode##bpp(rfbClientPtr client, uint##bpp##_t *data, int w, int h) { \
-    uint##bpp##_t cl;                                                         \
-    rfbRectangle subrect;                                                     \
-    int x,y;                                                                  \
-    int i,j;                                                                  \
-    int hx=0,hy,vx=0,vy;                                                      \
-    int hyflag;                                                               \
-    uint##bpp##_t *seg;                                                       \
-    uint##bpp##_t *line;                                                      \
-    int hw,hh,vw,vh;                                                          \
-    int thex,they,thew,theh;                                                  \
-    int numsubs = 0;                                                          \
-    int newLen;                                                               \
-    uint##bpp##_t bg = (uint##bpp##_t)getBgColour((char*)data,w*h,bpp);       \
-                                                                              \
-    *((uint##bpp##_t*)client->afterEncBuf) = bg;                                      \
-                                                                              \
-    client->afterEncBufLen = (bpp/8);                                                 \
-                                                                              \
-    for (y=0; y<h; y++) {                                                     \
-      line = data+(y*w);                                                      \
-      for (x=0; x<w; x++) {                                                   \
-        if (line[x] != bg) {                                                  \
-          cl = line[x];                                                       \
-          hy = y-1;                                                           \
-          hyflag = 1;                                                         \
-          for (j=y; j<h; j++) {                                               \
-            seg = data+(j*w);                                                 \
-            if (seg[x] != cl) {break;}                                        \
-            i = x;                                                            \
-            while ((seg[i] == cl) && (i < w)) i += 1;                         \
-            i -= 1;                                                           \
-            if (j == y) vx = hx = i;                                          \
-            if (i < vx) vx = i;                                               \
-            if ((hyflag > 0) && (i >= hx)) {hy += 1;} else {hyflag = 0;}      \
-          }                                                                   \
-          vy = j-1;                                                           \
-                                                                              \
-          /*  We now have two possible subrects: (x,y,hx,hy) and (x,y,vx,vy)  \
-           *  We'll choose the bigger of the two.                             \
-           */                                                                 \
-          hw = hx-x+1;                                                        \
-          hh = hy-y+1;                                                        \
-          vw = vx-x+1;                                                        \
-          vh = vy-y+1;                                                        \
-                                                                              \
-          thex = x;                                                           \
-          they = y;                                                           \
-                                                                              \
-          if ((hw*hh) > (vw*vh)) {                                            \
-            thew = hw;                                                        \
-            theh = hh;                                                        \
-          } else {                                                            \
-            thew = vw;                                                        \
-            theh = vh;                                                        \
-          }                                                                   \
-                                                                              \
-          subrect.x = Swap16IfLE(thex);                                       \
-          subrect.y = Swap16IfLE(they);                                       \
-          subrect.w = Swap16IfLE(thew);                                       \
-          subrect.h = Swap16IfLE(theh);                                       \
-                                                                              \
-          newLen = client->afterEncBufLen + (bpp/8) + sz_rfbRectangle;                \
-          if ((newLen > (w * h * (bpp/8))) || (newLen > client->afterEncBufSize))     \
-            return -1;                                                        \
-                                                                              \
-          numsubs += 1;                                                       \
-          *((uint##bpp##_t*)(client->afterEncBuf + client->afterEncBufLen)) = cl;             \
-          client->afterEncBufLen += (bpp/8);                                          \
-          memcpy(&client->afterEncBuf[client->afterEncBufLen],&subrect,sz_rfbRectangle);      \
-          client->afterEncBufLen += sz_rfbRectangle;                                  \
-                                                                              \
-          /*                                                                  \
-           * Now mark the subrect as done.                                    \
-           */                                                                 \
-          for (j=they; j < (they+theh); j++) {                                \
-            for (i=thex; i < (thex+thew); i++) {                              \
-              data[j*w+i] = bg;                                               \
-            }                                                                 \
-          }                                                                   \
-        }                                                                     \
-      }                                                                       \
-    }                                                                         \
-                                                                              \
-    return numsubs;                                                           \
-}
-
-DEFINE_SUBRECT_ENCODE(8)
-DEFINE_SUBRECT_ENCODE(16)
-DEFINE_SUBRECT_ENCODE(32)
-
-
-/*
- * getBgColour() gets the most prevalent colour in a byte array.
- */
-static uint32_t
-getBgColour(char *data, int size, int bpp)
-{
-    
-#define NUMCLRS 256
-  
-  static int counts[NUMCLRS];
-  int i,j,k;
-
-  int maxcount = 0;
-  uint8_t maxclr = 0;
-
-  if (bpp != 8) {
-    if (bpp == 16) {
-      return ((uint16_t *)data)[0];
-    } else if (bpp == 32) {
-      return ((uint32_t *)data)[0];
-    } else {
-      rfbLog("getBgColour: bpp %d?\n",bpp);
-      return 0;
-    }
-  }
-
-  for (i=0; i<NUMCLRS; i++) {
-    counts[i] = 0;
-  }
-
-  for (j=0; j<size; j++) {
-    k = (int)(((uint8_t *)data)[j]);
-    if (k >= NUMCLRS) {
-      rfbErr("getBgColour: unusual colour = %d\n", k);
-      return 0;
-    }
-    counts[k] += 1;
-    if (counts[k] > maxcount) {
-      maxcount = counts[k];
-      maxclr = ((uint8_t *)data)[j];
-    }
-  }
-  
-  return maxclr;
-}
diff --git a/libvncserver/scale.c b/libvncserver/scale.c
deleted file mode 100644
index 3469510..0000000
--- a/libvncserver/scale.c
+++ /dev/null
@@ -1,416 +0,0 @@
-/*
- * scale.c - deal with server-side scaling.
- */
-
-/*
- *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin
- *  Copyright (C) 2002 RealVNC Ltd.
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#endif
-#include <string.h>
-#include "rfb/rfb.h"
-#include "rfb/rfbregion.h"
-#include "private.h"
-
-#ifdef LIBVNCSERVER_HAVE_FCNTL_H
-#include <fcntl.h>
-#endif
-
-#ifdef WIN32
-#define write(sock,buf,len) send(sock,buf,len,0)
-#else
-#ifdef LIBVNCSERVER_HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <pwd.h>
-#ifdef LIBVNCSERVER_HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <arpa/inet.h>
-#endif
-#endif
-
-#ifdef DEBUGPROTO
-#undef DEBUGPROTO
-#define DEBUGPROTO(x) x
-#else
-#define DEBUGPROTO(x)
-#endif
-
-/****************************/
-#define CEIL(x)  ( (double) ((int) (x)) == (x) ? \
-        (double) ((int) (x)) : (double) ((int) (x) + 1) )
-#define FLOOR(x) ( (double) ((int) (x)) )
-
-
-int ScaleX(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int x)
-{
-    if ((from==to) || (from==NULL) || (to==NULL)) return x;
-    return ((int)(((double) x / (double)from->width) * (double)to->width ));
-}
-
-int ScaleY(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int y)
-{
-    if ((from==to) || (from==NULL) || (to==NULL)) return y;
-    return ((int)(((double) y / (double)from->height) * (double)to->height ));
-}
-
-/* So, all of the encodings point to the ->screen->frameBuffer,
- * We need to change this!
- */
-void rfbScaledCorrection(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int *x, int *y, int *w, int *h, const char *function)
-{
-    double x1,y1,w1,h1, x2, y2, w2, h2;
-    double scaleW = ((double) to->width) / ((double) from->width);
-    double scaleH = ((double) to->height) / ((double) from->height);
-
-
-    /*
-     * rfbLog("rfbScaledCorrection(%p -> %p, %dx%d->%dx%d (%dXx%dY-%dWx%dH)\n",
-     * from, to, from->width, from->height, to->width, to->height, *x, *y, *w, *h);
-     */
-
-    /* If it's the original framebuffer... */
-    if (from==to) return;
-
-    x1 = ((double) *x) * scaleW;
-    y1 = ((double) *y) * scaleH;
-    w1 = ((double) *w) * scaleW;
-    h1 = ((double) *h) * scaleH;
-
-
-    /*cast from double to int is same as "*x = floor(x1);" */
-    x2 = FLOOR(x1);
-    y2 = FLOOR(y1);
-
-    /* include into W and H the jitter of scaling X and Y */
-    w2 = CEIL(w1 + ( x1 - x2 ));
-    h2 = CEIL(h1 + ( y1 - y2 ));
-
-    /*
-     * rfbLog("%s (%dXx%dY-%dWx%dH  ->  %fXx%fY-%fWx%fH) {%dWx%dH -> %dWx%dH}\n",
-     *    function, *x, *y, *w, *h, x2, y2, w2, h2,
-     *    from->width, from->height, to->width, to->height);
-     */
-
-    /* simulate ceil() without math library */
-    *x = (int)x2;
-    *y = (int)y2;
-    *w = (int)w2;
-    *h = (int)h2;
-
-    /* Small changes for a thumbnail may be scaled to zero */
-    if (*w==0) (*w)++;
-    if (*h==0) (*h)++;
-    /* scaling from small to big may overstep the size a bit */
-    if (*x+*w > to->width)  *w=to->width - *x;
-    if (*y+*h > to->height) *h=to->height - *y;
-}
-
-void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0)
-{
-    int x,y,w,v,z;
-    int x1, y1, w1, h1;
-    int bitsPerPixel, bytesPerPixel, bytesPerLine, areaX, areaY, area2;
-    unsigned char *srcptr, *dstptr;
-
-    /* Nothing to do!!! */
-    if (screen==ptr) return;
-
-    x1 = x0;
-    y1 = y0;
-    w1 = w0;
-    h1 = h0;
-
-    rfbScaledCorrection(screen, ptr, &x1, &y1, &w1, &h1, "rfbScaledScreenUpdateRect");
-    x0 = ScaleX(ptr, screen, x1);
-    y0 = ScaleY(ptr, screen, y1);
-    w0 = ScaleX(ptr, screen, w1);
-    h0 = ScaleY(ptr, screen, h1);
-
-    bitsPerPixel = screen->bitsPerPixel;
-    bytesPerPixel = bitsPerPixel / 8;
-    bytesPerLine = w1 * bytesPerPixel;
-    srcptr = (unsigned char *)(screen->frameBuffer +
-     (y0 * screen->paddedWidthInBytes + x0 * bytesPerPixel));
-    dstptr = (unsigned char *)(ptr->frameBuffer +
-     ( y1 * ptr->paddedWidthInBytes + x1 * bytesPerPixel));
-    /* The area of the source framebuffer for each destination pixel */
-    areaX = ScaleX(ptr,screen,1);
-    areaY = ScaleY(ptr,screen,1);
-    area2 = areaX*areaY;
-
-
-    /* Ensure that we do not go out of bounds */
-    if ((x1+w1) > (ptr->width))
-    {
-      if (x1==0) w1=ptr->width; else x1 = ptr->width - w1;
-    }
-    if ((y1+h1) > (ptr->height))
-    {
-      if (y1==0) h1=ptr->height; else y1 = ptr->height - h1;
-    }
-    /*
-     * rfbLog("rfbScaledScreenUpdateRect(%dXx%dY-%dWx%dH  ->  %dXx%dY-%dWx%dH <%dx%d>) {%dWx%dH -> %dWx%dH} 0x%p\n",
-     *    x0, y0, w0, h0, x1, y1, w1, h1, areaX, areaY,
-     *    screen->width, screen->height, ptr->width, ptr->height, ptr->frameBuffer);
-     */
-
-    if (screen->serverFormat.trueColour) { /* Blend neighbouring pixels together */
-      unsigned char *srcptr2;
-      unsigned long pixel_value, red, green, blue;
-      unsigned int redShift = screen->serverFormat.redShift;
-      unsigned int greenShift = screen->serverFormat.greenShift;
-      unsigned int blueShift = screen->serverFormat.blueShift;
-      unsigned long redMax = screen->serverFormat.redMax;
-      unsigned long greenMax = screen->serverFormat.greenMax;
-      unsigned long blueMax = screen->serverFormat.blueMax;
-
-     /* for each *destination* pixel... */
-     for (y = 0; y < h1; y++) {
-       for (x = 0; x < w1; x++) {
-         red = green = blue = 0;
-         /* Get the totals for rgb from the source grid... */
-         for (w = 0; w < areaX; w++) {
-           for (v = 0; v < areaY; v++) {
-             srcptr2 = &srcptr[(((x * areaX) + w) * bytesPerPixel) +
-                               (v * screen->paddedWidthInBytes)];
-             pixel_value = 0;
-
-
-             switch (bytesPerPixel) {
-             case 4: pixel_value = *((unsigned int *)srcptr2);   break;
-             case 2: pixel_value = *((unsigned short *)srcptr2); break;
-             case 1: pixel_value = *((unsigned char *)srcptr2);  break;
-             default:
-               /* fixme: endianess problem? */
-               for (z = 0; z < bytesPerPixel; z++)
-                 pixel_value += (srcptr2[z] << (8 * z));
-                break;
-              }
-              /*
-              srcptr2 += bytesPerPixel;
-              */
-
-            red += ((pixel_value >> redShift) & redMax);
-            green += ((pixel_value >> greenShift) & greenMax);
-            blue += ((pixel_value >> blueShift) & blueMax);
-
-           }
-         }
-         /* We now have a total for all of the colors, find the average! */
-         red /= area2;
-         green /= area2;
-         blue /= area2;
-          /* Stuff the new value back into memory */
-         pixel_value = ((red & redMax) << redShift) | ((green & greenMax) << greenShift) | ((blue & blueMax) << blueShift);
-
-         switch (bytesPerPixel) {
-         case 4: *((unsigned int *)dstptr)   = (unsigned int)   pixel_value; break;
-         case 2: *((unsigned short *)dstptr) = (unsigned short) pixel_value; break;
-         case 1: *((unsigned char *)dstptr)  = (unsigned char)  pixel_value; break;
-         default:
-           /* fixme: endianess problem? */
-           for (z = 0; z < bytesPerPixel; z++)
-             dstptr[z]=(pixel_value >> (8 * z)) & 0xff;
-            break;
-          }
-          dstptr += bytesPerPixel;
-       }
-       srcptr += (screen->paddedWidthInBytes * areaY);
-       dstptr += (ptr->paddedWidthInBytes - bytesPerLine);
-     }
-   } else
-   { /* Not truecolour, so we can't blend. Just use the top-left pixel instead */
-     for (y = y1; y < (y1+h1); y++) {
-       for (x = x1; x < (x1+w1); x++)
-         memcpy (&ptr->frameBuffer[(y *ptr->paddedWidthInBytes) + (x * bytesPerPixel)],
-                 &screen->frameBuffer[(y * areaY * screen->paddedWidthInBytes) + (x *areaX * bytesPerPixel)], bytesPerPixel);
-     }
-  }
-}
-
-void rfbScaledScreenUpdate(rfbScreenInfoPtr screen, int x1, int y1, int x2, int y2)
-{
-    /* ok, now the task is to update each and every scaled version of the framebuffer
-     * and we only have to do this for this specific changed rectangle!
-     */
-    rfbScreenInfoPtr ptr;
-    int count=0;
-
-    /* We don't point to cl->screen as it is the original */
-    for (ptr=screen->scaledScreenNext;ptr!=NULL;ptr=ptr->scaledScreenNext)
-    {
-        /* Only update if it has active clients... */
-        if (ptr->scaledScreenRefCount>0)
-        {
-          rfbScaledScreenUpdateRect(screen, ptr, x1, y1, x2-x1, y2-y1);
-          count++;
-        }
-    }
-}
-
-/* Create a new scaled version of the framebuffer */
-rfbScreenInfoPtr rfbScaledScreenAllocate(rfbClientPtr cl, int width, int height)
-{
-    rfbScreenInfoPtr ptr;
-    ptr = malloc(sizeof(rfbScreenInfo));
-    if (ptr!=NULL)
-    {
-        /* copy *everything* (we don't use most of it, but just in case) */
-        memcpy(ptr, cl->screen, sizeof(rfbScreenInfo));
-        ptr->width = width;
-        ptr->height = height;
-        ptr->paddedWidthInBytes = (ptr->bitsPerPixel/8)*ptr->width;
-
-        /* Need to by multiples of 4 for Sparc systems */
-        ptr->paddedWidthInBytes += (ptr->paddedWidthInBytes % 4);
-
-        /* Reset the reference count to 0! */
-        ptr->scaledScreenRefCount = 0;
-
-        ptr->sizeInBytes = ptr->paddedWidthInBytes * ptr->height;
-        ptr->serverFormat = cl->screen->serverFormat;
-
-        ptr->frameBuffer = malloc(ptr->sizeInBytes);
-        if (ptr->frameBuffer!=NULL)
-        {
-            /* Reset to a known condition: scale the entire framebuffer */
-            rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);
-            /* Now, insert into the chain */
-            LOCK(cl->updateMutex);
-            ptr->scaledScreenNext = cl->screen->scaledScreenNext;
-            cl->screen->scaledScreenNext = ptr;
-            UNLOCK(cl->updateMutex);
-        }
-        else
-        {
-            /* Failed to malloc the new frameBuffer, cleanup */
-            free(ptr);
-            ptr=NULL;
-        }
-    }
-    return ptr;
-}
-
-/* Find an active scaled version of the framebuffer
- * TODO: implement a refcount per scaled screen to prevent
- * unreferenced scaled screens from hanging around
- */
-rfbScreenInfoPtr rfbScalingFind(rfbClientPtr cl, int width, int height)
-{
-    rfbScreenInfoPtr ptr;
-    /* include the original in the search (ie: fine 1:1 scaled version of the frameBuffer) */
-    for (ptr=cl->screen; ptr!=NULL; ptr=ptr->scaledScreenNext)
-    {
-        if ((ptr->width==width) && (ptr->height==height))
-            return ptr;
-    }
-    return NULL;
-}
-
-/* Future needs "scale to 320x240, as that's the client's screen size */
-void rfbScalingSetup(rfbClientPtr cl, int width, int height)
-{
-    rfbScreenInfoPtr ptr;
-
-    ptr = rfbScalingFind(cl,width,height);
-    if (ptr==NULL)
-        ptr = rfbScaledScreenAllocate(cl,width,height);
-    /* Now, there is a new screen available (if ptr is not NULL) */
-    if (ptr!=NULL)
-    {
-        /* Update it! */
-        if (ptr->scaledScreenRefCount<1)
-            rfbScaledScreenUpdateRect(cl->screen, ptr, 0, 0, cl->screen->width, cl->screen->height);
-        /*
-         * rfbLog("Taking one from %dx%d-%d and adding it to %dx%d-%d\n",
-         *    cl->scaledScreen->width, cl->scaledScreen->height,
-         *    cl->scaledScreen->scaledScreenRefCount,
-         *    ptr->width, ptr->height, ptr->scaledScreenRefCount);
-         */
-
-        LOCK(cl->updateMutex);
-        cl->scaledScreen->scaledScreenRefCount--;
-        ptr->scaledScreenRefCount++;
-        cl->scaledScreen=ptr;
-        cl->newFBSizePending = TRUE;
-        UNLOCK(cl->updateMutex);
-
-        rfbLog("Scaling to %dx%d (refcount=%d)\n",width,height,ptr->scaledScreenRefCount);
-    }
-    else
-        rfbLog("Scaling to %dx%d failed, leaving things alone\n",width,height);
-}
-
-int rfbSendNewScaleSize(rfbClientPtr cl)
-{
-    /* if the client supports newFBsize Encoding, use it */
-    if (cl->useNewFBSize && cl->newFBSizePending)
-	return FALSE;
-
-    LOCK(cl->updateMutex);
-    cl->newFBSizePending = FALSE;
-    UNLOCK(cl->updateMutex);
-
-    if (cl->PalmVNC==TRUE)
-    {
-        rfbPalmVNCReSizeFrameBufferMsg pmsg;
-        pmsg.type = rfbPalmVNCReSizeFrameBuffer;
-        pmsg.pad1 = 0;
-        pmsg.desktop_w = Swap16IfLE(cl->screen->width);
-        pmsg.desktop_h = Swap16IfLE(cl->screen->height);
-        pmsg.buffer_w  = Swap16IfLE(cl->scaledScreen->width);
-        pmsg.buffer_h  = Swap16IfLE(cl->scaledScreen->height);
-        pmsg.pad2 = 0;
-
-        rfbLog("Sending a response to a PalmVNC style frameuffer resize event (%dx%d)\n", cl->scaledScreen->width, cl->scaledScreen->height);
-        if (rfbWriteExact(cl, (char *)&pmsg, sz_rfbPalmVNCReSizeFrameBufferMsg) < 0) {
-            rfbLogPerror("rfbNewClient: write");
-            rfbCloseClient(cl);
-            rfbClientConnectionGone(cl);
-            return FALSE;
-        }
-    }
-    else
-    {
-        rfbResizeFrameBufferMsg        rmsg;
-        rmsg.type = rfbResizeFrameBuffer;
-        rmsg.pad1=0;
-        rmsg.framebufferWidth  = Swap16IfLE(cl->scaledScreen->width);
-        rmsg.framebufferHeigth = Swap16IfLE(cl->scaledScreen->height);
-        rfbLog("Sending a response to a UltraVNC style frameuffer resize event (%dx%d)\n", cl->scaledScreen->width, cl->scaledScreen->height);
-        if (rfbWriteExact(cl, (char *)&rmsg, sz_rfbResizeFrameBufferMsg) < 0) {
-            rfbLogPerror("rfbNewClient: write");
-            rfbCloseClient(cl);
-            rfbClientConnectionGone(cl);
-            return FALSE;
-        }
-    }
-    return TRUE;
-}
-/****************************/
diff --git a/libvncserver/scale.h b/libvncserver/scale.h
deleted file mode 100644
index a030d4b..0000000
--- a/libvncserver/scale.h
+++ /dev/null
@@ -1,10 +0,0 @@
-
-int ScaleX(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int x);
-int ScaleY(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int y);
-void rfbScaledCorrection(rfbScreenInfoPtr from, rfbScreenInfoPtr to, int *x, int *y, int *w, int *h, const char *function);
-void rfbScaledScreenUpdateRect(rfbScreenInfoPtr screen, rfbScreenInfoPtr ptr, int x0, int y0, int w0, int h0);
-void rfbScaledScreenUpdate(rfbScreenInfoPtr screen, int x1, int y1, int x2, int y2);
-rfbScreenInfoPtr rfbScaledScreenAllocate(rfbClientPtr cl, int width, int height);
-rfbScreenInfoPtr rfbScalingFind(rfbClientPtr cl, int width, int height);
-void rfbScalingSetup(rfbClientPtr cl, int width, int height);
-int rfbSendNewScaleSize(rfbClientPtr cl);
diff --git a/libvncserver/selbox.c b/libvncserver/selbox.c
deleted file mode 100644
index 3ad428f..0000000
--- a/libvncserver/selbox.c
+++ /dev/null
@@ -1,300 +0,0 @@
-#include <ctype.h>
-#include "rfb/rfb.h"
-#include "rfb/keysym.h"
-
-typedef struct {
-  rfbScreenInfoPtr screen;
-  rfbFontDataPtr font;
-  char** list;
-  int listSize;
-  int selected;
-  int displayStart;
-  int x1,y1,x2,y2,textH,pageH;
-  int xhot,yhot;
-  int buttonWidth,okBX,cancelBX,okX,cancelX,okY;
-  rfbBool okInverted,cancelInverted;
-  int lastButtons;
-  rfbPixel colour,backColour;
-  SelectionChangedHookPtr selChangedHook;
-  enum { SELECTING, OK, CANCEL } state;
-} rfbSelectData;
-
-static const char* okStr="OK";
-static const char* cancelStr="Cancel";
-
-static void selPaintButtons(rfbSelectData* m,rfbBool invertOk,rfbBool invertCancel)
-{
-  rfbScreenInfoPtr s = m->screen;
-  rfbPixel bcolour = m->backColour;
-  rfbPixel colour = m->colour;
-
-  rfbFillRect(s,m->x1,m->okY-m->textH,m->x2,m->okY,bcolour);
-
-  if(invertOk) {
-    rfbFillRect(s,m->okBX,m->okY-m->textH,m->okBX+m->buttonWidth,m->okY,colour);
-    rfbDrawStringWithClip(s,m->font,m->okX+m->xhot,m->okY-1+m->yhot,okStr,
-			  m->x1,m->okY-m->textH,m->x2,m->okY,
-			  bcolour,colour);
-  } else
-    rfbDrawString(s,m->font,m->okX+m->xhot,m->okY-1+m->yhot,okStr,colour);
-    
-  if(invertCancel) {
-    rfbFillRect(s,m->cancelBX,m->okY-m->textH,
-	     m->cancelBX+m->buttonWidth,m->okY,colour);
-    rfbDrawStringWithClip(s,m->font,m->cancelX+m->xhot,m->okY-1+m->yhot,
-			  cancelStr,m->x1,m->okY-m->textH,m->x2,m->okY,
-			  bcolour,colour);
-  } else
-    rfbDrawString(s,m->font,m->cancelX+m->xhot,m->okY-1+m->yhot,cancelStr,colour);
-
-  m->okInverted = invertOk;
-  m->cancelInverted = invertCancel;
-}
-
-/* line is relative to displayStart */
-static void selPaintLine(rfbSelectData* m,int line,rfbBool invert)
-{
-  int y1 = m->y1+line*m->textH, y2 = y1+m->textH;
-  if(y2>m->y2)
-    y2=m->y2;
-  rfbFillRect(m->screen,m->x1,y1,m->x2,y2,invert?m->colour:m->backColour);
-  if(m->displayStart+line<m->listSize)
-    rfbDrawStringWithClip(m->screen,m->font,m->x1+m->xhot,y2-1+m->yhot,
-			  m->list[m->displayStart+line],
-			  m->x1,y1,m->x2,y2,
-			  invert?m->backColour:m->colour,
-			  invert?m->backColour:m->colour);
-}
-
-static void selSelect(rfbSelectData* m,int _index)
-{
-  int delta;
-
-  if(_index==m->selected || _index<0 || _index>=m->listSize)
-    return;
-
-  if(m->selected>=0)
-    selPaintLine(m,m->selected-m->displayStart,FALSE);
-
-  if(_index<m->displayStart || _index>=m->displayStart+m->pageH) {
-    /* targetLine is the screen line in which the selected line will
-       be displayed.
-       targetLine = m->pageH/2 doesn't look so nice */
-    int targetLine = m->selected-m->displayStart;
-    int lineStart,lineEnd;
-
-    /* scroll */
-    if(_index<targetLine)
-      targetLine = _index;
-    else if(_index+m->pageH-targetLine>=m->listSize)
-      targetLine = _index+m->pageH-m->listSize;
-    delta = _index-(m->displayStart+targetLine);
-
-    if(delta>-m->pageH && delta<m->pageH) {
-      if(delta>0) {
-	lineStart = m->pageH-delta;
-	lineEnd = m->pageH;
-	rfbDoCopyRect(m->screen,m->x1,m->y1,m->x2,m->y1+lineStart*m->textH,
-		      0,-delta*m->textH);
-      } else {
-	lineStart = 0;
-	lineEnd = -delta;
-	rfbDoCopyRect(m->screen,
-		      m->x1,m->y1+lineEnd*m->textH,m->x2,m->y2,
-		      0,-delta*m->textH);
-      }
-    } else {
-      lineStart = 0;
-      lineEnd = m->pageH;
-    }
-    m->displayStart += delta;
-    for(delta=lineStart;delta<lineEnd;delta++)
-      if(delta!=_index)
-	selPaintLine(m,delta,FALSE);
-  }
-
-  m->selected = _index;
-  selPaintLine(m,m->selected-m->displayStart,TRUE);
-
-  if(m->selChangedHook)
-    m->selChangedHook(_index);
-
-  /* todo: scrollbars */
-}
-
-static void selKbdAddEvent(rfbBool down,rfbKeySym keySym,rfbClientPtr cl)
-{
-  if(down) {
-    if(keySym>' ' && keySym<0xff) {
-      int i;
-      rfbSelectData* m = (rfbSelectData*)cl->screen->screenData;
-      char c = tolower(keySym);
-
-      for(i=m->selected+1;m->list[i] && tolower(m->list[i][0])!=c;i++);
-      if(!m->list[i])
-	for(i=0;i<m->selected && tolower(m->list[i][0])!=c;i++);
-      selSelect(m,i);
-    } else if(keySym==XK_Escape) {
-      rfbSelectData* m = (rfbSelectData*)cl->screen->screenData;
-      m->state = CANCEL;
-    } else if(keySym==XK_Return) {
-      rfbSelectData* m = (rfbSelectData*)cl->screen->screenData;
-      m->state = OK;
-    } else {
-      rfbSelectData* m = (rfbSelectData*)cl->screen->screenData;
-      int curSel=m->selected;
-      if(keySym==XK_Up) {
-	if(curSel>0)
-	  selSelect(m,curSel-1);
-      } else if(keySym==XK_Down) {
-	if(curSel+1<m->listSize)
-	  selSelect(m,curSel+1);
-      } else {
-	if(keySym==XK_Page_Down) {
-	  if(curSel+m->pageH<m->listSize)
-	    selSelect(m,curSel+m->pageH);
-	  else
-	    selSelect(m,m->listSize-1);
-	} else if(keySym==XK_Page_Up) {
-	  if(curSel-m->pageH>=0)
-	    selSelect(m,curSel-m->pageH);
-	  else
-	    selSelect(m,0);
-	}
-      }
-    }
-  }
-}
-
-static void selPtrAddEvent(int buttonMask,int x,int y,rfbClientPtr cl)
-{
-  rfbSelectData* m = (rfbSelectData*)cl->screen->screenData;
-  if(y<m->okY && y>=m->okY-m->textH) {
-    if(x>=m->okBX && x<m->okBX+m->buttonWidth) {
-      if(!m->okInverted)
-	selPaintButtons(m,TRUE,FALSE);
-      if(buttonMask)
-	m->state = OK;
-    } else if(x>=m->cancelBX && x<m->cancelBX+m->buttonWidth) {
-      if(!m->cancelInverted)
-	selPaintButtons(m,FALSE,TRUE);
-      if(buttonMask)
-	m->state = CANCEL;
-    } else if(m->okInverted || m->cancelInverted)
-      selPaintButtons(m,FALSE,FALSE);
-  } else {
-    if(m->okInverted || m->cancelInverted)
-      selPaintButtons(m,FALSE,FALSE);
-    if(!m->lastButtons && buttonMask) {
-      if(x>=m->x1 && x<m->x2 && y>=m->y1 && y<m->y2)
-	selSelect(m,m->displayStart+(y-m->y1)/m->textH);
-    }
-  }
-  m->lastButtons = buttonMask;
-
-  /* todo: scrollbars */
-}
-
-static rfbCursorPtr selGetCursorPtr(rfbClientPtr cl)
-{
-  return NULL;
-}
-
-int rfbSelectBox(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,
-		 char** list,
-		 int x1,int y1,int x2,int y2,
-		 rfbPixel colour,rfbPixel backColour,
-		 int border,SelectionChangedHookPtr selChangedHook)
-{
-   int bpp = rfbScreen->bitsPerPixel/8;
-   char* frameBufferBackup;
-   void* screenDataBackup = rfbScreen->screenData;
-   rfbKbdAddEventProcPtr kbdAddEventBackup = rfbScreen->kbdAddEvent;
-   rfbPtrAddEventProcPtr ptrAddEventBackup = rfbScreen->ptrAddEvent;
-   rfbGetCursorProcPtr getCursorPtrBackup = rfbScreen->getCursorPtr;
-   rfbDisplayHookPtr displayHookBackup = rfbScreen->displayHook;
-   rfbSelectData selData;
-   int i,j,k;
-   int fx1,fy1,fx2,fy2; /* for font bbox */
-
-   if(list==0 || *list==0)
-     return(-1);
-   
-   rfbWholeFontBBox(font, &fx1, &fy1, &fx2, &fy2);
-   selData.textH = fy2-fy1;
-   /* I need at least one line for the choice and one for the buttons */
-   if(y2-y1<selData.textH*2+3*border)
-     return(-1);
-   selData.xhot = -fx1;
-   selData.yhot = -fy2;
-   selData.x1 = x1+border;
-   selData.y1 = y1+border;
-   selData.y2 = y2-selData.textH-3*border;
-   selData.x2 = x2-2*border;
-   selData.pageH = (selData.y2-selData.y1)/selData.textH;
-
-   i = rfbWidthOfString(font,okStr);
-   j = rfbWidthOfString(font,cancelStr);
-   selData.buttonWidth= k = 4*border+(i<j)?j:i;
-   selData.okBX = x1+(x2-x1-2*k)/3;
-   if(selData.okBX<x1+border) /* too narrow! */
-     return(-1);
-   selData.cancelBX = x1+k+(x2-x1-2*k)*2/3;
-   selData.okX = selData.okBX+(k-i)/2;
-   selData.cancelX = selData.cancelBX+(k-j)/2;
-   selData.okY = y2-border;
-
-   frameBufferBackup = (char*)malloc(bpp*(x2-x1)*(y2-y1));
-
-   selData.state = SELECTING;
-   selData.screen = rfbScreen;
-   selData.font = font;
-   selData.list = list;
-   selData.colour = colour;
-   selData.backColour = backColour;
-   for(i=0;list[i];i++);
-   selData.selected = i;
-   selData.listSize = i;
-   selData.displayStart = i;
-   selData.lastButtons = 0;
-   selData.selChangedHook = selChangedHook;
-   
-   rfbScreen->screenData = &selData;
-   rfbScreen->kbdAddEvent = selKbdAddEvent;
-   rfbScreen->ptrAddEvent = selPtrAddEvent;
-   rfbScreen->getCursorPtr = selGetCursorPtr;
-   rfbScreen->displayHook = NULL;
-   
-   /* backup screen */
-   for(j=0;j<y2-y1;j++)
-     memcpy(frameBufferBackup+j*(x2-x1)*bpp,
-	    rfbScreen->frameBuffer+j*rfbScreen->paddedWidthInBytes+x1*bpp,
-	    (x2-x1)*bpp);
-
-   /* paint list and buttons */
-   rfbFillRect(rfbScreen,x1,y1,x2,y2,colour);
-   selPaintButtons(&selData,FALSE,FALSE);
-   selSelect(&selData,0);
-
-   /* modal loop */
-   while(selData.state == SELECTING)
-     rfbProcessEvents(rfbScreen,20000);
-
-   /* copy back screen data */
-   for(j=0;j<y2-y1;j++)
-     memcpy(rfbScreen->frameBuffer+j*rfbScreen->paddedWidthInBytes+x1*bpp,
-	    frameBufferBackup+j*(x2-x1)*bpp,
-	    (x2-x1)*bpp);
-   free(frameBufferBackup);
-   rfbMarkRectAsModified(rfbScreen,x1,y1,x2,y2);
-   rfbScreen->screenData = screenDataBackup;
-   rfbScreen->kbdAddEvent = kbdAddEventBackup;
-   rfbScreen->ptrAddEvent = ptrAddEventBackup;
-   rfbScreen->getCursorPtr = getCursorPtrBackup;
-   rfbScreen->displayHook = displayHookBackup;
-
-   if(selData.state==CANCEL)
-     selData.selected=-1;
-   return(selData.selected);
-}
-
diff --git a/libvncserver/sockets.c b/libvncserver/sockets.c
deleted file mode 100644
index e54252d..0000000
--- a/libvncserver/sockets.c
+++ /dev/null
@@ -1,737 +0,0 @@
-/*
- * sockets.c - deal with TCP & UDP sockets.
- *
- * This code should be independent of any changes in the RFB protocol.  It just
- * deals with the X server scheduling stuff, calling rfbNewClientConnection and
- * rfbProcessClientMessage to actually deal with the protocol.  If a socket
- * needs to be closed for any reason then rfbCloseClient should be called, and
- * this in turn will call rfbClientConnectionGone.  To make an active
- * connection out, call rfbConnect - note that this does _not_ call
- * rfbNewClientConnection.
- *
- * This file is divided into two types of function.  Those beginning with
- * "rfb" are specific to sockets using the RFB protocol.  Those without the
- * "rfb" prefix are more general socket routines (which are used by the http
- * code).
- *
- * Thanks to Karl Hakimian for pointing out that some platforms return EAGAIN
- * not EWOULDBLOCK.
- */
-
-/*
- *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netdb.h>
-#include <arpa/inet.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-#if defined(__linux__) && defined(NEED_TIMEVAL)
-struct timeval 
-{
-   long int tv_sec,tv_usec;
-}
-;
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_FCNTL_H
-#include <fcntl.h>
-#endif
-
-#include <errno.h>
-
-#ifdef USE_LIBWRAP
-#include <syslog.h>
-#include <tcpd.h>
-int allow_severity=LOG_INFO;
-int deny_severity=LOG_WARNING;
-#endif
-
-#if defined(WIN32)
-#ifndef __MINGW32__
-#pragma warning (disable: 4018 4761)
-#endif
-#define read(sock,buf,len) recv(sock,buf,len,0)
-#define EWOULDBLOCK WSAEWOULDBLOCK
-#define ETIMEDOUT WSAETIMEDOUT
-#define write(sock,buf,len) send(sock,buf,len,0)
-#else
-#define closesocket close
-#endif
-
-int rfbMaxClientWait = 20000;   /* time (ms) after which we decide client has
-                                   gone away - needed to stop us hanging */
-
-/*
- * rfbInitSockets sets up the TCP and UDP sockets to listen for RFB
- * connections.  It does nothing if called again.
- */
-
-void
-rfbInitSockets(rfbScreenInfoPtr rfbScreen)
-{
-    in_addr_t iface = rfbScreen->listenInterface;
-
-    if (rfbScreen->socketState!=RFB_SOCKET_INIT)
-	return;
-
-    rfbScreen->socketState = RFB_SOCKET_READY;
-
-    if (rfbScreen->inetdSock != -1) {
-	const int one = 1;
-
-        if(!rfbSetNonBlocking(rfbScreen->inetdSock))
-	    return;
-
-	if (setsockopt(rfbScreen->inetdSock, IPPROTO_TCP, TCP_NODELAY,
-		       (char *)&one, sizeof(one)) < 0) {
-	    rfbLogPerror("setsockopt");
-	    return;
-	}
-
-    	FD_ZERO(&(rfbScreen->allFds));
-    	FD_SET(rfbScreen->inetdSock, &(rfbScreen->allFds));
-    	rfbScreen->maxFd = rfbScreen->inetdSock;
-	return;
-    }
-
-    if(rfbScreen->autoPort) {
-        int i;
-        rfbLog("Autoprobing TCP port \n");
-        for (i = 5900; i < 6000; i++) {
-            if ((rfbScreen->listenSock = rfbListenOnTCPPort(i, iface)) >= 0) {
-		rfbScreen->port = i;
-		break;
-	    }
-        }
-
-        if (i >= 6000) {
-	    rfbLogPerror("Failure autoprobing");
-	    return;
-        }
-
-        rfbLog("Autoprobing selected port %d\n", rfbScreen->port);
-        FD_ZERO(&(rfbScreen->allFds));
-        FD_SET(rfbScreen->listenSock, &(rfbScreen->allFds));
-        rfbScreen->maxFd = rfbScreen->listenSock;
-    }
-    else if(rfbScreen->port>0) {
-      rfbLog("Listening for VNC connections on TCP port %d\n", rfbScreen->port);
-
-      if ((rfbScreen->listenSock = rfbListenOnTCPPort(rfbScreen->port, iface)) < 0) {
-	rfbLogPerror("ListenOnTCPPort");
-	return;
-      }
-
-      FD_ZERO(&(rfbScreen->allFds));
-      FD_SET(rfbScreen->listenSock, &(rfbScreen->allFds));
-      rfbScreen->maxFd = rfbScreen->listenSock;
-    }
-
-    if (rfbScreen->udpPort != 0) {
-	rfbLog("rfbInitSockets: listening for input on UDP port %d\n",rfbScreen->udpPort);
-
-	if ((rfbScreen->udpSock = rfbListenOnUDPPort(rfbScreen->udpPort, iface)) < 0) {
-	    rfbLogPerror("ListenOnUDPPort");
-	    return;
-	}
-	FD_SET(rfbScreen->udpSock, &(rfbScreen->allFds));
-	rfbScreen->maxFd = max((int)rfbScreen->udpSock,rfbScreen->maxFd);
-    }
-}
-
-void rfbShutdownSockets(rfbScreenInfoPtr rfbScreen)
-{
-    if (rfbScreen->socketState!=RFB_SOCKET_READY)
-	return;
-
-    rfbScreen->socketState = RFB_SOCKET_SHUTDOWN;
-
-    if(rfbScreen->inetdSock>-1) {
-	closesocket(rfbScreen->inetdSock);
-	FD_CLR(rfbScreen->inetdSock,&rfbScreen->allFds);
-	rfbScreen->inetdSock=-1;
-    }
-
-    if(rfbScreen->listenSock>-1) {
-	closesocket(rfbScreen->listenSock);
-	FD_CLR(rfbScreen->listenSock,&rfbScreen->allFds);
-	rfbScreen->listenSock=-1;
-    }
-
-    if(rfbScreen->udpSock>-1) {
-	closesocket(rfbScreen->udpSock);
-	FD_CLR(rfbScreen->udpSock,&rfbScreen->allFds);
-	rfbScreen->udpSock=-1;
-    }
-}
-
-/*
- * rfbCheckFds is called from ProcessInputEvents to check for input on the RFB
- * socket(s).  If there is input to process, the appropriate function in the
- * RFB server code will be called (rfbNewClientConnection,
- * rfbProcessClientMessage, etc).
- */
-
-int
-rfbCheckFds(rfbScreenInfoPtr rfbScreen,long usec)
-{
-    int nfds;
-    fd_set fds;
-    struct timeval tv;
-    struct sockaddr_in addr;
-    socklen_t addrlen = sizeof(addr);
-    char buf[6];
-    rfbClientIteratorPtr i;
-    rfbClientPtr cl;
-    int result = 0;
-
-    if (!rfbScreen->inetdInitDone && rfbScreen->inetdSock != -1) {
-	rfbNewClientConnection(rfbScreen,rfbScreen->inetdSock); 
-	rfbScreen->inetdInitDone = TRUE;
-    }
-
-    do {
-	memcpy((char *)&fds, (char *)&(rfbScreen->allFds), sizeof(fd_set));
-	tv.tv_sec = 0;
-	tv.tv_usec = usec;
-	nfds = select(rfbScreen->maxFd + 1, &fds, NULL, NULL /* &fds */, &tv);
-	if (nfds == 0) {
-	    /* timed out, check for async events */
-            i = rfbGetClientIterator(rfbScreen);
-            while((cl = rfbClientIteratorNext(i))) {
-                if (cl->onHold)
-                    continue;
-                if (FD_ISSET(cl->sock, &(rfbScreen->allFds)))
-                    rfbSendFileTransferChunk(cl);
-            }
-            rfbReleaseClientIterator(i);
-	    return result;
-	}
-
-	if (nfds < 0) {
-#ifdef WIN32
-	    errno = WSAGetLastError();
-#endif
-	    if (errno != EINTR)
-		rfbLogPerror("rfbCheckFds: select");
-	    return -1;
-	}
-
-	result += nfds;
-
-	if (rfbScreen->listenSock != -1 && FD_ISSET(rfbScreen->listenSock, &fds)) {
-
-	    if (!rfbProcessNewConnection(rfbScreen))
-                return -1;
-
-	    FD_CLR(rfbScreen->listenSock, &fds);
-	    if (--nfds == 0)
-		return result;
-	}
-
-	if ((rfbScreen->udpSock != -1) && FD_ISSET(rfbScreen->udpSock, &fds)) {
-	    if(!rfbScreen->udpClient)
-		rfbNewUDPClient(rfbScreen);
-	    if (recvfrom(rfbScreen->udpSock, buf, 1, MSG_PEEK,
-			(struct sockaddr *)&addr, &addrlen) < 0) {
-		rfbLogPerror("rfbCheckFds: UDP: recvfrom");
-		rfbDisconnectUDPSock(rfbScreen);
-		rfbScreen->udpSockConnected = FALSE;
-	    } else {
-		if (!rfbScreen->udpSockConnected ||
-			(memcmp(&addr, &rfbScreen->udpRemoteAddr, addrlen) != 0))
-		{
-		    /* new remote end */
-		    rfbLog("rfbCheckFds: UDP: got connection\n");
-
-		    memcpy(&rfbScreen->udpRemoteAddr, &addr, addrlen);
-		    rfbScreen->udpSockConnected = TRUE;
-
-		    if (connect(rfbScreen->udpSock,
-				(struct sockaddr *)&addr, addrlen) < 0) {
-			rfbLogPerror("rfbCheckFds: UDP: connect");
-			rfbDisconnectUDPSock(rfbScreen);
-			return -1;
-		    }
-
-		    rfbNewUDPConnection(rfbScreen,rfbScreen->udpSock);
-		}
-
-		rfbProcessUDPInput(rfbScreen);
-	    }
-
-	    FD_CLR(rfbScreen->udpSock, &fds);
-	    if (--nfds == 0)
-		return result;
-	}
-
-	i = rfbGetClientIterator(rfbScreen);
-	while((cl = rfbClientIteratorNext(i))) {
-
-	    if (cl->onHold)
-		continue;
-
-            if (FD_ISSET(cl->sock, &(rfbScreen->allFds)))
-            {
-                if (FD_ISSET(cl->sock, &fds))
-                    rfbProcessClientMessage(cl);
-                else
-                    rfbSendFileTransferChunk(cl);
-            }
-	}
-	rfbReleaseClientIterator(i);
-    } while(rfbScreen->handleEventsEagerly);
-    return result;
-}
-
-rfbBool
-rfbProcessNewConnection(rfbScreenInfoPtr rfbScreen)
-{
-    const int one = 1;
-    int sock = -1;
-    struct sockaddr_in addr;
-    socklen_t addrlen = sizeof(addr);
-
-    if ((sock = accept(rfbScreen->listenSock,
-		       (struct sockaddr *)&addr, &addrlen)) < 0) {
-      rfbLogPerror("rfbCheckFds: accept");
-      return FALSE;
-    }
-
-    if(!rfbSetNonBlocking(sock)) {
-      closesocket(sock);
-      return FALSE;
-    }
-
-    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
-		   (char *)&one, sizeof(one)) < 0) {
-      rfbLogPerror("rfbCheckFds: setsockopt");
-      closesocket(sock);
-      return FALSE;
-    }
-
-#ifdef USE_LIBWRAP
-    if(!hosts_ctl("vnc",STRING_UNKNOWN,inet_ntoa(addr.sin_addr),
-		  STRING_UNKNOWN)) {
-      rfbLog("Rejected connection from client %s\n",
-	     inet_ntoa(addr.sin_addr));
-      closesocket(sock);
-      return FALSE;
-    }
-#endif
-
-    rfbLog("Got connection from client %s\n", inet_ntoa(addr.sin_addr));
-
-    rfbNewClient(rfbScreen,sock);
-
-    return TRUE;
-}
-
-
-void
-rfbDisconnectUDPSock(rfbScreenInfoPtr rfbScreen)
-{
-  rfbScreen->udpSockConnected = FALSE;
-}
-
-
-
-void
-rfbCloseClient(rfbClientPtr cl)
-{
-    rfbExtensionData* extension;
-
-    for(extension=cl->extensions; extension; extension=extension->next)
-	if(extension->extension->close)
-	    extension->extension->close(cl, extension->data);
-
-    LOCK(cl->updateMutex);
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    if (cl->sock != -1)
-#endif
-      {
-	FD_CLR(cl->sock,&(cl->screen->allFds));
-	if(cl->sock==cl->screen->maxFd)
-	  while(cl->screen->maxFd>0
-		&& !FD_ISSET(cl->screen->maxFd,&(cl->screen->allFds)))
-	    cl->screen->maxFd--;
-#ifndef __MINGW32__
-	shutdown(cl->sock,SHUT_RDWR);
-#endif
-	closesocket(cl->sock);
-	cl->sock = -1;
-      }
-    TSIGNAL(cl->updateCond);
-    UNLOCK(cl->updateMutex);
-}
-
-
-/*
- * rfbConnect is called to make a connection out to a given TCP address.
- */
-
-int
-rfbConnect(rfbScreenInfoPtr rfbScreen,
-           char *host,
-           int port)
-{
-    int sock;
-    int one = 1;
-
-    rfbLog("Making connection to client on host %s port %d\n",
-	   host,port);
-
-    if ((sock = rfbConnectToTcpAddr(host, port)) < 0) {
-	rfbLogPerror("connection failed");
-	return -1;
-    }
-
-    if(!rfbSetNonBlocking(sock)) {
-        closesocket(sock);
-	return -1;
-    }
-
-    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
-		   (char *)&one, sizeof(one)) < 0) {
-	rfbLogPerror("setsockopt failed");
-	closesocket(sock);
-	return -1;
-    }
-
-    /* AddEnabledDevice(sock); */
-    FD_SET(sock, &rfbScreen->allFds);
-    rfbScreen->maxFd = max(sock,rfbScreen->maxFd);
-
-    return sock;
-}
-
-/*
- * ReadExact reads an exact number of bytes from a client.  Returns 1 if
- * those bytes have been read, 0 if the other end has closed, or -1 if an error
- * occurred (errno is set to ETIMEDOUT if it timed out).
- */
-
-int
-rfbReadExactTimeout(rfbClientPtr cl, char* buf, int len, int timeout)
-{
-    int sock = cl->sock;
-    int n;
-    fd_set fds;
-    struct timeval tv;
-
-    while (len > 0) {
-        n = read(sock, buf, len);
-
-        if (n > 0) {
-
-            buf += n;
-            len -= n;
-
-        } else if (n == 0) {
-
-            return 0;
-
-        } else {
-#ifdef WIN32
-	    errno = WSAGetLastError();
-#endif
-	    if (errno == EINTR)
-		continue;
-
-#ifdef LIBVNCSERVER_ENOENT_WORKAROUND
-	    if (errno != ENOENT)
-#endif
-            if (errno != EWOULDBLOCK && errno != EAGAIN) {
-                return n;
-            }
-
-            FD_ZERO(&fds);
-            FD_SET(sock, &fds);
-            tv.tv_sec = timeout / 1000;
-            tv.tv_usec = (timeout % 1000) * 1000;
-            n = select(sock+1, &fds, NULL, &fds, &tv);
-            if (n < 0) {
-                rfbLogPerror("ReadExact: select");
-                return n;
-            }
-            if (n == 0) {
-                errno = ETIMEDOUT;
-                return -1;
-            }
-        }
-    }
-#undef DEBUG_READ_EXACT
-#ifdef DEBUG_READ_EXACT
-    rfbLog("ReadExact %d bytes\n",len);
-    for(n=0;n<len;n++)
-	    fprintf(stderr,"%02x ",(unsigned char)buf[n]);
-    fprintf(stderr,"\n");
-#endif
-
-    return 1;
-}
-
-int rfbReadExact(rfbClientPtr cl,char* buf,int len)
-{
-  /* favor the per-screen value if set */
-  if(cl->screen && cl->screen->maxClientWait)
-    return(rfbReadExactTimeout(cl,buf,len,cl->screen->maxClientWait));
-  else
-    return(rfbReadExactTimeout(cl,buf,len,rfbMaxClientWait));
-}
-
-/*
- * WriteExact writes an exact number of bytes to a client.  Returns 1 if
- * those bytes have been written, or -1 if an error occurred (errno is set to
- * ETIMEDOUT if it timed out).
- */
-
-int
-rfbWriteExact(rfbClientPtr cl,
-              const char *buf,
-              int len)
-{
-    int sock = cl->sock;
-    int n;
-    fd_set fds;
-    struct timeval tv;
-    int totalTimeWaited = 0;
-    const int timeout = (cl->screen && cl->screen->maxClientWait) ? cl->screen->maxClientWait : rfbMaxClientWait;
-
-#undef DEBUG_WRITE_EXACT
-#ifdef DEBUG_WRITE_EXACT
-    rfbLog("WriteExact %d bytes\n",len);
-    for(n=0;n<len;n++)
-	    fprintf(stderr,"%02x ",(unsigned char)buf[n]);
-    fprintf(stderr,"\n");
-#endif
-
-    LOCK(cl->outputMutex);
-    while (len > 0) {
-        n = write(sock, buf, len);
-
-        if (n > 0) {
-
-            buf += n;
-            len -= n;
-
-        } else if (n == 0) {
-
-            rfbErr("WriteExact: write returned 0?\n");
-            return 0;
-
-        } else {
-#ifdef WIN32
-			errno = WSAGetLastError();
-#endif
-	    if (errno == EINTR)
-		continue;
-
-            if (errno != EWOULDBLOCK && errno != EAGAIN) {
-	        UNLOCK(cl->outputMutex);
-                return n;
-            }
-
-            /* Retry every 5 seconds until we exceed timeout.  We
-               need to do this because select doesn't necessarily return
-               immediately when the other end has gone away */
-
-            FD_ZERO(&fds);
-            FD_SET(sock, &fds);
-            tv.tv_sec = 5;
-            tv.tv_usec = 0;
-            n = select(sock+1, NULL, &fds, NULL /* &fds */, &tv);
-	    if (n < 0) {
-#ifdef WIN32
-                errno=WSAGetLastError();
-#endif
-       	        if(errno==EINTR)
-		    continue;
-                rfbLogPerror("WriteExact: select");
-                UNLOCK(cl->outputMutex);
-                return n;
-            }
-            if (n == 0) {
-                totalTimeWaited += 5000;
-                if (totalTimeWaited >= timeout) {
-                    errno = ETIMEDOUT;
-                    UNLOCK(cl->outputMutex);
-                    return -1;
-                }
-            } else {
-                totalTimeWaited = 0;
-            }
-        }
-    }
-    UNLOCK(cl->outputMutex);
-    return 1;
-}
-
-/* currently private, called by rfbProcessArguments() */
-int
-rfbStringToAddr(char *str, in_addr_t *addr)  {
-    if (str == NULL || *str == '\0' || strcmp(str, "any") == 0) {
-        *addr = htonl(INADDR_ANY);
-    } else if (strcmp(str, "localhost") == 0) {
-        *addr = htonl(INADDR_LOOPBACK);
-    } else {
-        struct hostent *hp;
-        if ((*addr = inet_addr(str)) == htonl(INADDR_NONE)) {
-            if (!(hp = gethostbyname(str))) {
-                return 0;
-            }
-            *addr = *(unsigned long *)hp->h_addr;
-        }
-    }
-    return 1;
-}
-
-int
-rfbListenOnTCPPort(int port,
-                   in_addr_t iface)
-{
-    struct sockaddr_in addr;
-    int sock;
-    int one = 1;
-
-    memset(&addr, 0, sizeof(addr));
-    addr.sin_family = AF_INET;
-    addr.sin_port = htons(port);
-    addr.sin_addr.s_addr = iface;
-
-    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
-	return -1;
-    }
-    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
-		   (char *)&one, sizeof(one)) < 0) {
-	closesocket(sock);
-	return -1;
-    }
-    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
-	closesocket(sock);
-	return -1;
-    }
-    if (listen(sock, 32) < 0) {
-	closesocket(sock);
-	return -1;
-    }
-
-    return sock;
-}
-
-int
-rfbConnectToTcpAddr(char *host,
-                    int port)
-{
-    struct hostent *hp;
-    int sock;
-    struct sockaddr_in addr;
-
-    memset(&addr, 0, sizeof(addr));
-    addr.sin_family = AF_INET;
-    addr.sin_port = htons(port);
-
-    if ((addr.sin_addr.s_addr = inet_addr(host)) == htonl(INADDR_NONE))
-    {
-	if (!(hp = gethostbyname(host))) {
-	    errno = EINVAL;
-	    return -1;
-	}
-	addr.sin_addr.s_addr = *(unsigned long *)hp->h_addr;
-    }
-
-    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
-	return -1;
-    }
-
-    if (connect(sock, (struct sockaddr *)&addr, (sizeof(addr))) < 0) {
-	closesocket(sock);
-	return -1;
-    }
-
-    return sock;
-}
-
-int
-rfbListenOnUDPPort(int port,
-                   in_addr_t iface)
-{
-    struct sockaddr_in addr;
-    int sock;
-    int one = 1;
-
-    memset(&addr, 0, sizeof(addr));
-    addr.sin_family = AF_INET;
-    addr.sin_port = htons(port);
-    addr.sin_addr.s_addr = iface;
-
-    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
-	return -1;
-    }
-    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
-		   (char *)&one, sizeof(one)) < 0) {
-	return -1;
-    }
-    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
-	return -1;
-    }
-
-    return sock;
-}
-
-/*
- * rfbSetNonBlocking sets a socket into non-blocking mode.
- */
-rfbBool
-rfbSetNonBlocking(int sock)
-{
-#ifdef WIN32
-  unsigned long block=1;
-  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {
-    errno=WSAGetLastError();
-#else
-  int flags = fcntl(sock, F_GETFL);
-  if(flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
-#endif
-    rfbLogPerror("Setting socket to non-blocking failed");
-    return FALSE;
-  }
-  return TRUE;
-}
diff --git a/libvncserver/stats.c b/libvncserver/stats.c
deleted file mode 100644
index c8261d5..0000000
--- a/libvncserver/stats.c
+++ /dev/null
@@ -1,478 +0,0 @@
-/*
- * stats.c
- */
-
-/*
- *  Copyright (C) 2002 RealVNC Ltd.
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-
-char *messageNameServer2Client(uint32_t type, char *buf, int len);
-char *messageNameClient2Server(uint32_t type, char *buf, int len);
-char *encodingName(uint32_t enc, char *buf, int len);
-
-rfbStatList *rfbStatLookupEncoding(rfbClientPtr cl, uint32_t type);
-rfbStatList *rfbStatLookupMessage(rfbClientPtr cl, uint32_t type);
-
-void  rfbStatRecordEncodingSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-void  rfbStatRecordEncodingRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-void  rfbStatRecordMessageSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-void  rfbStatRecordMessageRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-void rfbResetStats(rfbClientPtr cl);
-void rfbPrintStats(rfbClientPtr cl);
-
-
-
-
-char *messageNameServer2Client(uint32_t type, char *buf, int len) {
-    if (buf==NULL) return "error";
-    switch (type) {
-    case rfbFramebufferUpdate:        snprintf(buf, len, "FramebufferUpdate"); break;
-    case rfbSetColourMapEntries:      snprintf(buf, len, "SetColourMapEntries"); break;
-    case rfbBell:                     snprintf(buf, len, "Bell"); break;
-    case rfbServerCutText:            snprintf(buf, len, "ServerCutText"); break;
-    case rfbResizeFrameBuffer:        snprintf(buf, len, "ResizeFrameBuffer"); break;
-    case rfbFileTransfer:             snprintf(buf, len, "FileTransfer"); break;
-    case rfbTextChat:                 snprintf(buf, len, "TextChat"); break;
-    case rfbPalmVNCReSizeFrameBuffer: snprintf(buf, len, "PalmVNCReSize"); break;
-    case rfbXvp:                      snprintf(buf, len, "XvpServerMessage"); break;
-    default:
-        snprintf(buf, len, "svr2cli-0x%08X", 0xFF);
-    }
-    return buf;
-}
-
-char *messageNameClient2Server(uint32_t type, char *buf, int len) {
-    if (buf==NULL) return "error";
-    switch (type) {
-    case rfbSetPixelFormat:           snprintf(buf, len, "SetPixelFormat"); break;
-    case rfbFixColourMapEntries:      snprintf(buf, len, "FixColourMapEntries"); break;
-    case rfbSetEncodings:             snprintf(buf, len, "SetEncodings"); break;
-    case rfbFramebufferUpdateRequest: snprintf(buf, len, "FramebufferUpdate"); break;
-    case rfbKeyEvent:                 snprintf(buf, len, "KeyEvent"); break;
-    case rfbPointerEvent:             snprintf(buf, len, "PointerEvent"); break;
-    case rfbClientCutText:            snprintf(buf, len, "ClientCutText"); break;
-    case rfbFileTransfer:             snprintf(buf, len, "FileTransfer"); break;
-    case rfbSetScale:                 snprintf(buf, len, "SetScale"); break;
-    case rfbSetServerInput:           snprintf(buf, len, "SetServerInput"); break;
-    case rfbSetSW:                    snprintf(buf, len, "SetSingleWindow"); break;
-    case rfbTextChat:                 snprintf(buf, len, "TextChat"); break;
-    case rfbPalmVNCSetScaleFactor:    snprintf(buf, len, "PalmVNCSetScale"); break;
-    case rfbXvp:                      snprintf(buf, len, "XvpClientMessage"); break;
-    default:
-        snprintf(buf, len, "cli2svr-0x%08X", type);
-
-
-    }
-    return buf;
-}
-
-/* Encoding name must be <=16 characters to fit nicely on the status output in
- * an 80 column terminal window
- */
-char *encodingName(uint32_t type, char *buf, int len) {
-    if (buf==NULL) return "error";
-    
-    switch (type) {
-    case rfbEncodingRaw:                snprintf(buf, len, "raw");         break;
-    case rfbEncodingCopyRect:           snprintf(buf, len, "copyRect");    break;
-    case rfbEncodingRRE:                snprintf(buf, len, "RRE");         break;
-    case rfbEncodingCoRRE:              snprintf(buf, len, "CoRRE");       break;
-    case rfbEncodingHextile:            snprintf(buf, len, "hextile");     break;
-    case rfbEncodingZlib:               snprintf(buf, len, "zlib");        break;
-    case rfbEncodingTight:              snprintf(buf, len, "tight");       break;
-    case rfbEncodingZlibHex:            snprintf(buf, len, "zlibhex");     break;
-    case rfbEncodingUltra:              snprintf(buf, len, "ultra");       break;
-    case rfbEncodingZRLE:               snprintf(buf, len, "ZRLE");        break;
-    case rfbEncodingZYWRLE:             snprintf(buf, len, "ZYWRLE");      break;
-    case rfbEncodingCache:              snprintf(buf, len, "cache");       break;
-    case rfbEncodingCacheEnable:        snprintf(buf, len, "cacheEnable"); break;
-    case rfbEncodingXOR_Zlib:           snprintf(buf, len, "xorZlib");     break;
-    case rfbEncodingXORMonoColor_Zlib:  snprintf(buf, len, "xorMonoZlib");  break;
-    case rfbEncodingXORMultiColor_Zlib: snprintf(buf, len, "xorColorZlib"); break;
-    case rfbEncodingSolidColor:         snprintf(buf, len, "solidColor");  break;
-    case rfbEncodingXOREnable:          snprintf(buf, len, "xorEnable");   break;
-    case rfbEncodingCacheZip:           snprintf(buf, len, "cacheZip");    break;
-    case rfbEncodingSolMonoZip:         snprintf(buf, len, "monoZip");     break;
-    case rfbEncodingUltraZip:           snprintf(buf, len, "ultraZip");    break;
-
-    case rfbEncodingXCursor:            snprintf(buf, len, "Xcursor");     break;
-    case rfbEncodingRichCursor:         snprintf(buf, len, "RichCursor");  break;
-    case rfbEncodingPointerPos:         snprintf(buf, len, "PointerPos");  break;
-
-    case rfbEncodingLastRect:           snprintf(buf, len, "LastRect");    break;
-    case rfbEncodingNewFBSize:          snprintf(buf, len, "NewFBSize");   break;
-    case rfbEncodingKeyboardLedState:   snprintf(buf, len, "LedState");    break;
-    case rfbEncodingSupportedMessages:  snprintf(buf, len, "SupportedMessage");  break;
-    case rfbEncodingSupportedEncodings: snprintf(buf, len, "SupportedEncoding"); break;
-    case rfbEncodingServerIdentity:     snprintf(buf, len, "ServerIdentify");    break;
-
-    /* The following lookups do not report in stats */
-    case rfbEncodingCompressLevel0: snprintf(buf, len, "CompressLevel0");  break;
-    case rfbEncodingCompressLevel1: snprintf(buf, len, "CompressLevel1");  break;
-    case rfbEncodingCompressLevel2: snprintf(buf, len, "CompressLevel2");  break;
-    case rfbEncodingCompressLevel3: snprintf(buf, len, "CompressLevel3");  break;
-    case rfbEncodingCompressLevel4: snprintf(buf, len, "CompressLevel4");  break;
-    case rfbEncodingCompressLevel5: snprintf(buf, len, "CompressLevel5");  break;
-    case rfbEncodingCompressLevel6: snprintf(buf, len, "CompressLevel6");  break;
-    case rfbEncodingCompressLevel7: snprintf(buf, len, "CompressLevel7");  break;
-    case rfbEncodingCompressLevel8: snprintf(buf, len, "CompressLevel8");  break;
-    case rfbEncodingCompressLevel9: snprintf(buf, len, "CompressLevel9");  break;
-    
-    case rfbEncodingQualityLevel0:  snprintf(buf, len, "QualityLevel0");   break;
-    case rfbEncodingQualityLevel1:  snprintf(buf, len, "QualityLevel1");   break;
-    case rfbEncodingQualityLevel2:  snprintf(buf, len, "QualityLevel2");   break;
-    case rfbEncodingQualityLevel3:  snprintf(buf, len, "QualityLevel3");   break;
-    case rfbEncodingQualityLevel4:  snprintf(buf, len, "QualityLevel4");   break;
-    case rfbEncodingQualityLevel5:  snprintf(buf, len, "QualityLevel5");   break;
-    case rfbEncodingQualityLevel6:  snprintf(buf, len, "QualityLevel6");   break;
-    case rfbEncodingQualityLevel7:  snprintf(buf, len, "QualityLevel7");   break;
-    case rfbEncodingQualityLevel8:  snprintf(buf, len, "QualityLevel8");   break;
-    case rfbEncodingQualityLevel9:  snprintf(buf, len, "QualityLevel9");   break;
-
-
-    default:
-        snprintf(buf, len, "Enc(0x%08X)", type);
-    }
-
-    return buf;
-}
-
-
-
-
-
-rfbStatList *rfbStatLookupEncoding(rfbClientPtr cl, uint32_t type)
-{
-    rfbStatList *ptr;
-    if (cl==NULL) return NULL;
-    for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-    {
-        if (ptr->type==type) return ptr;
-    }
-    /* Well, we are here... need to *CREATE* an entry */
-    ptr = (rfbStatList *)malloc(sizeof(rfbStatList));
-    if (ptr!=NULL)
-    {
-        memset((char *)ptr, 0, sizeof(rfbStatList));
-        ptr->type = type;
-        /* add to the top of the list */
-        ptr->Next = cl->statEncList;
-        cl->statEncList = ptr;
-    }
-    return ptr;
-}
-
-
-rfbStatList *rfbStatLookupMessage(rfbClientPtr cl, uint32_t type)
-{
-    rfbStatList *ptr;
-    if (cl==NULL) return NULL;
-    for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-    {
-        if (ptr->type==type) return ptr;
-    }
-    /* Well, we are here... need to *CREATE* an entry */
-    ptr = (rfbStatList *)malloc(sizeof(rfbStatList));
-    if (ptr!=NULL)
-    {
-        memset((char *)ptr, 0, sizeof(rfbStatList));
-        ptr->type = type;
-        /* add to the top of the list */
-        ptr->Next = cl->statMsgList;
-        cl->statMsgList = ptr;
-    }
-    return ptr;
-}
-
-void rfbStatRecordEncodingSentAdd(rfbClientPtr cl, uint32_t type, int byteCount) /* Specifically for tight encoding */
-{
-    rfbStatList *ptr;
-
-    ptr = rfbStatLookupEncoding(cl, type);
-    if (ptr!=NULL)
-        ptr->bytesSent      += byteCount;
-}
-
-
-void  rfbStatRecordEncodingSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw)
-{
-    rfbStatList *ptr;
-
-    ptr = rfbStatLookupEncoding(cl, type);
-    if (ptr!=NULL)
-    {
-        ptr->sentCount++;
-        ptr->bytesSent      += byteCount;
-        ptr->bytesSentIfRaw += byteIfRaw;
-    }
-}
-
-void  rfbStatRecordEncodingRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw)
-{
-    rfbStatList *ptr;
-
-    ptr = rfbStatLookupEncoding(cl, type);
-    if (ptr!=NULL)
-    {
-        ptr->rcvdCount++;
-        ptr->bytesRcvd      += byteCount;
-        ptr->bytesRcvdIfRaw += byteIfRaw;
-    }
-}
-
-void  rfbStatRecordMessageSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw)
-{
-    rfbStatList *ptr;
-
-    ptr = rfbStatLookupMessage(cl, type);
-    if (ptr!=NULL)
-    {
-        ptr->sentCount++;
-        ptr->bytesSent      += byteCount;
-        ptr->bytesSentIfRaw += byteIfRaw;
-    }
-}
-
-void  rfbStatRecordMessageRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw)
-{
-    rfbStatList *ptr;
-
-    ptr = rfbStatLookupMessage(cl, type);
-    if (ptr!=NULL)
-    {
-        ptr->rcvdCount++;
-        ptr->bytesRcvd      += byteCount;
-        ptr->bytesRcvdIfRaw += byteIfRaw;
-    }
-}
-
-
-int rfbStatGetSentBytes(rfbClientPtr cl)
-{
-    rfbStatList *ptr=NULL;
-    int bytes=0;
-    if (cl==NULL) return 0;
-    for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesSent;
-    for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesSent;
-    return bytes;
-}
-
-int rfbStatGetSentBytesIfRaw(rfbClientPtr cl)
-{
-    rfbStatList *ptr=NULL;
-    int bytes=0;
-    if (cl==NULL) return 0;
-    for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesSentIfRaw;
-    for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesSentIfRaw;
-    return bytes;
-}
-
-int rfbStatGetRcvdBytes(rfbClientPtr cl)
-{
-    rfbStatList *ptr=NULL;
-    int bytes=0;
-    if (cl==NULL) return 0;
-    for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesRcvd;
-    for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesRcvd;
-    return bytes;
-}
-
-int rfbStatGetRcvdBytesIfRaw(rfbClientPtr cl)
-{
-    rfbStatList *ptr=NULL;
-    int bytes=0;
-    if (cl==NULL) return 0;
-    for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesRcvdIfRaw;
-    for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-        bytes += ptr->bytesRcvdIfRaw;
-    return bytes;
-}
-
-int rfbStatGetMessageCountSent(rfbClientPtr cl, uint32_t type)
-{
-  rfbStatList *ptr=NULL;
-    if (cl==NULL) return 0;
-  for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-      if (ptr->type==type) return ptr->sentCount;
-  return 0;
-}
-int rfbStatGetMessageCountRcvd(rfbClientPtr cl, uint32_t type)
-{
-  rfbStatList *ptr=NULL;
-    if (cl==NULL) return 0;
-  for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-      if (ptr->type==type) return ptr->rcvdCount;
-  return 0;
-}
-
-int rfbStatGetEncodingCountSent(rfbClientPtr cl, uint32_t type)
-{
-  rfbStatList *ptr=NULL;
-    if (cl==NULL) return 0;
-  for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-      if (ptr->type==type) return ptr->sentCount;
-  return 0;
-}
-int rfbStatGetEncodingCountRcvd(rfbClientPtr cl, uint32_t type)
-{
-  rfbStatList *ptr=NULL;
-    if (cl==NULL) return 0;
-  for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-      if (ptr->type==type) return ptr->rcvdCount;
-  return 0;
-}
-
-
-
-
-void rfbResetStats(rfbClientPtr cl)
-{
-    rfbStatList *ptr;
-    if (cl==NULL) return;
-    while (cl->statEncList!=NULL)
-    {
-        ptr = cl->statEncList;
-        cl->statEncList = ptr->Next;
-        free(ptr);
-    }
-    while (cl->statMsgList!=NULL)
-    {
-        ptr = cl->statMsgList;
-        cl->statMsgList = ptr->Next;
-        free(ptr);
-    }
-}
-
-
-void rfbPrintStats(rfbClientPtr cl)
-{
-    rfbStatList *ptr=NULL;
-    char encBuf[64];
-    double savings=0.0;
-    int    totalRects=0;
-    double totalBytes=0.0;
-    double totalBytesIfRaw=0.0;
-
-    char *name=NULL;
-    int bytes=0;
-    int bytesIfRaw=0;
-    int count=0;
-
-    if (cl==NULL) return;
-    
-    rfbLog("%-21.21s  %-6.6s   %9.9s/%9.9s (%6.6s)\n", "Statistics", "events", "Transmit","RawEquiv","saved");
-    for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-    {
-        name       = messageNameServer2Client(ptr->type, encBuf, sizeof(encBuf));
-        count      = ptr->sentCount;
-        bytes      = ptr->bytesSent;
-        bytesIfRaw = ptr->bytesSentIfRaw;
-        
-        savings = 0.0;
-        if (bytesIfRaw>0.0)
-            savings = 100.0 - (((double)bytes / (double)bytesIfRaw) * 100.0);
-        if ((bytes>0) || (count>0) || (bytesIfRaw>0))
-            rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n",
-	        name, count, bytes, bytesIfRaw, savings);
-        totalRects += count;
-        totalBytes += bytes;
-        totalBytesIfRaw += bytesIfRaw;
-    }
-
-    for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-    {
-        name       = encodingName(ptr->type, encBuf, sizeof(encBuf));
-        count      = ptr->sentCount;
-        bytes      = ptr->bytesSent;
-        bytesIfRaw = ptr->bytesSentIfRaw;
-        savings    = 0.0;
-
-        if (bytesIfRaw>0.0)
-            savings = 100.0 - (((double)bytes / (double)bytesIfRaw) * 100.0);
-        if ((bytes>0) || (count>0) || (bytesIfRaw>0))
-            rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n",
-	        name, count, bytes, bytesIfRaw, savings);
-        totalRects += count;
-        totalBytes += bytes;
-        totalBytesIfRaw += bytesIfRaw;
-    }
-    savings=0.0;
-    if (totalBytesIfRaw>0.0)
-        savings = 100.0 - ((totalBytes/totalBytesIfRaw)*100.0);
-    rfbLog(" %-20.20s: %6d | %9.0f/%9.0f (%5.1f%%)\n",
-            "TOTALS", totalRects, totalBytes,totalBytesIfRaw, savings);
-
-    totalRects=0.0;
-    totalBytes=0.0;
-    totalBytesIfRaw=0.0;
-
-    rfbLog("%-21.21s  %-6.6s   %9.9s/%9.9s (%6.6s)\n", "Statistics", "events", "Received","RawEquiv","saved");
-    for (ptr = cl->statMsgList; ptr!=NULL; ptr=ptr->Next)
-    {
-        name       = messageNameClient2Server(ptr->type, encBuf, sizeof(encBuf));
-        count      = ptr->rcvdCount;
-        bytes      = ptr->bytesRcvd;
-        bytesIfRaw = ptr->bytesRcvdIfRaw;
-        savings    = 0.0;
-
-        if (bytesIfRaw>0.0)
-            savings = 100.0 - (((double)bytes / (double)bytesIfRaw) * 100.0);
-        if ((bytes>0) || (count>0) || (bytesIfRaw>0))
-            rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n",
-	        name, count, bytes, bytesIfRaw, savings);
-        totalRects += count;
-        totalBytes += bytes;
-        totalBytesIfRaw += bytesIfRaw;
-    }
-    for (ptr = cl->statEncList; ptr!=NULL; ptr=ptr->Next)
-    {
-        name       = encodingName(ptr->type, encBuf, sizeof(encBuf));
-        count      = ptr->rcvdCount;
-        bytes      = ptr->bytesRcvd;
-        bytesIfRaw = ptr->bytesRcvdIfRaw;
-        savings    = 0.0;
-
-        if (bytesIfRaw>0.0)
-            savings = 100.0 - (((double)bytes / (double)bytesIfRaw) * 100.0);
-        if ((bytes>0) || (count>0) || (bytesIfRaw>0))
-            rfbLog(" %-20.20s: %6d | %9d/%9d (%5.1f%%)\n",
-	        name, count, bytes, bytesIfRaw, savings);
-        totalRects += count;
-        totalBytes += bytes;
-        totalBytesIfRaw += bytesIfRaw;
-    }
-    savings=0.0;
-    if (totalBytesIfRaw>0.0)
-        savings = 100.0 - ((totalBytes/totalBytesIfRaw)*100.0);
-    rfbLog(" %-20.20s: %6d | %9.0f/%9.0f (%5.1f%%)\n",
-            "TOTALS", totalRects, totalBytes,totalBytesIfRaw, savings);
-      
-} 
-
diff --git a/libvncserver/tableinit24.c b/libvncserver/tableinit24.c
deleted file mode 100644
index 39e9920..0000000
--- a/libvncserver/tableinit24.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
-  24 bit
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-static void
-rfbInitOneRGBTable24 (uint8_t *table, int inMax, int outMax, int outShift,int swap);
-
-
-static void
-rfbInitColourMapSingleTable24(char **table, rfbPixelFormat *in,
-                            rfbPixelFormat *out,rfbColourMap* colourMap)
-{
-    uint32_t i, r, g, b, outValue;
-    uint8_t *t;
-    uint8_t c;
-    unsigned int nEntries = 1 << in->bitsPerPixel;
-    int shift = colourMap->is16?16:8;
-
-    if (*table) free(*table);
-    *table = (char *)malloc(nEntries * 3 + 1);
-    t = (uint8_t *)*table;
-
-    for (i = 0; i < nEntries; i++) {
-        r = g = b = 0;
-	if(i < colourMap->count) {
-	  if(colourMap->is16) {
-	    r = colourMap->data.shorts[3*i+0];
-	    g = colourMap->data.shorts[3*i+1];
-	    b = colourMap->data.shorts[3*i+2];
-	  } else {
-	    r = colourMap->data.bytes[3*i+0];
-	    g = colourMap->data.bytes[3*i+1];
-	    b = colourMap->data.bytes[3*i+2];
-	  }
-	}
-        outValue = ((((r * (1 + out->redMax)) >> shift) << out->redShift) |
-                (((g * (1 + out->greenMax)) >> shift) << out->greenShift) |
-                (((b * (1 + out->blueMax)) >> shift) << out->blueShift));
-	*(uint32_t*)&t[3*i] = outValue;
-	if(!rfbEndianTest)
-	  memmove(t+3*i,t+3*i+1,3);
-        if (out->bigEndian != in->bigEndian) {
-	  c = t[3*i]; t[3*i] = t[3*i+2]; t[3*i+2] = c;
-        }
-    }
-}
-
-/*
- * rfbInitTrueColourSingleTable sets up a single lookup table for truecolour
- * translation.
- */
-
-static void
-rfbInitTrueColourSingleTable24 (char **table, rfbPixelFormat *in,
-                                 rfbPixelFormat *out)
-{
-    int i,outValue;
-    int inRed, inGreen, inBlue, outRed, outGreen, outBlue;
-    uint8_t *t;
-    uint8_t c;
-    int nEntries = 1 << in->bitsPerPixel;
-
-    if (*table) free(*table);
-    *table = (char *)malloc(nEntries * 3 + 1);
-    t = (uint8_t *)*table;
-
-    for (i = 0; i < nEntries; i++) {
-        inRed   = (i >> in->redShift)   & in->redMax;
-        inGreen = (i >> in->greenShift) & in->greenMax;
-        inBlue  = (i >> in->blueShift)  & in->blueMax;
-
-        outRed   = (inRed   * out->redMax   + in->redMax / 2)   / in->redMax;
-        outGreen = (inGreen * out->greenMax + in->greenMax / 2) / in->greenMax;
-        outBlue  = (inBlue  * out->blueMax  + in->blueMax / 2)  / in->blueMax;
-
-	outValue = ((outRed   << out->redShift)   |
-                (outGreen << out->greenShift) |
-                (outBlue  << out->blueShift));
-	*(uint32_t*)&t[3*i] = outValue;
-	if(!rfbEndianTest)
-	  memmove(t+3*i,t+3*i+1,3);
-        if (out->bigEndian != in->bigEndian) {
-	  c = t[3*i]; t[3*i] = t[3*i+2]; t[3*i+2] = c;
-        }
-    }
-}
-
-
-/*
- * rfbInitTrueColourRGBTables sets up three separate lookup tables for the
- * red, green and blue values.
- */
-
-static void
-rfbInitTrueColourRGBTables24 (char **table, rfbPixelFormat *in,
-                               rfbPixelFormat *out)
-{
-    uint8_t *redTable;
-    uint8_t *greenTable;
-    uint8_t *blueTable;
-
-    if (*table) free(*table);
-    *table = (char *)malloc((in->redMax + in->greenMax + in->blueMax + 3)
-                            * 3 + 1);
-    redTable = (uint8_t *)*table;
-    greenTable = redTable + 3*(in->redMax + 1);
-    blueTable = greenTable + 3*(in->greenMax + 1);
-
-    rfbInitOneRGBTable24 (redTable, in->redMax, out->redMax,
-                           out->redShift, (out->bigEndian != in->bigEndian));
-    rfbInitOneRGBTable24 (greenTable, in->greenMax, out->greenMax,
-                           out->greenShift, (out->bigEndian != in->bigEndian));
-    rfbInitOneRGBTable24 (blueTable, in->blueMax, out->blueMax,
-                           out->blueShift, (out->bigEndian != in->bigEndian));
-}
-
-static void
-rfbInitOneRGBTable24 (uint8_t *table, int inMax, int outMax, int outShift,
-                       int swap)
-{
-    int i;
-    int nEntries = inMax + 1;
-    uint32_t outValue;
-    uint8_t c;
-
-    for (i = 0; i < nEntries; i++) {
-      outValue = ((i * outMax + inMax / 2) / inMax) << outShift;
-      *(uint32_t *)&table[3*i] = outValue;
-      if(!rfbEndianTest)
-	memmove(table+3*i,table+3*i+1,3);
-        if (swap) {
-	  c = table[3*i]; table[3*i] = table[3*i+2];
-	  table[3*i+2] = c;
-        }
-    }
-}
diff --git a/libvncserver/tableinitcmtemplate.c b/libvncserver/tableinitcmtemplate.c
deleted file mode 100644
index df01b23..0000000
--- a/libvncserver/tableinitcmtemplate.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * tableinitcmtemplate.c - template for initialising lookup tables for
- * translation from a colour map to true colour.
- *
- * This file shouldn't be compiled.  It is included multiple times by
- * translate.c, each time with a different definition of the macro OUT.
- * For each value of OUT, this file defines a function which allocates an
- * appropriately sized lookup table and initialises it.
- *
- * I know this code isn't nice to read because of all the macros, but
- * efficiency is important here.
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#if !defined(OUT)
-#error "This file shouldn't be compiled."
-#error "It is included as part of translate.c"
-#endif
-
-#define OUT_T CONCAT3E(uint,OUT,_t)
-#define SwapOUT(x) CONCAT2E(Swap,OUT(x))
-#define rfbInitColourMapSingleTableOUT \
-                                CONCAT2E(rfbInitColourMapSingleTable,OUT)
-
-static void
-rfbInitColourMapSingleTableOUT(char **table, rfbPixelFormat *in,
-                            rfbPixelFormat *out,rfbColourMap* colourMap)
-{
-    uint32_t i, r, g, b;
-    OUT_T *t;
-    uint32_t nEntries = 1 << in->bitsPerPixel;
-    int shift = colourMap->is16?16:8;
-
-    if (*table) free(*table);
-    *table = (char *)malloc(nEntries * sizeof(OUT_T));
-    t = (OUT_T *)*table;
-
-    for (i = 0; i < nEntries; i++) {
-        r = g = b = 0;
-	if(i < colourMap->count) {
-	  if(colourMap->is16) {
-	    r = colourMap->data.shorts[3*i+0];
-	    g = colourMap->data.shorts[3*i+1];
-	    b = colourMap->data.shorts[3*i+2];
-	  } else {
-	    r = colourMap->data.bytes[3*i+0];
-	    g = colourMap->data.bytes[3*i+1];
-	    b = colourMap->data.bytes[3*i+2];
-	  }
-	}
-        t[i] = ((((r * (1 + out->redMax)) >> shift) << out->redShift) |
-                (((g * (1 + out->greenMax)) >> shift) << out->greenShift) |
-                (((b * (1 + out->blueMax)) >> shift) << out->blueShift));
-#if (OUT != 8)
-        if (out->bigEndian != in->bigEndian) {
-            t[i] = SwapOUT(t[i]);
-        }
-#endif
-    }
-}
-
-#undef OUT_T
-#undef SwapOUT
-#undef rfbInitColourMapSingleTableOUT
diff --git a/libvncserver/tableinittctemplate.c b/libvncserver/tableinittctemplate.c
deleted file mode 100644
index 8d4f742..0000000
--- a/libvncserver/tableinittctemplate.c
+++ /dev/null
@@ -1,142 +0,0 @@
-/*
- * tableinittctemplate.c - template for initialising lookup tables for
- * truecolour to truecolour translation.
- *
- * This file shouldn't be compiled.  It is included multiple times by
- * translate.c, each time with a different definition of the macro OUT.
- * For each value of OUT, this file defines two functions for initialising
- * lookup tables.  One is for truecolour translation using a single lookup
- * table, the other is for truecolour translation using three separate
- * lookup tables for the red, green and blue values.
- *
- * I know this code isn't nice to read because of all the macros, but
- * efficiency is important here.
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#if !defined(OUT)
-#error "This file shouldn't be compiled."
-#error "It is included as part of translate.c"
-#endif
-
-#define OUT_T CONCAT3E(uint,OUT,_t)
-#define SwapOUT(x) CONCAT2E(Swap,OUT(x))
-#define rfbInitTrueColourSingleTableOUT \
-                                CONCAT2E(rfbInitTrueColourSingleTable,OUT)
-#define rfbInitTrueColourRGBTablesOUT CONCAT2E(rfbInitTrueColourRGBTables,OUT)
-#define rfbInitOneRGBTableOUT CONCAT2E(rfbInitOneRGBTable,OUT)
-
-static void
-rfbInitOneRGBTableOUT (OUT_T *table, int inMax, int outMax, int outShift,
-                       int swap);
-
-
-/*
- * rfbInitTrueColourSingleTable sets up a single lookup table for truecolour
- * translation.
- */
-
-static void
-rfbInitTrueColourSingleTableOUT (char **table, rfbPixelFormat *in,
-                                 rfbPixelFormat *out)
-{
-    int i;
-    int inRed, inGreen, inBlue, outRed, outGreen, outBlue;
-    OUT_T *t;
-    int nEntries = 1 << in->bitsPerPixel;
-
-    if (*table) free(*table);
-    *table = (char *)malloc(nEntries * sizeof(OUT_T));
-    t = (OUT_T *)*table;
-
-    for (i = 0; i < nEntries; i++) {
-        inRed   = (i >> in->redShift)   & in->redMax;
-        inGreen = (i >> in->greenShift) & in->greenMax;
-        inBlue  = (i >> in->blueShift)  & in->blueMax;
-
-        outRed   = (inRed   * out->redMax   + in->redMax / 2)   / in->redMax;
-        outGreen = (inGreen * out->greenMax + in->greenMax / 2) / in->greenMax;
-        outBlue  = (inBlue  * out->blueMax  + in->blueMax / 2)  / in->blueMax;
-
-        t[i] = ((outRed   << out->redShift)   |
-                (outGreen << out->greenShift) |
-                (outBlue  << out->blueShift));
-#if (OUT != 8)
-        if (out->bigEndian != in->bigEndian) {
-            t[i] = SwapOUT(t[i]);
-        }
-#endif
-    }
-}
-
-
-/*
- * rfbInitTrueColourRGBTables sets up three separate lookup tables for the
- * red, green and blue values.
- */
-
-static void
-rfbInitTrueColourRGBTablesOUT (char **table, rfbPixelFormat *in,
-                               rfbPixelFormat *out)
-{
-    OUT_T *redTable;
-    OUT_T *greenTable;
-    OUT_T *blueTable;
-
-    if (*table) free(*table);
-    *table = (char *)malloc((in->redMax + in->greenMax + in->blueMax + 3)
-                            * sizeof(OUT_T));
-    redTable = (OUT_T *)*table;
-    greenTable = redTable + in->redMax + 1;
-    blueTable = greenTable + in->greenMax + 1;
-
-    rfbInitOneRGBTableOUT (redTable, in->redMax, out->redMax,
-                           out->redShift, (out->bigEndian != in->bigEndian));
-    rfbInitOneRGBTableOUT (greenTable, in->greenMax, out->greenMax,
-                           out->greenShift, (out->bigEndian != in->bigEndian));
-    rfbInitOneRGBTableOUT (blueTable, in->blueMax, out->blueMax,
-                           out->blueShift, (out->bigEndian != in->bigEndian));
-}
-
-static void
-rfbInitOneRGBTableOUT (OUT_T *table, int inMax, int outMax, int outShift,
-                       int swap)
-{
-    int i;
-    int nEntries = inMax + 1;
-
-    for (i = 0; i < nEntries; i++) {
-        table[i] = ((i * outMax + inMax / 2) / inMax) << outShift;
-#if (OUT != 8)
-        if (swap) {
-            table[i] = SwapOUT(table[i]);
-        }
-#endif
-    }
-}
-
-#undef OUT_T
-#undef SwapOUT
-#undef rfbInitTrueColourSingleTableOUT
-#undef rfbInitTrueColourRGBTablesOUT
-#undef rfbInitOneRGBTableOUT
diff --git a/libvncserver/tabletrans24template.c b/libvncserver/tabletrans24template.c
deleted file mode 100644
index 4b3a0a0..0000000
--- a/libvncserver/tabletrans24template.c
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
- * tabletranstemplate.c - template for translation using lookup tables.
- *
- * This file shouldn't be compiled.  It is included multiple times by
- * translate.c, each time with different definitions of the macros IN and OUT.
- *
- * For each pair of values IN and OUT, this file defines two functions for
- * translating a given rectangle of pixel data.  One uses a single lookup
- * table, and the other uses three separate lookup tables for the red, green
- * and blue values.
- *
- * I know this code isn't nice to read because of all the macros, but
- * efficiency is important here.
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#if !defined(BPP)
-#error "This file shouldn't be compiled."
-#error "It is included as part of translate.c"
-#endif
-
-#if BPP == 24
-
-/*
- * rfbTranslateWithSingleTableINtoOUT translates a rectangle of pixel data
- * using a single lookup table.
- */
-
-static void
-rfbTranslateWithSingleTable24to24 (char *table, rfbPixelFormat *in,
-                                    rfbPixelFormat *out,
-                                    char *iptr, char *optr,
-                                    int bytesBetweenInputLines,
-                                    int width, int height)
-{
-    uint8_t *ip = (uint8_t *)iptr;
-    uint8_t *op = (uint8_t *)optr;
-    int ipextra = bytesBetweenInputLines - width * 3;
-    uint8_t *opLineEnd;
-    uint8_t *t = (uint8_t *)table;
-    int shift = rfbEndianTest?0:8;
-    uint8_t c;
-
-    while (height > 0) {
-        opLineEnd = op + width*3;
-
-        while (op < opLineEnd) {
-	    *(uint32_t*)op = t[((*(uint32_t *)ip)>>shift)&0x00ffffff];
-	    if(!rfbEndianTest)
-	      memmove(op,op+1,3);
-	    if (out->bigEndian != in->bigEndian) {
-	      c = op[0]; op[0] = op[2]; op[2] = c;
-	    }
-	    op += 3;
-	    ip += 3;
-        }
-
-        ip += ipextra;
-        height--;
-    }
-}
-
-/*
- * rfbTranslateWithRGBTablesINtoOUT translates a rectangle of pixel data
- * using three separate lookup tables for the red, green and blue values.
- */
-
-static void
-rfbTranslateWithRGBTables24to24 (char *table, rfbPixelFormat *in,
-                                  rfbPixelFormat *out,
-                                  char *iptr, char *optr,
-                                  int bytesBetweenInputLines,
-                                  int width, int height)
-{
-    uint8_t *ip = (uint8_t *)iptr;
-    uint8_t *op = (uint8_t *)optr;
-    int ipextra = bytesBetweenInputLines - width*3;
-    uint8_t *opLineEnd;
-    uint8_t *redTable = (uint8_t *)table;
-    uint8_t *greenTable = redTable + 3*(in->redMax + 1);
-    uint8_t *blueTable = greenTable + 3*(in->greenMax + 1);
-    uint32_t outValue,inValue;
-    int shift = rfbEndianTest?0:8;
-
-    while (height > 0) {
-        opLineEnd = op+3*width;
-
-        while (op < opLineEnd) {
-	    inValue = ((*(uint32_t *)ip)>>shift)&0x00ffffff;
-            outValue = (redTable[(inValue >> in->redShift) & in->redMax] |
-                       greenTable[(inValue >> in->greenShift) & in->greenMax] |
-                       blueTable[(inValue >> in->blueShift) & in->blueMax]);
-	    memcpy(op,&outValue,3);
-	    op += 3;
-            ip+=3;
-        }
-        ip += ipextra;
-        height--;
-    }
-}
-
-#else
-
-#define IN_T CONCAT3E(uint,BPP,_t)
-#define OUT_T CONCAT3E(uint,BPP,_t)
-#define rfbTranslateWithSingleTable24toOUT \
-                                CONCAT4E(rfbTranslateWithSingleTable,24,to,BPP)
-#define rfbTranslateWithSingleTableINto24 \
-                                CONCAT4E(rfbTranslateWithSingleTable,BPP,to,24)
-#define rfbTranslateWithRGBTables24toOUT \
-                                CONCAT4E(rfbTranslateWithRGBTables,24,to,BPP)
-#define rfbTranslateWithRGBTablesINto24 \
-                                CONCAT4E(rfbTranslateWithRGBTables,BPP,to,24)
-
-/*
- * rfbTranslateWithSingleTableINtoOUT translates a rectangle of pixel data
- * using a single lookup table.
- */
-
-static void
-rfbTranslateWithSingleTable24toOUT (char *table, rfbPixelFormat *in,
-                                    rfbPixelFormat *out,
-                                    char *iptr, char *optr,
-                                    int bytesBetweenInputLines,
-                                    int width, int height)
-{
-    uint8_t *ip = (uint8_t *)iptr;
-    OUT_T *op = (OUT_T *)optr;
-    int ipextra = bytesBetweenInputLines - width*3;
-    OUT_T *opLineEnd;
-    OUT_T *t = (OUT_T *)table;
-    int shift = rfbEndianTest?0:8;
-
-    while (height > 0) {
-        opLineEnd = op + width;
-
-        while (op < opLineEnd) {
-            *(op++) = t[((*(uint32_t *)ip)>>shift)&0x00ffffff];
-	    ip+=3;
-        }
-
-        ip += ipextra;
-        height--;
-    }
-}
-
-
-/*
- * rfbTranslateWithRGBTablesINtoOUT translates a rectangle of pixel data
- * using three separate lookup tables for the red, green and blue values.
- */
-
-static void
-rfbTranslateWithRGBTables24toOUT (char *table, rfbPixelFormat *in,
-                                  rfbPixelFormat *out,
-                                  char *iptr, char *optr,
-                                  int bytesBetweenInputLines,
-                                  int width, int height)
-{
-    uint8_t *ip = (uint8_t *)iptr;
-    OUT_T *op = (OUT_T *)optr;
-    int ipextra = bytesBetweenInputLines - width*3;
-    OUT_T *opLineEnd;
-    OUT_T *redTable = (OUT_T *)table;
-    OUT_T *greenTable = redTable + in->redMax + 1;
-    OUT_T *blueTable = greenTable + in->greenMax + 1;
-    uint32_t inValue;
-    int shift = rfbEndianTest?0:8;
-
-    while (height > 0) {
-        opLineEnd = &op[width];
-
-        while (op < opLineEnd) {
-	    inValue = ((*(uint32_t *)ip)>>shift)&0x00ffffff;
-            *(op++) = (redTable[(inValue >> in->redShift) & in->redMax] |
-                       greenTable[(inValue >> in->greenShift) & in->greenMax] |
-                       blueTable[(inValue >> in->blueShift) & in->blueMax]);
-            ip+=3;
-        }
-        ip += ipextra;
-        height--;
-    }
-}
-
-/*
- * rfbTranslateWithSingleTableINto24 translates a rectangle of pixel data
- * using a single lookup table.
- */
-
-static void
-rfbTranslateWithSingleTableINto24 (char *table, rfbPixelFormat *in,
-                                    rfbPixelFormat *out,
-                                    char *iptr, char *optr,
-                                    int bytesBetweenInputLines,
-                                    int width, int height)
-{
-    IN_T *ip = (IN_T *)iptr;
-    uint8_t *op = (uint8_t *)optr;
-    int ipextra = bytesBetweenInputLines / sizeof(IN_T) - width;
-    uint8_t *opLineEnd;
-    uint8_t *t = (uint8_t *)table;
-
-    while (height > 0) {
-        opLineEnd = op + width * 3;
-
-        while (op < opLineEnd) {
-	    memcpy(op,&t[3*(*(ip++))],3);
-	    op += 3;
-        }
-
-        ip += ipextra;
-        height--;
-    }
-}
-
-
-/*
- * rfbTranslateWithRGBTablesINto24 translates a rectangle of pixel data
- * using three separate lookup tables for the red, green and blue values.
- */
-
-static void
-rfbTranslateWithRGBTablesINto24 (char *table, rfbPixelFormat *in,
-                                  rfbPixelFormat *out,
-                                  char *iptr, char *optr,
-                                  int bytesBetweenInputLines,
-                                  int width, int height)
-{
-    IN_T *ip = (IN_T *)iptr;
-    uint8_t *op = (uint8_t *)optr;
-    int ipextra = bytesBetweenInputLines / sizeof(IN_T) - width;
-    uint8_t *opLineEnd;
-    uint8_t *redTable = (uint8_t *)table;
-    uint8_t *greenTable = redTable + 3*(in->redMax + 1);
-    uint8_t *blueTable = greenTable + 3*(in->greenMax + 1);
-    uint32_t outValue;
-
-    while (height > 0) {
-        opLineEnd = op+3*width;
-
-        while (op < opLineEnd) {
-            outValue = (redTable[(*ip >> in->redShift) & in->redMax] |
-                       greenTable[(*ip >> in->greenShift) & in->greenMax] |
-                       blueTable[(*ip >> in->blueShift) & in->blueMax]);
-	    memcpy(op,&outValue,3);
-	    op += 3;
-            ip++;
-        }
-        ip += ipextra;
-        height--;
-    }
-}
-
-#undef IN_T
-#undef OUT_T
-#undef rfbTranslateWithSingleTable24toOUT
-#undef rfbTranslateWithRGBTables24toOUT
-#undef rfbTranslateWithSingleTableINto24
-#undef rfbTranslateWithRGBTablesINto24
-
-#endif
diff --git a/libvncserver/tabletranstemplate.c b/libvncserver/tabletranstemplate.c
deleted file mode 100644
index e83c623..0000000
--- a/libvncserver/tabletranstemplate.c
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * tabletranstemplate.c - template for translation using lookup tables.
- *
- * This file shouldn't be compiled.  It is included multiple times by
- * translate.c, each time with different definitions of the macros IN and OUT.
- *
- * For each pair of values IN and OUT, this file defines two functions for
- * translating a given rectangle of pixel data.  One uses a single lookup
- * table, and the other uses three separate lookup tables for the red, green
- * and blue values.
- *
- * I know this code isn't nice to read because of all the macros, but
- * efficiency is important here.
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#if !defined(IN) || !defined(OUT)
-#error "This file shouldn't be compiled."
-#error "It is included as part of translate.c"
-#endif
-
-#define IN_T CONCAT3E(uint,IN,_t)
-#define OUT_T CONCAT3E(uint,OUT,_t)
-#define rfbTranslateWithSingleTableINtoOUT \
-                                CONCAT4E(rfbTranslateWithSingleTable,IN,to,OUT)
-#define rfbTranslateWithRGBTablesINtoOUT \
-                                CONCAT4E(rfbTranslateWithRGBTables,IN,to,OUT)
-
-/*
- * rfbTranslateWithSingleTableINtoOUT translates a rectangle of pixel data
- * using a single lookup table.
- */
-
-static void
-rfbTranslateWithSingleTableINtoOUT (char *table, rfbPixelFormat *in,
-                                    rfbPixelFormat *out,
-                                    char *iptr, char *optr,
-                                    int bytesBetweenInputLines,
-                                    int width, int height)
-{
-    IN_T *ip = (IN_T *)iptr;
-    OUT_T *op = (OUT_T *)optr;
-    int ipextra = bytesBetweenInputLines / sizeof(IN_T) - width;
-    OUT_T *opLineEnd;
-    OUT_T *t = (OUT_T *)table;
-
-    while (height > 0) {
-        opLineEnd = op + width;
-
-        while (op < opLineEnd) {
-            *(op++) = t[*(ip++)];
-        }
-
-        ip += ipextra;
-        height--;
-    }
-}
-
-
-/*
- * rfbTranslateWithRGBTablesINtoOUT translates a rectangle of pixel data
- * using three separate lookup tables for the red, green and blue values.
- */
-
-static void
-rfbTranslateWithRGBTablesINtoOUT (char *table, rfbPixelFormat *in,
-                                  rfbPixelFormat *out,
-                                  char *iptr, char *optr,
-                                  int bytesBetweenInputLines,
-                                  int width, int height)
-{
-    IN_T *ip = (IN_T *)iptr;
-    OUT_T *op = (OUT_T *)optr;
-    int ipextra = bytesBetweenInputLines / sizeof(IN_T) - width;
-    OUT_T *opLineEnd;
-    OUT_T *redTable = (OUT_T *)table;
-    OUT_T *greenTable = redTable + in->redMax + 1;
-    OUT_T *blueTable = greenTable + in->greenMax + 1;
-
-    while (height > 0) {
-        opLineEnd = &op[width];
-
-        while (op < opLineEnd) {
-            *(op++) = (redTable[(*ip >> in->redShift) & in->redMax] |
-                       greenTable[(*ip >> in->greenShift) & in->greenMax] |
-                       blueTable[(*ip >> in->blueShift) & in->blueMax]);
-            ip++;
-        }
-        ip += ipextra;
-        height--;
-    }
-}
-
-#undef IN_T
-#undef OUT_T
-#undef rfbTranslateWithSingleTableINtoOUT
-#undef rfbTranslateWithRGBTablesINtoOUT
diff --git a/libvncserver/tight.c b/libvncserver/tight.c
deleted file mode 100644
index da5a02d..0000000
--- a/libvncserver/tight.c
+++ /dev/null
@@ -1,1824 +0,0 @@
-/*
- * tight.c
- *
- * Routines to implement Tight Encoding
- */
-
-/*
- *  Copyright (C) 2000, 2001 Const Kaplinsky.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*#include <stdio.h>*/
-#include "rfb/rfb.h"
-#include "private.h"
-
-#ifdef WIN32
-#define XMD_H
-#undef FAR
-#define NEEDFAR_POINTERS
-#endif
-
-#ifdef _RPCNDR_H /* This Windows header typedefs 'boolean', jpeglib has to know */
-#define HAVE_BOOLEAN
-#endif
-#include <jpeglib.h>
-
-/* Note: The following constant should not be changed. */
-#define TIGHT_MIN_TO_COMPRESS 12
-
-/* The parameters below may be adjusted. */
-#define MIN_SPLIT_RECT_SIZE     4096
-#define MIN_SOLID_SUBRECT_SIZE  2048
-#define MAX_SPLIT_TILE_SIZE       16
-
-/* May be set to TRUE with "-lazytight" Xvnc option. */
-rfbBool rfbTightDisableGradient = FALSE;
-
-/*
- * There is so much access of the Tight encoding static data buffers
- * that we resort to using thread local storage instead of having
- * per-client data.
- */
-#if LIBVNCSERVER_HAVE_LIBPTHREAD && LIBVNCSERVER_HAVE_TLS && !defined(TLS) && defined(__linux__)
-#define TLS __thread
-#endif
-#ifndef TLS
-#define TLS
-#endif
-
-/* This variable is set on every rfbSendRectEncodingTight() call. */
-static TLS rfbBool usePixelFormat24 = FALSE;
-
-/* Compression level stuff. The following array contains various
-   encoder parameters for each of 10 compression levels (0..9).
-   Last three parameters correspond to JPEG quality levels (0..9). */
-
-typedef struct TIGHT_CONF_s {
-    int maxRectSize, maxRectWidth;
-    int monoMinRectSize, gradientMinRectSize;
-    int idxZlibLevel, monoZlibLevel, rawZlibLevel, gradientZlibLevel;
-    int gradientThreshold, gradientThreshold24;
-    int idxMaxColorsDivisor;
-    int jpegQuality, jpegThreshold, jpegThreshold24;
-} TIGHT_CONF;
-
-static TIGHT_CONF tightConf[10] = {
-    {   512,   32,   6, 65536, 0, 0, 0, 0,   0,   0,   4,  5, 10000, 23000 },
-    {  2048,  128,   6, 65536, 1, 1, 1, 0,   0,   0,   8, 10,  8000, 18000 },
-    {  6144,  256,   8, 65536, 3, 3, 2, 0,   0,   0,  24, 15,  6500, 15000 },
-    { 10240, 1024,  12, 65536, 5, 5, 3, 0,   0,   0,  32, 25,  5000, 12000 },
-    { 16384, 2048,  12, 65536, 6, 6, 4, 0,   0,   0,  32, 37,  4000, 10000 },
-    { 32768, 2048,  12,  4096, 7, 7, 5, 4, 150, 380,  32, 50,  3000,  8000 },
-    { 65536, 2048,  16,  4096, 7, 7, 6, 4, 170, 420,  48, 60,  2000,  5000 },
-    { 65536, 2048,  16,  4096, 8, 8, 7, 5, 180, 450,  64, 70,  1000,  2500 },
-    { 65536, 2048,  32,  8192, 9, 9, 8, 6, 190, 475,  64, 75,   500,  1200 },
-    { 65536, 2048,  32,  8192, 9, 9, 9, 6, 200, 500,  96, 80,   200,   500 }
-};
-
-static TLS int compressLevel = 0;
-static TLS int qualityLevel = 0;
-
-/* Stuff dealing with palettes. */
-
-typedef struct COLOR_LIST_s {
-    struct COLOR_LIST_s *next;
-    int idx;
-    uint32_t rgb;
-} COLOR_LIST;
-
-typedef struct PALETTE_ENTRY_s {
-    COLOR_LIST *listNode;
-    int numPixels;
-} PALETTE_ENTRY;
-
-typedef struct PALETTE_s {
-    PALETTE_ENTRY entry[256];
-    COLOR_LIST *hash[256];
-    COLOR_LIST list[256];
-} PALETTE;
-
-/* TODO: move into rfbScreen struct */
-static TLS int paletteNumColors = 0;
-static TLS int paletteMaxColors = 0;
-static TLS uint32_t monoBackground = 0;
-static TLS uint32_t monoForeground = 0;
-static TLS PALETTE palette;
-
-/* Pointers to dynamically-allocated buffers. */
-
-static TLS int tightBeforeBufSize = 0;
-static TLS char *tightBeforeBuf = NULL;
-
-static TLS int tightAfterBufSize = 0;
-static TLS char *tightAfterBuf = NULL;
-
-static TLS int *prevRowBuf = NULL;
-
-void rfbTightCleanup(rfbScreenInfoPtr screen)
-{
-  if(tightBeforeBufSize) {
-    free(tightBeforeBuf);
-    tightBeforeBufSize=0;
-    tightBeforeBuf = NULL;
-  }
-  if(tightAfterBufSize) {
-    free(tightAfterBuf);
-    tightAfterBufSize=0;
-    tightAfterBuf = NULL;
-  }
-}
-
-/* Prototypes for static functions. */
-
-static void FindBestSolidArea (rfbClientPtr cl, int x, int y, int w, int h,
-                               uint32_t colorValue, int *w_ptr, int *h_ptr);
-static void ExtendSolidArea   (rfbClientPtr cl, int x, int y, int w, int h,
-                               uint32_t colorValue,
-                               int *x_ptr, int *y_ptr, int *w_ptr, int *h_ptr);
-static rfbBool CheckSolidTile    (rfbClientPtr cl, int x, int y, int w, int h,
-                               uint32_t *colorPtr, rfbBool needSameColor);
-static rfbBool CheckSolidTile8   (rfbClientPtr cl, int x, int y, int w, int h,
-                               uint32_t *colorPtr, rfbBool needSameColor);
-static rfbBool CheckSolidTile16  (rfbClientPtr cl, int x, int y, int w, int h,
-                               uint32_t *colorPtr, rfbBool needSameColor);
-static rfbBool CheckSolidTile32  (rfbClientPtr cl, int x, int y, int w, int h,
-                               uint32_t *colorPtr, rfbBool needSameColor);
-
-static rfbBool SendRectSimple    (rfbClientPtr cl, int x, int y, int w, int h);
-static rfbBool SendSubrect       (rfbClientPtr cl, int x, int y, int w, int h);
-static rfbBool SendTightHeader   (rfbClientPtr cl, int x, int y, int w, int h);
-
-static rfbBool SendSolidRect     (rfbClientPtr cl);
-static rfbBool SendMonoRect      (rfbClientPtr cl, int w, int h);
-static rfbBool SendIndexedRect   (rfbClientPtr cl, int w, int h);
-static rfbBool SendFullColorRect (rfbClientPtr cl, int w, int h);
-static rfbBool SendGradientRect  (rfbClientPtr cl, int w, int h);
-
-static rfbBool CompressData(rfbClientPtr cl, int streamId, int dataLen,
-                         int zlibLevel, int zlibStrategy);
-static rfbBool SendCompressedData(rfbClientPtr cl, int compressedLen);
-
-static void FillPalette8(int count);
-static void FillPalette16(int count);
-static void FillPalette32(int count);
-
-static void PaletteReset(void);
-static int PaletteInsert(uint32_t rgb, int numPixels, int bpp);
-
-static void Pack24(rfbClientPtr cl, char *buf, rfbPixelFormat *fmt, int count);
-
-static void EncodeIndexedRect16(uint8_t *buf, int count);
-static void EncodeIndexedRect32(uint8_t *buf, int count);
-
-static void EncodeMonoRect8(uint8_t *buf, int w, int h);
-static void EncodeMonoRect16(uint8_t *buf, int w, int h);
-static void EncodeMonoRect32(uint8_t *buf, int w, int h);
-
-static void FilterGradient24(rfbClientPtr cl, char *buf, rfbPixelFormat *fmt, int w, int h);
-static void FilterGradient16(rfbClientPtr cl, uint16_t *buf, rfbPixelFormat *fmt, int w, int h);
-static void FilterGradient32(rfbClientPtr cl, uint32_t *buf, rfbPixelFormat *fmt, int w, int h);
-
-static int DetectSmoothImage(rfbClientPtr cl, rfbPixelFormat *fmt, int w, int h);
-static unsigned long DetectSmoothImage24(rfbClientPtr cl, rfbPixelFormat *fmt, int w, int h);
-static unsigned long DetectSmoothImage16(rfbClientPtr cl, rfbPixelFormat *fmt, int w, int h);
-static unsigned long DetectSmoothImage32(rfbClientPtr cl, rfbPixelFormat *fmt, int w, int h);
-
-static rfbBool SendJpegRect(rfbClientPtr cl, int x, int y, int w, int h,
-                         int quality);
-static void PrepareRowForJpeg(rfbClientPtr cl, uint8_t *dst, int x, int y, int count);
-static void PrepareRowForJpeg24(rfbClientPtr cl, uint8_t *dst, int x, int y, int count);
-static void PrepareRowForJpeg16(rfbClientPtr cl, uint8_t *dst, int x, int y, int count);
-static void PrepareRowForJpeg32(rfbClientPtr cl, uint8_t *dst, int x, int y, int count);
-
-static void JpegInitDestination(j_compress_ptr cinfo);
-static boolean JpegEmptyOutputBuffer(j_compress_ptr cinfo);
-static void JpegTermDestination(j_compress_ptr cinfo);
-static void JpegSetDstManager(j_compress_ptr cinfo);
-
-
-/*
- * Tight encoding implementation.
- */
-
-int
-rfbNumCodedRectsTight(rfbClientPtr cl,
-                      int x,
-                      int y,
-                      int w,
-                      int h)
-{
-    int maxRectSize, maxRectWidth;
-    int subrectMaxWidth, subrectMaxHeight;
-
-    /* No matter how many rectangles we will send if LastRect markers
-       are used to terminate rectangle stream. */
-    if (cl->enableLastRectEncoding && w * h >= MIN_SPLIT_RECT_SIZE)
-      return 0;
-
-    maxRectSize = tightConf[cl->tightCompressLevel].maxRectSize;
-    maxRectWidth = tightConf[cl->tightCompressLevel].maxRectWidth;
-
-    if (w > maxRectWidth || w * h > maxRectSize) {
-        subrectMaxWidth = (w > maxRectWidth) ? maxRectWidth : w;
-        subrectMaxHeight = maxRectSize / subrectMaxWidth;
-        return (((w - 1) / maxRectWidth + 1) *
-                ((h - 1) / subrectMaxHeight + 1));
-    } else {
-        return 1;
-    }
-}
-
-rfbBool
-rfbSendRectEncodingTight(rfbClientPtr cl,
-                         int x,
-                         int y,
-                         int w,
-                         int h)
-{
-    int nMaxRows;
-    uint32_t colorValue;
-    int dx, dy, dw, dh;
-    int x_best, y_best, w_best, h_best;
-    char *fbptr;
-
-    rfbSendUpdateBuf(cl);
-
-    compressLevel = cl->tightCompressLevel;
-    qualityLevel = cl->tightQualityLevel;
-
-    if ( cl->format.depth == 24 && cl->format.redMax == 0xFF &&
-         cl->format.greenMax == 0xFF && cl->format.blueMax == 0xFF ) {
-        usePixelFormat24 = TRUE;
-    } else {
-        usePixelFormat24 = FALSE;
-    }
-
-    if (!cl->enableLastRectEncoding || w * h < MIN_SPLIT_RECT_SIZE)
-        return SendRectSimple(cl, x, y, w, h);
-
-    /* Make sure we can write at least one pixel into tightBeforeBuf. */
-
-    if (tightBeforeBufSize < 4) {
-        tightBeforeBufSize = 4;
-        if (tightBeforeBuf == NULL)
-            tightBeforeBuf = (char *)malloc(tightBeforeBufSize);
-        else
-            tightBeforeBuf = (char *)realloc(tightBeforeBuf,
-                                              tightBeforeBufSize);
-    }
-
-    /* Calculate maximum number of rows in one non-solid rectangle. */
-
-    {
-        int maxRectSize, maxRectWidth, nMaxWidth;
-
-        maxRectSize = tightConf[compressLevel].maxRectSize;
-        maxRectWidth = tightConf[compressLevel].maxRectWidth;
-        nMaxWidth = (w > maxRectWidth) ? maxRectWidth : w;
-        nMaxRows = maxRectSize / nMaxWidth;
-    }
-
-    /* Try to find large solid-color areas and send them separately. */
-
-    for (dy = y; dy < y + h; dy += MAX_SPLIT_TILE_SIZE) {
-
-        /* If a rectangle becomes too large, send its upper part now. */
-
-        if (dy - y >= nMaxRows) {
-            if (!SendRectSimple(cl, x, y, w, nMaxRows))
-                return 0;
-            y += nMaxRows;
-            h -= nMaxRows;
-        }
-
-        dh = (dy + MAX_SPLIT_TILE_SIZE <= y + h) ?
-            MAX_SPLIT_TILE_SIZE : (y + h - dy);
-
-        for (dx = x; dx < x + w; dx += MAX_SPLIT_TILE_SIZE) {
-
-            dw = (dx + MAX_SPLIT_TILE_SIZE <= x + w) ?
-                MAX_SPLIT_TILE_SIZE : (x + w - dx);
-
-            if (CheckSolidTile(cl, dx, dy, dw, dh, &colorValue, FALSE)) {
-
-                /* Get dimensions of solid-color area. */
-
-                FindBestSolidArea(cl, dx, dy, w - (dx - x), h - (dy - y),
-				  colorValue, &w_best, &h_best);
-
-                /* Make sure a solid rectangle is large enough
-                   (or the whole rectangle is of the same color). */
-
-                if ( w_best * h_best != w * h &&
-                     w_best * h_best < MIN_SOLID_SUBRECT_SIZE )
-                    continue;
-
-                /* Try to extend solid rectangle to maximum size. */
-
-                x_best = dx; y_best = dy;
-                ExtendSolidArea(cl, x, y, w, h, colorValue,
-                                &x_best, &y_best, &w_best, &h_best);
-
-                /* Send rectangles at top and left to solid-color area. */
-
-                if ( y_best != y &&
-                     !SendRectSimple(cl, x, y, w, y_best-y) )
-                    return FALSE;
-                if ( x_best != x &&
-                     !rfbSendRectEncodingTight(cl, x, y_best,
-                                               x_best-x, h_best) )
-                    return FALSE;
-
-                /* Send solid-color rectangle. */
-
-                if (!SendTightHeader(cl, x_best, y_best, w_best, h_best))
-                    return FALSE;
-
-                fbptr = (cl->scaledScreen->frameBuffer +
-                         (cl->scaledScreen->paddedWidthInBytes * y_best) +
-                         (x_best * (cl->scaledScreen->bitsPerPixel / 8)));
-
-                (*cl->translateFn)(cl->translateLookupTable, &cl->screen->serverFormat,
-                                   &cl->format, fbptr, tightBeforeBuf,
-                                   cl->scaledScreen->paddedWidthInBytes, 1, 1);
-
-                if (!SendSolidRect(cl))
-                    return FALSE;
-
-                /* Send remaining rectangles (at right and bottom). */
-
-                if ( x_best + w_best != x + w &&
-                     !rfbSendRectEncodingTight(cl, x_best+w_best, y_best,
-                                               w-(x_best-x)-w_best, h_best) )
-                    return FALSE;
-                if ( y_best + h_best != y + h &&
-                     !rfbSendRectEncodingTight(cl, x, y_best+h_best,
-                                               w, h-(y_best-y)-h_best) )
-                    return FALSE;
-
-                /* Return after all recursive calls are done. */
-
-                return TRUE;
-            }
-
-        }
-
-    }
-
-    /* No suitable solid-color rectangles found. */
-
-    return SendRectSimple(cl, x, y, w, h);
-}
-
-static void
-FindBestSolidArea(rfbClientPtr cl,
-                  int x,
-                  int y,
-                  int w,
-                  int h,
-                  uint32_t colorValue,
-                  int *w_ptr,
-                  int *h_ptr)
-{
-    int dx, dy, dw, dh;
-    int w_prev;
-    int w_best = 0, h_best = 0;
-
-    w_prev = w;
-
-    for (dy = y; dy < y + h; dy += MAX_SPLIT_TILE_SIZE) {
-
-        dh = (dy + MAX_SPLIT_TILE_SIZE <= y + h) ?
-            MAX_SPLIT_TILE_SIZE : (y + h - dy);
-        dw = (w_prev > MAX_SPLIT_TILE_SIZE) ?
-            MAX_SPLIT_TILE_SIZE : w_prev;
-
-        if (!CheckSolidTile(cl, x, dy, dw, dh, &colorValue, TRUE))
-            break;
-
-        for (dx = x + dw; dx < x + w_prev;) {
-            dw = (dx + MAX_SPLIT_TILE_SIZE <= x + w_prev) ?
-                MAX_SPLIT_TILE_SIZE : (x + w_prev - dx);
-            if (!CheckSolidTile(cl, dx, dy, dw, dh, &colorValue, TRUE))
-                break;
-	    dx += dw;
-        }
-
-        w_prev = dx - x;
-        if (w_prev * (dy + dh - y) > w_best * h_best) {
-            w_best = w_prev;
-            h_best = dy + dh - y;
-        }
-    }
-
-    *w_ptr = w_best;
-    *h_ptr = h_best;
-}
-
-static void
-ExtendSolidArea(rfbClientPtr cl,
-                int x,
-                int y,
-                int w,
-                int h,
-                uint32_t colorValue,
-                int *x_ptr,
-                int *y_ptr,
-                int *w_ptr,
-                int *h_ptr)
-{
-    int cx, cy;
-
-    /* Try to extend the area upwards. */
-    for ( cy = *y_ptr - 1;
-          cy >= y && CheckSolidTile(cl, *x_ptr, cy, *w_ptr, 1, &colorValue, TRUE);
-          cy-- );
-    *h_ptr += *y_ptr - (cy + 1);
-    *y_ptr = cy + 1;
-
-    /* ... downwards. */
-    for ( cy = *y_ptr + *h_ptr;
-          cy < y + h &&
-              CheckSolidTile(cl, *x_ptr, cy, *w_ptr, 1, &colorValue, TRUE);
-          cy++ );
-    *h_ptr += cy - (*y_ptr + *h_ptr);
-
-    /* ... to the left. */
-    for ( cx = *x_ptr - 1;
-          cx >= x && CheckSolidTile(cl, cx, *y_ptr, 1, *h_ptr, &colorValue, TRUE);
-          cx-- );
-    *w_ptr += *x_ptr - (cx + 1);
-    *x_ptr = cx + 1;
-
-    /* ... to the right. */
-    for ( cx = *x_ptr + *w_ptr;
-          cx < x + w &&
-              CheckSolidTile(cl, cx, *y_ptr, 1, *h_ptr, &colorValue, TRUE);
-          cx++ );
-    *w_ptr += cx - (*x_ptr + *w_ptr);
-}
-
-/*
- * Check if a rectangle is all of the same color. If needSameColor is
- * set to non-zero, then also check that its color equals to the
- * *colorPtr value. The result is 1 if the test is successfull, and in
- * that case new color will be stored in *colorPtr.
- */
-
-static rfbBool CheckSolidTile(rfbClientPtr cl, int x, int y, int w, int h, uint32_t* colorPtr, rfbBool needSameColor)
-{
-    switch(cl->screen->serverFormat.bitsPerPixel) {
-    case 32:
-        return CheckSolidTile32(cl, x, y, w, h, colorPtr, needSameColor);
-    case 16:
-        return CheckSolidTile16(cl, x, y, w, h, colorPtr, needSameColor);
-    default:
-        return CheckSolidTile8(cl, x, y, w, h, colorPtr, needSameColor);
-    }
-}
-
-#define DEFINE_CHECK_SOLID_FUNCTION(bpp)                                      \
-                                                                              \
-static rfbBool                                                                \
-CheckSolidTile##bpp(rfbClientPtr cl, int x, int y, int w, int h,              \
-		uint32_t* colorPtr, rfbBool needSameColor)                    \
-{                                                                             \
-    uint##bpp##_t *fbptr;                                                     \
-    uint##bpp##_t colorValue;                                                 \
-    int dx, dy;                                                               \
-                                                                              \
-    fbptr = (uint##bpp##_t *)                                                 \
-        &cl->scaledScreen->frameBuffer[y * cl->scaledScreen->paddedWidthInBytes + x * (bpp/8)]; \
-                                                                              \
-    colorValue = *fbptr;                                                      \
-    if (needSameColor && (uint32_t)colorValue != *colorPtr)                   \
-        return FALSE;                                                         \
-                                                                              \
-    for (dy = 0; dy < h; dy++) {                                              \
-        for (dx = 0; dx < w; dx++) {                                          \
-            if (colorValue != fbptr[dx])                                      \
-                return FALSE;                                                 \
-        }                                                                     \
-        fbptr = (uint##bpp##_t *)((uint8_t *)fbptr + cl->scaledScreen->paddedWidthInBytes); \
-    }                                                                         \
-                                                                              \
-    *colorPtr = (uint32_t)colorValue;                                         \
-    return TRUE;                                                              \
-}
-
-DEFINE_CHECK_SOLID_FUNCTION(8)
-DEFINE_CHECK_SOLID_FUNCTION(16)
-DEFINE_CHECK_SOLID_FUNCTION(32)
-
-static rfbBool
-SendRectSimple(rfbClientPtr cl, int x, int y, int w, int h)
-{
-    int maxBeforeSize, maxAfterSize;
-    int maxRectSize, maxRectWidth;
-    int subrectMaxWidth, subrectMaxHeight;
-    int dx, dy;
-    int rw, rh;
-
-    maxRectSize = tightConf[compressLevel].maxRectSize;
-    maxRectWidth = tightConf[compressLevel].maxRectWidth;
-
-    maxBeforeSize = maxRectSize * (cl->format.bitsPerPixel / 8);
-    maxAfterSize = maxBeforeSize + (maxBeforeSize + 99) / 100 + 12;
-
-    if (tightBeforeBufSize < maxBeforeSize) {
-        tightBeforeBufSize = maxBeforeSize;
-        if (tightBeforeBuf == NULL)
-            tightBeforeBuf = (char *)malloc(tightBeforeBufSize);
-        else
-            tightBeforeBuf = (char *)realloc(tightBeforeBuf,
-                                              tightBeforeBufSize);
-    }
-
-    if (tightAfterBufSize < maxAfterSize) {
-        tightAfterBufSize = maxAfterSize;
-        if (tightAfterBuf == NULL)
-            tightAfterBuf = (char *)malloc(tightAfterBufSize);
-        else
-            tightAfterBuf = (char *)realloc(tightAfterBuf,
-                                             tightAfterBufSize);
-    }
-
-    if (w > maxRectWidth || w * h > maxRectSize) {
-        subrectMaxWidth = (w > maxRectWidth) ? maxRectWidth : w;
-        subrectMaxHeight = maxRectSize / subrectMaxWidth;
-
-        for (dy = 0; dy < h; dy += subrectMaxHeight) {
-            for (dx = 0; dx < w; dx += maxRectWidth) {
-                rw = (dx + maxRectWidth < w) ? maxRectWidth : w - dx;
-                rh = (dy + subrectMaxHeight < h) ? subrectMaxHeight : h - dy;
-                if (!SendSubrect(cl, x+dx, y+dy, rw, rh))
-                    return FALSE;
-            }
-        }
-    } else {
-        if (!SendSubrect(cl, x, y, w, h))
-            return FALSE;
-    }
-
-    return TRUE;
-}
-
-static rfbBool
-SendSubrect(rfbClientPtr cl,
-            int x,
-            int y,
-            int w,
-            int h)
-{
-    char *fbptr;
-    rfbBool success = FALSE;
-
-    /* Send pending data if there is more than 128 bytes. */
-    if (cl->ublen > 128) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    if (!SendTightHeader(cl, x, y, w, h))
-        return FALSE;
-
-    fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)
-             + (x * (cl->scaledScreen->bitsPerPixel / 8)));
-
-    (*cl->translateFn)(cl->translateLookupTable, &cl->screen->serverFormat,
-                       &cl->format, fbptr, tightBeforeBuf,
-                       cl->scaledScreen->paddedWidthInBytes, w, h);
-
-    paletteMaxColors = w * h / tightConf[compressLevel].idxMaxColorsDivisor;
-    if ( paletteMaxColors < 2 &&
-         w * h >= tightConf[compressLevel].monoMinRectSize ) {
-        paletteMaxColors = 2;
-    }
-    switch (cl->format.bitsPerPixel) {
-    case 8:
-        FillPalette8(w * h);
-        break;
-    case 16:
-        FillPalette16(w * h);
-        break;
-    default:
-        FillPalette32(w * h);
-    }
-
-    switch (paletteNumColors) {
-    case 0:
-        /* Truecolor image */
-        if (DetectSmoothImage(cl, &cl->format, w, h)) {
-            if (qualityLevel != -1) {
-                success = SendJpegRect(cl, x, y, w, h,
-                                       tightConf[qualityLevel].jpegQuality);
-            } else {
-                success = SendGradientRect(cl, w, h);
-            }
-        } else {
-            success = SendFullColorRect(cl, w, h);
-        }
-        break;
-    case 1:
-        /* Solid rectangle */
-        success = SendSolidRect(cl);
-        break;
-    case 2:
-        /* Two-color rectangle */
-        success = SendMonoRect(cl, w, h);
-        break;
-    default:
-        /* Up to 256 different colors */
-        if ( paletteNumColors > 96 &&
-             qualityLevel != -1 && qualityLevel <= 3 &&
-             DetectSmoothImage(cl, &cl->format, w, h) ) {
-            success = SendJpegRect(cl, x, y, w, h,
-                                   tightConf[qualityLevel].jpegQuality);
-        } else {
-            success = SendIndexedRect(cl, w, h);
-        }
-    }
-    return success;
-}
-
-static rfbBool
-SendTightHeader(rfbClientPtr cl,
-                int x,
-                int y,
-                int w,
-                int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    rect.r.x = Swap16IfLE(x);
-    rect.r.y = Swap16IfLE(y);
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-    rect.encoding = Swap32IfLE(rfbEncodingTight);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-           sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    rfbStatRecordEncodingSent(cl, rfbEncodingTight, sz_rfbFramebufferUpdateRectHeader,
-                              sz_rfbFramebufferUpdateRectHeader + w * (cl->format.bitsPerPixel / 8) * h);
-
-    return TRUE;
-}
-
-/*
- * Subencoding implementations.
- */
-
-static rfbBool
-SendSolidRect(rfbClientPtr cl)
-{
-    int len;
-
-    if (usePixelFormat24) {
-        Pack24(cl, tightBeforeBuf, &cl->format, 1);
-        len = 3;
-    } else
-        len = cl->format.bitsPerPixel / 8;
-
-    if (cl->ublen + 1 + len > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    cl->updateBuf[cl->ublen++] = (char)(rfbTightFill << 4);
-    memcpy (&cl->updateBuf[cl->ublen], tightBeforeBuf, len);
-    cl->ublen += len;
-
-    rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, len+1);
-
-    return TRUE;
-}
-
-static rfbBool
-SendMonoRect(rfbClientPtr cl,
-             int w,
-             int h)
-{
-    int streamId = 1;
-    int paletteLen, dataLen;
-
-    if ( cl->ublen + TIGHT_MIN_TO_COMPRESS + 6 +
-	 2 * cl->format.bitsPerPixel / 8 > UPDATE_BUF_SIZE ) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    /* Prepare tight encoding header. */
-    dataLen = (w + 7) / 8;
-    dataLen *= h;
-
-    cl->updateBuf[cl->ublen++] = (streamId | rfbTightExplicitFilter) << 4;
-    cl->updateBuf[cl->ublen++] = rfbTightFilterPalette;
-    cl->updateBuf[cl->ublen++] = 1;
-
-    /* Prepare palette, convert image. */
-    switch (cl->format.bitsPerPixel) {
-
-    case 32:
-        EncodeMonoRect32((uint8_t *)tightBeforeBuf, w, h);
-
-        ((uint32_t *)tightAfterBuf)[0] = monoBackground;
-        ((uint32_t *)tightAfterBuf)[1] = monoForeground;
-        if (usePixelFormat24) {
-            Pack24(cl, tightAfterBuf, &cl->format, 2);
-            paletteLen = 6;
-        } else
-            paletteLen = 8;
-
-        memcpy(&cl->updateBuf[cl->ublen], tightAfterBuf, paletteLen);
-        cl->ublen += paletteLen;
-        rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 3 + paletteLen);
-        break;
-
-    case 16:
-        EncodeMonoRect16((uint8_t *)tightBeforeBuf, w, h);
-
-        ((uint16_t *)tightAfterBuf)[0] = (uint16_t)monoBackground;
-        ((uint16_t *)tightAfterBuf)[1] = (uint16_t)monoForeground;
-
-        memcpy(&cl->updateBuf[cl->ublen], tightAfterBuf, 4);
-        cl->ublen += 4;
-        rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 7);
-        break;
-
-    default:
-        EncodeMonoRect8((uint8_t *)tightBeforeBuf, w, h);
-
-        cl->updateBuf[cl->ublen++] = (char)monoBackground;
-        cl->updateBuf[cl->ublen++] = (char)monoForeground;
-        rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 5);
-    }
-
-    return CompressData(cl, streamId, dataLen,
-                        tightConf[compressLevel].monoZlibLevel,
-                        Z_DEFAULT_STRATEGY);
-}
-
-static rfbBool
-SendIndexedRect(rfbClientPtr cl,
-                int w,
-                int h)
-{
-    int streamId = 2;
-    int i, entryLen;
-
-    if ( cl->ublen + TIGHT_MIN_TO_COMPRESS + 6 +
-	 paletteNumColors * cl->format.bitsPerPixel / 8 >
-         UPDATE_BUF_SIZE ) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    /* Prepare tight encoding header. */
-    cl->updateBuf[cl->ublen++] = (streamId | rfbTightExplicitFilter) << 4;
-    cl->updateBuf[cl->ublen++] = rfbTightFilterPalette;
-    cl->updateBuf[cl->ublen++] = (char)(paletteNumColors - 1);
-
-    /* Prepare palette, convert image. */
-    switch (cl->format.bitsPerPixel) {
-
-    case 32:
-        EncodeIndexedRect32((uint8_t *)tightBeforeBuf, w * h);
-
-        for (i = 0; i < paletteNumColors; i++) {
-            ((uint32_t *)tightAfterBuf)[i] =
-                palette.entry[i].listNode->rgb;
-        }
-        if (usePixelFormat24) {
-            Pack24(cl, tightAfterBuf, &cl->format, paletteNumColors);
-            entryLen = 3;
-        } else
-            entryLen = 4;
-
-        memcpy(&cl->updateBuf[cl->ublen], tightAfterBuf, paletteNumColors * entryLen);
-        cl->ublen += paletteNumColors * entryLen;
-        rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 3 + paletteNumColors * entryLen);
-        break;
-
-    case 16:
-        EncodeIndexedRect16((uint8_t *)tightBeforeBuf, w * h);
-
-        for (i = 0; i < paletteNumColors; i++) {
-            ((uint16_t *)tightAfterBuf)[i] =
-                (uint16_t)palette.entry[i].listNode->rgb;
-        }
-
-        memcpy(&cl->updateBuf[cl->ublen], tightAfterBuf, paletteNumColors * 2);
-        cl->ublen += paletteNumColors * 2;
-        rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 3 + paletteNumColors * 2);
-        break;
-
-    default:
-        return FALSE;           /* Should never happen. */
-    }
-
-    return CompressData(cl, streamId, w * h,
-                        tightConf[compressLevel].idxZlibLevel,
-                        Z_DEFAULT_STRATEGY);
-}
-
-static rfbBool
-SendFullColorRect(rfbClientPtr cl,
-                  int w,
-                  int h)
-{
-    int streamId = 0;
-    int len;
-
-    if (cl->ublen + TIGHT_MIN_TO_COMPRESS + 1 > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    cl->updateBuf[cl->ublen++] = 0x00;  /* stream id = 0, no flushing, no filter */
-    rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 1);
-
-    if (usePixelFormat24) {
-        Pack24(cl, tightBeforeBuf, &cl->format, w * h);
-        len = 3;
-    } else
-        len = cl->format.bitsPerPixel / 8;
-
-    return CompressData(cl, streamId, w * h * len,
-                        tightConf[compressLevel].rawZlibLevel,
-                        Z_DEFAULT_STRATEGY);
-}
-
-static rfbBool
-SendGradientRect(rfbClientPtr cl,
-                 int w,
-                 int h)
-{
-    int streamId = 3;
-    int len;
-
-    if (cl->format.bitsPerPixel == 8)
-        return SendFullColorRect(cl, w, h);
-
-    if (cl->ublen + TIGHT_MIN_TO_COMPRESS + 2 > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    if (prevRowBuf == NULL)
-        prevRowBuf = (int *)malloc(2048 * 3 * sizeof(int));
-
-    cl->updateBuf[cl->ublen++] = (streamId | rfbTightExplicitFilter) << 4;
-    cl->updateBuf[cl->ublen++] = rfbTightFilterGradient;
-    rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 2);
-
-    if (usePixelFormat24) {
-        FilterGradient24(cl, tightBeforeBuf, &cl->format, w, h);
-        len = 3;
-    } else if (cl->format.bitsPerPixel == 32) {
-        FilterGradient32(cl, (uint32_t *)tightBeforeBuf, &cl->format, w, h);
-        len = 4;
-    } else {
-        FilterGradient16(cl, (uint16_t *)tightBeforeBuf, &cl->format, w, h);
-        len = 2;
-    }
-
-    return CompressData(cl, streamId, w * h * len,
-                        tightConf[compressLevel].gradientZlibLevel,
-                        Z_FILTERED);
-}
-
-static rfbBool
-CompressData(rfbClientPtr cl,
-             int streamId,
-             int dataLen,
-             int zlibLevel,
-             int zlibStrategy)
-{
-    z_streamp pz;
-    int err;
-
-    if (dataLen < TIGHT_MIN_TO_COMPRESS) {
-        memcpy(&cl->updateBuf[cl->ublen], tightBeforeBuf, dataLen);
-        cl->ublen += dataLen;
-        rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, dataLen);
-        return TRUE;
-    }
-
-    pz = &cl->zsStruct[streamId];
-
-    /* Initialize compression stream if needed. */
-    if (!cl->zsActive[streamId]) {
-        pz->zalloc = Z_NULL;
-        pz->zfree = Z_NULL;
-        pz->opaque = Z_NULL;
-
-        err = deflateInit2 (pz, zlibLevel, Z_DEFLATED, MAX_WBITS,
-                            MAX_MEM_LEVEL, zlibStrategy);
-        if (err != Z_OK)
-            return FALSE;
-
-        cl->zsActive[streamId] = TRUE;
-        cl->zsLevel[streamId] = zlibLevel;
-    }
-
-    /* Prepare buffer pointers. */
-    pz->next_in = (Bytef *)tightBeforeBuf;
-    pz->avail_in = dataLen;
-    pz->next_out = (Bytef *)tightAfterBuf;
-    pz->avail_out = tightAfterBufSize;
-
-    /* Change compression parameters if needed. */
-    if (zlibLevel != cl->zsLevel[streamId]) {
-        if (deflateParams (pz, zlibLevel, zlibStrategy) != Z_OK) {
-            return FALSE;
-        }
-        cl->zsLevel[streamId] = zlibLevel;
-    }
-
-    /* Actual compression. */
-    if ( deflate (pz, Z_SYNC_FLUSH) != Z_OK ||
-         pz->avail_in != 0 || pz->avail_out == 0 ) {
-        return FALSE;
-    }
-
-    return SendCompressedData(cl, tightAfterBufSize - pz->avail_out);
-}
-
-static rfbBool SendCompressedData(rfbClientPtr cl,
-                                  int compressedLen)
-{
-    int i, portionLen;
-
-    cl->updateBuf[cl->ublen++] = compressedLen & 0x7F;
-    rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 1);
-    if (compressedLen > 0x7F) {
-        cl->updateBuf[cl->ublen-1] |= 0x80;
-        cl->updateBuf[cl->ublen++] = compressedLen >> 7 & 0x7F;
-        rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 1);
-        if (compressedLen > 0x3FFF) {
-            cl->updateBuf[cl->ublen-1] |= 0x80;
-            cl->updateBuf[cl->ublen++] = compressedLen >> 14 & 0xFF;
-            rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 1);
-        }
-    }
-
-    portionLen = UPDATE_BUF_SIZE;
-    for (i = 0; i < compressedLen; i += portionLen) {
-        if (i + portionLen > compressedLen) {
-            portionLen = compressedLen - i;
-        }
-        if (cl->ublen + portionLen > UPDATE_BUF_SIZE) {
-            if (!rfbSendUpdateBuf(cl))
-                return FALSE;
-        }
-        memcpy(&cl->updateBuf[cl->ublen], &tightAfterBuf[i], portionLen);
-        cl->ublen += portionLen;
-    }
-    rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, compressedLen);
-
-    return TRUE;
-}
-
-/*
- * Code to determine how many different colors used in rectangle.
- */
-
-static void
-FillPalette8(int count)
-{
-    uint8_t *data = (uint8_t *)tightBeforeBuf;
-    uint8_t c0, c1;
-    int i, n0, n1;
-
-    paletteNumColors = 0;
-
-    c0 = data[0];
-    for (i = 1; i < count && data[i] == c0; i++);
-    if (i == count) {
-        paletteNumColors = 1;
-        return;                 /* Solid rectangle */
-    }
-
-    if (paletteMaxColors < 2)
-        return;
-
-    n0 = i;
-    c1 = data[i];
-    n1 = 0;
-    for (i++; i < count; i++) {
-        if (data[i] == c0) {
-            n0++;
-        } else if (data[i] == c1) {
-            n1++;
-        } else
-            break;
-    }
-    if (i == count) {
-        if (n0 > n1) {
-            monoBackground = (uint32_t)c0;
-            monoForeground = (uint32_t)c1;
-        } else {
-            monoBackground = (uint32_t)c1;
-            monoForeground = (uint32_t)c0;
-        }
-        paletteNumColors = 2;   /* Two colors */
-    }
-}
-
-#define DEFINE_FILL_PALETTE_FUNCTION(bpp)                               \
-                                                                        \
-static void                                                             \
-FillPalette##bpp(int count) {                                           \
-    uint##bpp##_t *data = (uint##bpp##_t *)tightBeforeBuf;              \
-    uint##bpp##_t c0, c1, ci;                                           \
-    int i, n0, n1, ni;                                                  \
-                                                                        \
-    c0 = data[0];                                                       \
-    for (i = 1; i < count && data[i] == c0; i++);                       \
-    if (i >= count) {                                                   \
-        paletteNumColors = 1;   /* Solid rectangle */                   \
-        return;                                                         \
-    }                                                                   \
-                                                                        \
-    if (paletteMaxColors < 2) {                                         \
-        paletteNumColors = 0;   /* Full-color encoding preferred */     \
-        return;                                                         \
-    }                                                                   \
-                                                                        \
-    n0 = i;                                                             \
-    c1 = data[i];                                                       \
-    n1 = 0;                                                             \
-    for (i++; i < count; i++) {                                         \
-        ci = data[i];                                                   \
-        if (ci == c0) {                                                 \
-            n0++;                                                       \
-        } else if (ci == c1) {                                          \
-            n1++;                                                       \
-        } else                                                          \
-            break;                                                      \
-    }                                                                   \
-    if (i >= count) {                                                   \
-        if (n0 > n1) {                                                  \
-            monoBackground = (uint32_t)c0;                              \
-            monoForeground = (uint32_t)c1;                              \
-        } else {                                                        \
-            monoBackground = (uint32_t)c1;                              \
-            monoForeground = (uint32_t)c0;                              \
-        }                                                               \
-        paletteNumColors = 2;   /* Two colors */                        \
-        return;                                                         \
-    }                                                                   \
-                                                                        \
-    PaletteReset();                                                     \
-    PaletteInsert (c0, (uint32_t)n0, bpp);                              \
-    PaletteInsert (c1, (uint32_t)n1, bpp);                              \
-                                                                        \
-    ni = 1;                                                             \
-    for (i++; i < count; i++) {                                         \
-        if (data[i] == ci) {                                            \
-            ni++;                                                       \
-        } else {                                                        \
-            if (!PaletteInsert (ci, (uint32_t)ni, bpp))                 \
-                return;                                                 \
-            ci = data[i];                                               \
-            ni = 1;                                                     \
-        }                                                               \
-    }                                                                   \
-    PaletteInsert (ci, (uint32_t)ni, bpp);                              \
-}
-
-DEFINE_FILL_PALETTE_FUNCTION(16)
-DEFINE_FILL_PALETTE_FUNCTION(32)
-
-
-/*
- * Functions to operate with palette structures.
- */
-
-#define HASH_FUNC16(rgb) ((int)(((rgb >> 8) + rgb) & 0xFF))
-#define HASH_FUNC32(rgb) ((int)(((rgb >> 16) + (rgb >> 8)) & 0xFF))
-
-static void
-PaletteReset(void)
-{
-    paletteNumColors = 0;
-    memset(palette.hash, 0, 256 * sizeof(COLOR_LIST *));
-}
-
-static int
-PaletteInsert(uint32_t rgb,
-              int numPixels,
-              int bpp)
-{
-    COLOR_LIST *pnode;
-    COLOR_LIST *prev_pnode = NULL;
-    int hash_key, idx, new_idx, count;
-
-    hash_key = (bpp == 16) ? HASH_FUNC16(rgb) : HASH_FUNC32(rgb);
-
-    pnode = palette.hash[hash_key];
-
-    while (pnode != NULL) {
-        if (pnode->rgb == rgb) {
-            /* Such palette entry already exists. */
-            new_idx = idx = pnode->idx;
-            count = palette.entry[idx].numPixels + numPixels;
-            if (new_idx && palette.entry[new_idx-1].numPixels < count) {
-                do {
-                    palette.entry[new_idx] = palette.entry[new_idx-1];
-                    palette.entry[new_idx].listNode->idx = new_idx;
-                    new_idx--;
-                }
-                while (new_idx && palette.entry[new_idx-1].numPixels < count);
-                palette.entry[new_idx].listNode = pnode;
-                pnode->idx = new_idx;
-            }
-            palette.entry[new_idx].numPixels = count;
-            return paletteNumColors;
-        }
-        prev_pnode = pnode;
-        pnode = pnode->next;
-    }
-
-    /* Check if palette is full. */
-    if (paletteNumColors == 256 || paletteNumColors == paletteMaxColors) {
-        paletteNumColors = 0;
-        return 0;
-    }
-
-    /* Move palette entries with lesser pixel counts. */
-    for ( idx = paletteNumColors;
-          idx > 0 && palette.entry[idx-1].numPixels < numPixels;
-          idx-- ) {
-        palette.entry[idx] = palette.entry[idx-1];
-        palette.entry[idx].listNode->idx = idx;
-    }
-
-    /* Add new palette entry into the freed slot. */
-    pnode = &palette.list[paletteNumColors];
-    if (prev_pnode != NULL) {
-        prev_pnode->next = pnode;
-    } else {
-        palette.hash[hash_key] = pnode;
-    }
-    pnode->next = NULL;
-    pnode->idx = idx;
-    pnode->rgb = rgb;
-    palette.entry[idx].listNode = pnode;
-    palette.entry[idx].numPixels = numPixels;
-
-    return (++paletteNumColors);
-}
-
-
-/*
- * Converting 32-bit color samples into 24-bit colors.
- * Should be called only when redMax, greenMax and blueMax are 255.
- * Color components assumed to be byte-aligned.
- */
-
-static void Pack24(rfbClientPtr cl,
-                   char *buf,
-                   rfbPixelFormat *fmt,
-                   int count)
-{
-    uint32_t *buf32;
-    uint32_t pix;
-    int r_shift, g_shift, b_shift;
-
-    buf32 = (uint32_t *)buf;
-
-    if (!cl->screen->serverFormat.bigEndian == !fmt->bigEndian) {
-        r_shift = fmt->redShift;
-        g_shift = fmt->greenShift;
-        b_shift = fmt->blueShift;
-    } else {
-        r_shift = 24 - fmt->redShift;
-        g_shift = 24 - fmt->greenShift;
-        b_shift = 24 - fmt->blueShift;
-    }
-
-    while (count--) {
-        pix = *buf32++;
-        *buf++ = (char)(pix >> r_shift);
-        *buf++ = (char)(pix >> g_shift);
-        *buf++ = (char)(pix >> b_shift);
-    }
-}
-
-
-/*
- * Converting truecolor samples into palette indices.
- */
-
-#define DEFINE_IDX_ENCODE_FUNCTION(bpp)                                 \
-                                                                        \
-static void                                                             \
-EncodeIndexedRect##bpp(uint8_t *buf, int count) {                       \
-    COLOR_LIST *pnode;                                                  \
-    uint##bpp##_t *src;                                                 \
-    uint##bpp##_t rgb;                                                  \
-    int rep = 0;                                                        \
-                                                                        \
-    src = (uint##bpp##_t *) buf;                                        \
-                                                                        \
-    while (count--) {                                                   \
-        rgb = *src++;                                                   \
-        while (count && *src == rgb) {                                  \
-            rep++, src++, count--;                                      \
-        }                                                               \
-        pnode = palette.hash[HASH_FUNC##bpp(rgb)];                      \
-        while (pnode != NULL) {                                         \
-            if ((uint##bpp##_t)pnode->rgb == rgb) {                     \
-                *buf++ = (uint8_t)pnode->idx;                           \
-                while (rep) {                                           \
-                    *buf++ = (uint8_t)pnode->idx;                       \
-                    rep--;                                              \
-                }                                                       \
-                break;                                                  \
-            }                                                           \
-            pnode = pnode->next;                                        \
-        }                                                               \
-    }                                                                   \
-}
-
-DEFINE_IDX_ENCODE_FUNCTION(16)
-DEFINE_IDX_ENCODE_FUNCTION(32)
-
-#define DEFINE_MONO_ENCODE_FUNCTION(bpp)                                \
-                                                                        \
-static void                                                             \
-EncodeMonoRect##bpp(uint8_t *buf, int w, int h) {                       \
-    uint##bpp##_t *ptr;                                                 \
-    uint##bpp##_t bg;                                                   \
-    unsigned int value, mask;                                           \
-    int aligned_width;                                                  \
-    int x, y, bg_bits;                                                  \
-                                                                        \
-    ptr = (uint##bpp##_t *) buf;                                        \
-    bg = (uint##bpp##_t) monoBackground;                                \
-    aligned_width = w - w % 8;                                          \
-                                                                        \
-    for (y = 0; y < h; y++) {                                           \
-        for (x = 0; x < aligned_width; x += 8) {                        \
-            for (bg_bits = 0; bg_bits < 8; bg_bits++) {                 \
-                if (*ptr++ != bg)                                       \
-                    break;                                              \
-            }                                                           \
-            if (bg_bits == 8) {                                         \
-                *buf++ = 0;                                             \
-                continue;                                               \
-            }                                                           \
-            mask = 0x80 >> bg_bits;                                     \
-            value = mask;                                               \
-            for (bg_bits++; bg_bits < 8; bg_bits++) {                   \
-                mask >>= 1;                                             \
-                if (*ptr++ != bg) {                                     \
-                    value |= mask;                                      \
-                }                                                       \
-            }                                                           \
-            *buf++ = (uint8_t)value;                                    \
-        }                                                               \
-                                                                        \
-        mask = 0x80;                                                    \
-        value = 0;                                                      \
-        if (x >= w)                                                     \
-            continue;                                                   \
-                                                                        \
-        for (; x < w; x++) {                                            \
-            if (*ptr++ != bg) {                                         \
-                value |= mask;                                          \
-            }                                                           \
-            mask >>= 1;                                                 \
-        }                                                               \
-        *buf++ = (uint8_t)value;                                        \
-    }                                                                   \
-}
-
-DEFINE_MONO_ENCODE_FUNCTION(8)
-DEFINE_MONO_ENCODE_FUNCTION(16)
-DEFINE_MONO_ENCODE_FUNCTION(32)
-
-
-/*
- * ``Gradient'' filter for 24-bit color samples.
- * Should be called only when redMax, greenMax and blueMax are 255.
- * Color components assumed to be byte-aligned.
- */
-
-static void
-FilterGradient24(rfbClientPtr cl, char *buf, rfbPixelFormat *fmt, int w, int h)
-{
-    uint32_t *buf32;
-    uint32_t pix32;
-    int *prevRowPtr;
-    int shiftBits[3];
-    int pixHere[3], pixUpper[3], pixLeft[3], pixUpperLeft[3];
-    int prediction;
-    int x, y, c;
-
-    buf32 = (uint32_t *)buf;
-    memset (prevRowBuf, 0, w * 3 * sizeof(int));
-
-    if (!cl->screen->serverFormat.bigEndian == !fmt->bigEndian) {
-        shiftBits[0] = fmt->redShift;
-        shiftBits[1] = fmt->greenShift;
-        shiftBits[2] = fmt->blueShift;
-    } else {
-        shiftBits[0] = 24 - fmt->redShift;
-        shiftBits[1] = 24 - fmt->greenShift;
-        shiftBits[2] = 24 - fmt->blueShift;
-    }
-
-    for (y = 0; y < h; y++) {
-        for (c = 0; c < 3; c++) {
-            pixUpper[c] = 0;
-            pixHere[c] = 0;
-        }
-        prevRowPtr = prevRowBuf;
-        for (x = 0; x < w; x++) {
-            pix32 = *buf32++;
-            for (c = 0; c < 3; c++) {
-                pixUpperLeft[c] = pixUpper[c];
-                pixLeft[c] = pixHere[c];
-                pixUpper[c] = *prevRowPtr;
-                pixHere[c] = (int)(pix32 >> shiftBits[c] & 0xFF);
-                *prevRowPtr++ = pixHere[c];
-
-                prediction = pixLeft[c] + pixUpper[c] - pixUpperLeft[c];
-                if (prediction < 0) {
-                    prediction = 0;
-                } else if (prediction > 0xFF) {
-                    prediction = 0xFF;
-                }
-                *buf++ = (char)(pixHere[c] - prediction);
-            }
-        }
-    }
-}
-
-
-/*
- * ``Gradient'' filter for other color depths.
- */
-
-#define DEFINE_GRADIENT_FILTER_FUNCTION(bpp)                             \
-                                                                         \
-static void                                                              \
-FilterGradient##bpp(rfbClientPtr cl, uint##bpp##_t *buf,                 \
-		rfbPixelFormat *fmt, int w, int h) {                     \
-    uint##bpp##_t pix, diff;                                             \
-    rfbBool endianMismatch;                                              \
-    int *prevRowPtr;                                                     \
-    int maxColor[3], shiftBits[3];                                       \
-    int pixHere[3], pixUpper[3], pixLeft[3], pixUpperLeft[3];            \
-    int prediction;                                                      \
-    int x, y, c;                                                         \
-                                                                         \
-    memset (prevRowBuf, 0, w * 3 * sizeof(int));                         \
-                                                                         \
-    endianMismatch = (!cl->screen->serverFormat.bigEndian != !fmt->bigEndian);    \
-                                                                         \
-    maxColor[0] = fmt->redMax;                                           \
-    maxColor[1] = fmt->greenMax;                                         \
-    maxColor[2] = fmt->blueMax;                                          \
-    shiftBits[0] = fmt->redShift;                                        \
-    shiftBits[1] = fmt->greenShift;                                      \
-    shiftBits[2] = fmt->blueShift;                                       \
-                                                                         \
-    for (y = 0; y < h; y++) {                                            \
-        for (c = 0; c < 3; c++) {                                        \
-            pixUpper[c] = 0;                                             \
-            pixHere[c] = 0;                                              \
-        }                                                                \
-        prevRowPtr = prevRowBuf;                                         \
-        for (x = 0; x < w; x++) {                                        \
-            pix = *buf;                                                  \
-            if (endianMismatch) {                                        \
-                pix = Swap##bpp(pix);                                    \
-            }                                                            \
-            diff = 0;                                                    \
-            for (c = 0; c < 3; c++) {                                    \
-                pixUpperLeft[c] = pixUpper[c];                           \
-                pixLeft[c] = pixHere[c];                                 \
-                pixUpper[c] = *prevRowPtr;                               \
-                pixHere[c] = (int)(pix >> shiftBits[c] & maxColor[c]);   \
-                *prevRowPtr++ = pixHere[c];                              \
-                                                                         \
-                prediction = pixLeft[c] + pixUpper[c] - pixUpperLeft[c]; \
-                if (prediction < 0) {                                    \
-                    prediction = 0;                                      \
-                } else if (prediction > maxColor[c]) {                   \
-                    prediction = maxColor[c];                            \
-                }                                                        \
-                diff |= ((pixHere[c] - prediction) & maxColor[c])        \
-                    << shiftBits[c];                                     \
-            }                                                            \
-            if (endianMismatch) {                                        \
-                diff = Swap##bpp(diff);                                  \
-            }                                                            \
-            *buf++ = diff;                                               \
-        }                                                                \
-    }                                                                    \
-}
-
-DEFINE_GRADIENT_FILTER_FUNCTION(16)
-DEFINE_GRADIENT_FILTER_FUNCTION(32)
-
-
-/*
- * Code to guess if given rectangle is suitable for smooth image
- * compression (by applying "gradient" filter or JPEG coder).
- */
-
-#define JPEG_MIN_RECT_SIZE  4096
-
-#define DETECT_SUBROW_WIDTH    7
-#define DETECT_MIN_WIDTH       8
-#define DETECT_MIN_HEIGHT      8
-
-static int
-DetectSmoothImage (rfbClientPtr cl, rfbPixelFormat *fmt, int w, int h)
-{
-    long avgError;
-
-    if ( cl->screen->serverFormat.bitsPerPixel == 8 || fmt->bitsPerPixel == 8 ||
-         w < DETECT_MIN_WIDTH || h < DETECT_MIN_HEIGHT ) {
-        return 0;
-    }
-
-    if (qualityLevel != -1) {
-        if (w * h < JPEG_MIN_RECT_SIZE) {
-            return 0;
-        }
-    } else {
-        if ( rfbTightDisableGradient ||
-             w * h < tightConf[compressLevel].gradientMinRectSize ) {
-            return 0;
-        }
-    }
-
-    if (fmt->bitsPerPixel == 32) {
-        if (usePixelFormat24) {
-            avgError = DetectSmoothImage24(cl, fmt, w, h);
-            if (qualityLevel != -1) {
-                return (avgError < tightConf[qualityLevel].jpegThreshold24);
-            }
-            return (avgError < tightConf[compressLevel].gradientThreshold24);
-        } else {
-            avgError = DetectSmoothImage32(cl, fmt, w, h);
-        }
-    } else {
-        avgError = DetectSmoothImage16(cl, fmt, w, h);
-    }
-    if (qualityLevel != -1) {
-        return (avgError < tightConf[qualityLevel].jpegThreshold);
-    }
-    return (avgError < tightConf[compressLevel].gradientThreshold);
-}
-
-static unsigned long
-DetectSmoothImage24 (rfbClientPtr cl,
-                     rfbPixelFormat *fmt,
-                     int w,
-                     int h)
-{
-    int off;
-    int x, y, d, dx, c;
-    int diffStat[256];
-    int pixelCount = 0;
-    int pix, left[3];
-    unsigned long avgError;
-
-    /* If client is big-endian, color samples begin from the second
-       byte (offset 1) of a 32-bit pixel value. */
-    off = (fmt->bigEndian != 0);
-
-    memset(diffStat, 0, 256*sizeof(int));
-
-    y = 0, x = 0;
-    while (y < h && x < w) {
-        for (d = 0; d < h - y && d < w - x - DETECT_SUBROW_WIDTH; d++) {
-            for (c = 0; c < 3; c++) {
-                left[c] = (int)tightBeforeBuf[((y+d)*w+x+d)*4+off+c] & 0xFF;
-            }
-            for (dx = 1; dx <= DETECT_SUBROW_WIDTH; dx++) {
-                for (c = 0; c < 3; c++) {
-                    pix = (int)tightBeforeBuf[((y+d)*w+x+d+dx)*4+off+c] & 0xFF;
-                    diffStat[abs(pix - left[c])]++;
-                    left[c] = pix;
-                }
-                pixelCount++;
-            }
-        }
-        if (w > h) {
-            x += h;
-            y = 0;
-        } else {
-            x = 0;
-            y += w;
-        }
-    }
-
-    if (diffStat[0] * 33 / pixelCount >= 95)
-        return 0;
-
-    avgError = 0;
-    for (c = 1; c < 8; c++) {
-        avgError += (unsigned long)diffStat[c] * (unsigned long)(c * c);
-        if (diffStat[c] == 0 || diffStat[c] > diffStat[c-1] * 2)
-            return 0;
-    }
-    for (; c < 256; c++) {
-        avgError += (unsigned long)diffStat[c] * (unsigned long)(c * c);
-    }
-    avgError /= (pixelCount * 3 - diffStat[0]);
-
-    return avgError;
-}
-
-#define DEFINE_DETECT_FUNCTION(bpp)                                          \
-                                                                             \
-static unsigned long                                                         \
-DetectSmoothImage##bpp (rfbClientPtr cl, rfbPixelFormat *fmt, int w, int h) {\
-    rfbBool endianMismatch;                                                  \
-    uint##bpp##_t pix;                                                       \
-    int maxColor[3], shiftBits[3];                                           \
-    int x, y, d, dx, c;                                                      \
-    int diffStat[256];                                                       \
-    int pixelCount = 0;                                                      \
-    int sample, sum, left[3];                                                \
-    unsigned long avgError;                                                  \
-                                                                             \
-    endianMismatch = (!cl->screen->serverFormat.bigEndian != !fmt->bigEndian); \
-                                                                             \
-    maxColor[0] = fmt->redMax;                                               \
-    maxColor[1] = fmt->greenMax;                                             \
-    maxColor[2] = fmt->blueMax;                                              \
-    shiftBits[0] = fmt->redShift;                                            \
-    shiftBits[1] = fmt->greenShift;                                          \
-    shiftBits[2] = fmt->blueShift;                                           \
-                                                                             \
-    memset(diffStat, 0, 256*sizeof(int));                                    \
-                                                                             \
-    y = 0, x = 0;                                                            \
-    while (y < h && x < w) {                                                 \
-        for (d = 0; d < h - y && d < w - x - DETECT_SUBROW_WIDTH; d++) {     \
-            pix = ((uint##bpp##_t *)tightBeforeBuf)[(y+d)*w+x+d];            \
-            if (endianMismatch) {                                            \
-                pix = Swap##bpp(pix);                                        \
-            }                                                                \
-            for (c = 0; c < 3; c++) {                                        \
-                left[c] = (int)(pix >> shiftBits[c] & maxColor[c]);          \
-            }                                                                \
-            for (dx = 1; dx <= DETECT_SUBROW_WIDTH; dx++) {                  \
-                pix = ((uint##bpp##_t *)tightBeforeBuf)[(y+d)*w+x+d+dx];     \
-                if (endianMismatch) {                                        \
-                    pix = Swap##bpp(pix);                                    \
-                }                                                            \
-                sum = 0;                                                     \
-                for (c = 0; c < 3; c++) {                                    \
-                    sample = (int)(pix >> shiftBits[c] & maxColor[c]);       \
-                    sum += abs(sample - left[c]);                            \
-                    left[c] = sample;                                        \
-                }                                                            \
-                if (sum > 255)                                               \
-                    sum = 255;                                               \
-                diffStat[sum]++;                                             \
-                pixelCount++;                                                \
-            }                                                                \
-        }                                                                    \
-        if (w > h) {                                                         \
-            x += h;                                                          \
-            y = 0;                                                           \
-        } else {                                                             \
-            x = 0;                                                           \
-            y += w;                                                          \
-        }                                                                    \
-    }                                                                        \
-                                                                             \
-    if ((diffStat[0] + diffStat[1]) * 100 / pixelCount >= 90)                \
-        return 0;                                                            \
-                                                                             \
-    avgError = 0;                                                            \
-    for (c = 1; c < 8; c++) {                                                \
-        avgError += (unsigned long)diffStat[c] * (unsigned long)(c * c);     \
-        if (diffStat[c] == 0 || diffStat[c] > diffStat[c-1] * 2)             \
-            return 0;                                                        \
-    }                                                                        \
-    for (; c < 256; c++) {                                                   \
-        avgError += (unsigned long)diffStat[c] * (unsigned long)(c * c);     \
-    }                                                                        \
-    avgError /= (pixelCount - diffStat[0]);                                  \
-                                                                             \
-    return avgError;                                                         \
-}
-
-DEFINE_DETECT_FUNCTION(16)
-DEFINE_DETECT_FUNCTION(32)
-
-
-/*
- * JPEG compression stuff.
- */
-
-static TLS struct jpeg_destination_mgr jpegDstManager;
-static TLS rfbBool jpegError = FALSE;
-static TLS int jpegDstDataLen = 0;
-
-static rfbBool
-SendJpegRect(rfbClientPtr cl, int x, int y, int w, int h, int quality)
-{
-    struct jpeg_compress_struct cinfo;
-    struct jpeg_error_mgr jerr;
-    uint8_t *srcBuf;
-    JSAMPROW rowPointer[1];
-    int dy;
-
-    if (cl->screen->serverFormat.bitsPerPixel == 8)
-        return SendFullColorRect(cl, w, h);
-
-    srcBuf = (uint8_t *)malloc(w * 3);
-    if (srcBuf == NULL) {
-        return SendFullColorRect(cl, w, h);
-    }
-    rowPointer[0] = srcBuf;
-
-    cinfo.err = jpeg_std_error(&jerr);
-    jpeg_create_compress(&cinfo);
-
-    cinfo.image_width = w;
-    cinfo.image_height = h;
-    cinfo.input_components = 3;
-    cinfo.in_color_space = JCS_RGB;
-
-    jpeg_set_defaults(&cinfo);
-    jpeg_set_quality(&cinfo, quality, TRUE);
-
-    JpegSetDstManager (&cinfo);
-
-    jpeg_start_compress(&cinfo, TRUE);
-
-    for (dy = 0; dy < h; dy++) {
-        PrepareRowForJpeg(cl, srcBuf, x, y + dy, w);
-        jpeg_write_scanlines(&cinfo, rowPointer, 1);
-        if (jpegError)
-            break;
-    }
-
-    if (!jpegError)
-        jpeg_finish_compress(&cinfo);
-
-    jpeg_destroy_compress(&cinfo);
-    free(srcBuf);
-
-    if (jpegError)
-        return SendFullColorRect(cl, w, h);
-
-    if (cl->ublen + TIGHT_MIN_TO_COMPRESS + 1 > UPDATE_BUF_SIZE) {
-        if (!rfbSendUpdateBuf(cl))
-            return FALSE;
-    }
-
-    cl->updateBuf[cl->ublen++] = (char)(rfbTightJpeg << 4);
-    rfbStatRecordEncodingSentAdd(cl, rfbEncodingTight, 1);
-
-    return SendCompressedData(cl, jpegDstDataLen);
-}
-
-static void
-PrepareRowForJpeg(rfbClientPtr cl,
-                  uint8_t *dst,
-                  int x,
-                  int y,
-                  int count)
-{
-    if (cl->screen->serverFormat.bitsPerPixel == 32) {
-        if ( cl->screen->serverFormat.redMax == 0xFF &&
-             cl->screen->serverFormat.greenMax == 0xFF &&
-             cl->screen->serverFormat.blueMax == 0xFF ) {
-            PrepareRowForJpeg24(cl, dst, x, y, count);
-        } else {
-            PrepareRowForJpeg32(cl, dst, x, y, count);
-        }
-    } else {
-        /* 16 bpp assumed. */
-        PrepareRowForJpeg16(cl, dst, x, y, count);
-    }
-}
-
-static void
-PrepareRowForJpeg24(rfbClientPtr cl,
-                    uint8_t *dst,
-                    int x,
-                    int y,
-                    int count)
-{
-    uint32_t *fbptr;
-    uint32_t pix;
-
-    fbptr = (uint32_t *)
-        &cl->scaledScreen->frameBuffer[y * cl->scaledScreen->paddedWidthInBytes + x * 4];
-
-    while (count--) {
-        pix = *fbptr++;
-        *dst++ = (uint8_t)(pix >> cl->screen->serverFormat.redShift);
-        *dst++ = (uint8_t)(pix >> cl->screen->serverFormat.greenShift);
-        *dst++ = (uint8_t)(pix >> cl->screen->serverFormat.blueShift);
-    }
-}
-
-#define DEFINE_JPEG_GET_ROW_FUNCTION(bpp)                                   \
-                                                                            \
-static void                                                                 \
-PrepareRowForJpeg##bpp(rfbClientPtr cl, uint8_t *dst, int x, int y, int count) { \
-    uint##bpp##_t *fbptr;                                                   \
-    uint##bpp##_t pix;                                                      \
-    int inRed, inGreen, inBlue;                                             \
-                                                                            \
-    fbptr = (uint##bpp##_t *)                                               \
-        &cl->scaledScreen->frameBuffer[y * cl->scaledScreen->paddedWidthInBytes +       \
-                             x * (bpp / 8)];                                \
-                                                                            \
-    while (count--) {                                                       \
-        pix = *fbptr++;                                                     \
-                                                                            \
-        inRed = (int)                                                       \
-            (pix >> cl->screen->serverFormat.redShift   & cl->screen->serverFormat.redMax); \
-        inGreen = (int)                                                     \
-            (pix >> cl->screen->serverFormat.greenShift & cl->screen->serverFormat.greenMax); \
-        inBlue  = (int)                                                     \
-            (pix >> cl->screen->serverFormat.blueShift  & cl->screen->serverFormat.blueMax); \
-                                                                            \
-	*dst++ = (uint8_t)((inRed   * 255 + cl->screen->serverFormat.redMax / 2) / \
-                         cl->screen->serverFormat.redMax);                  \
-	*dst++ = (uint8_t)((inGreen * 255 + cl->screen->serverFormat.greenMax / 2) / \
-                         cl->screen->serverFormat.greenMax);                \
-	*dst++ = (uint8_t)((inBlue  * 255 + cl->screen->serverFormat.blueMax / 2) / \
-                         cl->screen->serverFormat.blueMax);                 \
-    }                                                                       \
-}
-
-DEFINE_JPEG_GET_ROW_FUNCTION(16)
-DEFINE_JPEG_GET_ROW_FUNCTION(32)
-
-/*
- * Destination manager implementation for JPEG library.
- */
-
-static void
-JpegInitDestination(j_compress_ptr cinfo)
-{
-    jpegError = FALSE;
-    jpegDstManager.next_output_byte = (JOCTET *)tightAfterBuf;
-    jpegDstManager.free_in_buffer = (size_t)tightAfterBufSize;
-}
-
-static boolean
-JpegEmptyOutputBuffer(j_compress_ptr cinfo)
-{
-    jpegError = TRUE;
-    jpegDstManager.next_output_byte = (JOCTET *)tightAfterBuf;
-    jpegDstManager.free_in_buffer = (size_t)tightAfterBufSize;
-
-    return TRUE;
-}
-
-static void
-JpegTermDestination(j_compress_ptr cinfo)
-{
-    jpegDstDataLen = tightAfterBufSize - jpegDstManager.free_in_buffer;
-}
-
-static void
-JpegSetDstManager(j_compress_ptr cinfo)
-{
-    jpegDstManager.init_destination = JpegInitDestination;
-    jpegDstManager.empty_output_buffer = JpegEmptyOutputBuffer;
-    jpegDstManager.term_destination = JpegTermDestination;
-    cinfo->dest = &jpegDstManager;
-}
-
diff --git a/libvncserver/translate.c b/libvncserver/translate.c
deleted file mode 100644
index 6e14e27..0000000
--- a/libvncserver/translate.c
+++ /dev/null
@@ -1,477 +0,0 @@
-/*
- * translate.c - translate between different pixel formats
- */
-
-/*
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include "rfb/rfb.h"
-#include "rfb/rfbregion.h"
-
-static void PrintPixelFormat(rfbPixelFormat *pf);
-static rfbBool rfbSetClientColourMapBGR233(rfbClientPtr cl);
-
-rfbBool rfbEconomicTranslate = FALSE;
-
-/*
- * Some standard pixel formats.
- */
-
-static const rfbPixelFormat BGR233Format = {
-    8, 8, 0, 1, 7, 7, 3, 0, 3, 6, 0, 0
-};
-
-
-/*
- * Macro to compare pixel formats.
- */
-
-#define PF_EQ(x,y)                                                      \
-        ((x.bitsPerPixel == y.bitsPerPixel) &&                          \
-         (x.depth == y.depth) &&                                        \
-         ((x.bigEndian == y.bigEndian) || (x.bitsPerPixel == 8)) &&     \
-         (x.trueColour == y.trueColour) &&                              \
-         (!x.trueColour || ((x.redMax == y.redMax) &&                   \
-                            (x.greenMax == y.greenMax) &&               \
-                            (x.blueMax == y.blueMax) &&                 \
-                            (x.redShift == y.redShift) &&               \
-                            (x.greenShift == y.greenShift) &&           \
-                            (x.blueShift == y.blueShift))))
-
-#define CONCAT2(a,b) a##b
-#define CONCAT2E(a,b) CONCAT2(a,b)
-#define CONCAT3(a,b,c) a##b##c
-#define CONCAT3E(a,b,c) CONCAT3(a,b,c)
-#define CONCAT4(a,b,c,d) a##b##c##d
-#define CONCAT4E(a,b,c,d) CONCAT4(a,b,c,d)
-
-#undef OUT
-#undef IN
-
-#define OUT 8
-#include "tableinitcmtemplate.c"
-#include "tableinittctemplate.c"
-#define IN 8
-#include "tabletranstemplate.c"
-#undef IN
-#define IN 16
-#include "tabletranstemplate.c"
-#undef IN
-#define IN 32
-#include "tabletranstemplate.c"
-#undef IN
-#undef OUT
-
-#define OUT 16
-#include "tableinitcmtemplate.c"
-#include "tableinittctemplate.c"
-#define IN 8
-#include "tabletranstemplate.c"
-#undef IN
-#define IN 16
-#include "tabletranstemplate.c"
-#undef IN
-#define IN 32
-#include "tabletranstemplate.c"
-#undef IN
-#undef OUT
-
-#define OUT 32
-#include "tableinitcmtemplate.c"
-#include "tableinittctemplate.c"
-#define IN 8
-#include "tabletranstemplate.c"
-#undef IN
-#define IN 16
-#include "tabletranstemplate.c"
-#undef IN
-#define IN 32
-#include "tabletranstemplate.c"
-#undef IN
-#undef OUT
-
-#ifdef LIBVNCSERVER_ALLOW24BPP
-#define COUNT_OFFSETS 4
-#define BPP2OFFSET(bpp) ((bpp)/8-1)
-#include "tableinit24.c"
-#define BPP 8
-#include "tabletrans24template.c"
-#undef BPP
-#define BPP 16
-#include "tabletrans24template.c"
-#undef BPP
-#define BPP 24
-#include "tabletrans24template.c"
-#undef BPP
-#define BPP 32
-#include "tabletrans24template.c"
-#undef BPP
-#else
-#define COUNT_OFFSETS 3
-#define BPP2OFFSET(bpp) ((int)(bpp)/16)
-#endif
-
-typedef void (*rfbInitCMTableFnType)(char **table, rfbPixelFormat *in,
-                                   rfbPixelFormat *out,rfbColourMap* cm);
-typedef void (*rfbInitTableFnType)(char **table, rfbPixelFormat *in,
-                                   rfbPixelFormat *out);
-
-static rfbInitCMTableFnType rfbInitColourMapSingleTableFns[COUNT_OFFSETS] = {
-    rfbInitColourMapSingleTable8,
-    rfbInitColourMapSingleTable16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-    rfbInitColourMapSingleTable24,
-#endif
-    rfbInitColourMapSingleTable32
-};
-
-static rfbInitTableFnType rfbInitTrueColourSingleTableFns[COUNT_OFFSETS] = {
-    rfbInitTrueColourSingleTable8,
-    rfbInitTrueColourSingleTable16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-    rfbInitTrueColourSingleTable24,
-#endif
-    rfbInitTrueColourSingleTable32
-};
-
-static rfbInitTableFnType rfbInitTrueColourRGBTablesFns[COUNT_OFFSETS] = {
-    rfbInitTrueColourRGBTables8,
-    rfbInitTrueColourRGBTables16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-    rfbInitTrueColourRGBTables24,
-#endif
-    rfbInitTrueColourRGBTables32
-};
-
-static rfbTranslateFnType rfbTranslateWithSingleTableFns[COUNT_OFFSETS][COUNT_OFFSETS] = {
-    { rfbTranslateWithSingleTable8to8,
-      rfbTranslateWithSingleTable8to16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-      rfbTranslateWithSingleTable8to24,
-#endif
-      rfbTranslateWithSingleTable8to32 },
-    { rfbTranslateWithSingleTable16to8,
-      rfbTranslateWithSingleTable16to16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-      rfbTranslateWithSingleTable16to24,
-#endif
-      rfbTranslateWithSingleTable16to32 },
-#ifdef LIBVNCSERVER_ALLOW24BPP
-    { rfbTranslateWithSingleTable24to8,
-      rfbTranslateWithSingleTable24to16,
-      rfbTranslateWithSingleTable24to24,
-      rfbTranslateWithSingleTable24to32 },
-#endif
-    { rfbTranslateWithSingleTable32to8,
-      rfbTranslateWithSingleTable32to16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-      rfbTranslateWithSingleTable32to24,
-#endif
-      rfbTranslateWithSingleTable32to32 }
-};
-
-static rfbTranslateFnType rfbTranslateWithRGBTablesFns[COUNT_OFFSETS][COUNT_OFFSETS] = {
-    { rfbTranslateWithRGBTables8to8,
-      rfbTranslateWithRGBTables8to16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-      rfbTranslateWithRGBTables8to24,
-#endif
-      rfbTranslateWithRGBTables8to32 },
-    { rfbTranslateWithRGBTables16to8,
-      rfbTranslateWithRGBTables16to16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-      rfbTranslateWithRGBTables16to24,
-#endif
-      rfbTranslateWithRGBTables16to32 },
-#ifdef LIBVNCSERVER_ALLOW24BPP
-    { rfbTranslateWithRGBTables24to8,
-      rfbTranslateWithRGBTables24to16,
-      rfbTranslateWithRGBTables24to24,
-      rfbTranslateWithRGBTables24to32 },
-#endif
-    { rfbTranslateWithRGBTables32to8,
-      rfbTranslateWithRGBTables32to16,
-#ifdef LIBVNCSERVER_ALLOW24BPP
-      rfbTranslateWithRGBTables32to24,
-#endif
-      rfbTranslateWithRGBTables32to32 }
-};
-
-
-
-/*
- * rfbTranslateNone is used when no translation is required.
- */
-
-void
-rfbTranslateNone(char *table, rfbPixelFormat *in, rfbPixelFormat *out,
-                 char *iptr, char *optr, int bytesBetweenInputLines,
-                 int width, int height)
-{
-    int bytesPerOutputLine = width * (out->bitsPerPixel / 8);
-
-    while (height > 0) {
-        memcpy(optr, iptr, bytesPerOutputLine);
-        iptr += bytesBetweenInputLines;
-        optr += bytesPerOutputLine;
-        height--;
-    }
-}
-
-
-/*
- * rfbSetTranslateFunction sets the translation function.
- */
-
-rfbBool
-rfbSetTranslateFunction(rfbClientPtr cl)
-{
-    rfbLog("Pixel format for client %s:\n",cl->host);
-    PrintPixelFormat(&cl->format);
-
-    /*
-     * Check that bits per pixel values are valid
-     */
-
-    if ((cl->screen->serverFormat.bitsPerPixel != 8) &&
-        (cl->screen->serverFormat.bitsPerPixel != 16) &&
-#ifdef LIBVNCSERVER_ALLOW24BPP
-	(cl->screen->serverFormat.bitsPerPixel != 24) &&
-#endif
-        (cl->screen->serverFormat.bitsPerPixel != 32))
-    {
-        rfbErr("%s: server bits per pixel not 8, 16 or 32 (is %d)\n",
-	       "rfbSetTranslateFunction", 
-	       cl->screen->serverFormat.bitsPerPixel);
-        rfbCloseClient(cl);
-        return FALSE;
-    }
-
-    if ((cl->format.bitsPerPixel != 8) &&
-        (cl->format.bitsPerPixel != 16) &&
-#ifdef LIBVNCSERVER_ALLOW24BPP
-	(cl->format.bitsPerPixel != 24) &&
-#endif
-        (cl->format.bitsPerPixel != 32))
-    {
-        rfbErr("%s: client bits per pixel not 8, 16 or 32\n",
-                "rfbSetTranslateFunction");
-        rfbCloseClient(cl);
-        return FALSE;
-    }
-
-    if (!cl->format.trueColour && (cl->format.bitsPerPixel != 8)) {
-        rfbErr("rfbSetTranslateFunction: client has colour map "
-                "but %d-bit - can only cope with 8-bit colour maps\n",
-                cl->format.bitsPerPixel);
-        rfbCloseClient(cl);
-        return FALSE;
-    }
-
-    /*
-     * bpp is valid, now work out how to translate
-     */
-
-    if (!cl->format.trueColour) {
-        /*
-         * truecolour -> colour map
-         *
-         * Set client's colour map to BGR233, then effectively it's
-         * truecolour as well
-         */
-
-        if (!rfbSetClientColourMapBGR233(cl))
-            return FALSE;
-
-        cl->format = BGR233Format;
-    }
-
-    /* truecolour -> truecolour */
-
-    if (PF_EQ(cl->format,cl->screen->serverFormat)) {
-
-        /* client & server the same */
-
-        rfbLog("no translation needed\n");
-        cl->translateFn = rfbTranslateNone;
-        return TRUE;
-    }
-
-    if ((cl->screen->serverFormat.bitsPerPixel < 16) ||
-        ((!cl->screen->serverFormat.trueColour || !rfbEconomicTranslate) &&
-	   (cl->screen->serverFormat.bitsPerPixel == 16))) {
-
-        /* we can use a single lookup table for <= 16 bpp */
-
-        cl->translateFn = rfbTranslateWithSingleTableFns
-                              [BPP2OFFSET(cl->screen->serverFormat.bitsPerPixel)]
-                                  [BPP2OFFSET(cl->format.bitsPerPixel)];
-
-	if(cl->screen->serverFormat.trueColour)
-	  (*rfbInitTrueColourSingleTableFns
-	   [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,
-						   &(cl->screen->serverFormat), &cl->format);
-	else
-	  (*rfbInitColourMapSingleTableFns
-	   [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,
-						   &(cl->screen->serverFormat), &cl->format,&cl->screen->colourMap);
-
-    } else {
-
-        /* otherwise we use three separate tables for red, green and blue */
-
-        cl->translateFn = rfbTranslateWithRGBTablesFns
-                              [BPP2OFFSET(cl->screen->serverFormat.bitsPerPixel)]
-                                  [BPP2OFFSET(cl->format.bitsPerPixel)];
-
-        (*rfbInitTrueColourRGBTablesFns
-            [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,
-                                             &(cl->screen->serverFormat), &cl->format);
-    }
-
-    return TRUE;
-}
-
-
-
-/*
- * rfbSetClientColourMapBGR233 sets the client's colour map so that it's
- * just like an 8-bit BGR233 true colour client.
- */
-
-static rfbBool
-rfbSetClientColourMapBGR233(rfbClientPtr cl)
-{
-    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];
-    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;
-    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);
-    int i, len;
-    int r, g, b;
-
-    if (cl->format.bitsPerPixel != 8 ) {
-        rfbErr("%s: client not 8 bits per pixel\n",
-                "rfbSetClientColourMapBGR233");
-        rfbCloseClient(cl);
-        return FALSE;
-    }
-    
-    scme->type = rfbSetColourMapEntries;
-
-    scme->firstColour = Swap16IfLE(0);
-    scme->nColours = Swap16IfLE(256);
-
-    len = sz_rfbSetColourMapEntriesMsg;
-
-    i = 0;
-
-    for (b = 0; b < 4; b++) {
-        for (g = 0; g < 8; g++) {
-            for (r = 0; r < 8; r++) {
-                rgb[i++] = Swap16IfLE(r * 65535 / 7);
-                rgb[i++] = Swap16IfLE(g * 65535 / 7);
-                rgb[i++] = Swap16IfLE(b * 65535 / 3);
-            }
-        }
-    }
-
-    len += 256 * 3 * 2;
-
-    if (rfbWriteExact(cl, buf, len) < 0) {
-        rfbLogPerror("rfbSetClientColourMapBGR233: write");
-        rfbCloseClient(cl);
-        return FALSE;
-    }
-    return TRUE;
-}
-
-/* this function is not called very often, so it needn't be
-   efficient. */
-
-/*
- * rfbSetClientColourMap is called to set the client's colour map.  If the
- * client is a true colour client, we simply update our own translation table
- * and mark the whole screen as having been modified.
- */
-
-rfbBool
-rfbSetClientColourMap(rfbClientPtr cl, int firstColour, int nColours)
-{
-    if (cl->screen->serverFormat.trueColour || !cl->readyForSetColourMapEntries) {
-	return TRUE;
-    }
-
-    if (nColours == 0) {
-	nColours = cl->screen->colourMap.count;
-    }
-
-    if (cl->format.trueColour) {
-	LOCK(cl->updateMutex);
-	(*rfbInitColourMapSingleTableFns
-	    [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,
-					     &cl->screen->serverFormat, &cl->format,&cl->screen->colourMap);
-
-	sraRgnDestroy(cl->modifiedRegion);
-	cl->modifiedRegion =
-	  sraRgnCreateRect(0,0,cl->screen->width,cl->screen->height);
-	UNLOCK(cl->updateMutex);
-
-	return TRUE;
-    }
-
-    return rfbSendSetColourMapEntries(cl, firstColour, nColours);
-}
-
-
-/*
- * rfbSetClientColourMaps sets the colour map for each RFB client.
- */
-
-void
-rfbSetClientColourMaps(rfbScreenInfoPtr rfbScreen, int firstColour, int nColours)
-{
-    rfbClientIteratorPtr i;
-    rfbClientPtr cl;
-
-    i = rfbGetClientIterator(rfbScreen);
-    while((cl = rfbClientIteratorNext(i)))
-      rfbSetClientColourMap(cl, firstColour, nColours);
-    rfbReleaseClientIterator(i);
-}
-
-static void
-PrintPixelFormat(rfbPixelFormat *pf)
-{
-    if (pf->bitsPerPixel == 1) {
-        rfbLog("  1 bpp, %s sig bit in each byte is leftmost on the screen.\n",
-               (pf->bigEndian ? "most" : "least"));
-    } else {
-        rfbLog("  %d bpp, depth %d%s\n",pf->bitsPerPixel,pf->depth,
-               ((pf->bitsPerPixel == 8) ? ""
-                : (pf->bigEndian ? ", big endian" : ", little endian")));
-        if (pf->trueColour) {
-            rfbLog("  true colour: max r %d g %d b %d, shift r %d g %d b %d\n",
-                   pf->redMax, pf->greenMax, pf->blueMax,
-                   pf->redShift, pf->greenShift, pf->blueShift);
-        } else {
-            rfbLog("  uses a colour map (not true colour).\n");
-        }
-    }
-}
diff --git a/libvncserver/ultra.c b/libvncserver/ultra.c
deleted file mode 100644
index 2eb351c..0000000
--- a/libvncserver/ultra.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * ultra.c
- *
- * Routines to implement ultra based encoding (minilzo).
- * ultrazip supports packed rectangles if the rects are tiny...
- * This improves performance as lzo has more data to work with at once
- * This is 'UltraZip' and is currently not implemented.
- */
-
-#include "rfb/rfb.h"
-#include "minilzo.h"
-
-/*
- * cl->beforeEncBuf contains pixel data in the client's format.
- * cl->afterEncBuf contains the lzo (deflated) encoding version.
- * If the lzo compressed/encoded version is
- * larger than the raw data or if it exceeds cl->afterEncBufSize then
- * raw encoding is used instead.
- */
-
-
-/*
- * rfbSendOneRectEncodingZlib - send a given rectangle using one Zlib
- *                              rectangle encoding.
- */
-
-#define MAX_WRKMEM ((LZO1X_1_MEM_COMPRESS) + (sizeof(lzo_align_t) - 1)) / sizeof(lzo_align_t)
-
-
-void rfbFreeUltraData(rfbClientPtr cl) {
-  if (cl->compStreamInitedLZO) {
-    free(cl->lzoWrkMem);
-    cl->compStreamInitedLZO=FALSE;
-  }
-}
-
-
-static rfbBool
-rfbSendOneRectEncodingUltra(rfbClientPtr cl,
-                           int x,
-                           int y,
-                           int w,
-                           int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    rfbZlibHeader hdr;
-    int deflateResult;
-    int i;
-    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)
-    	   + (x * (cl->scaledScreen->bitsPerPixel / 8)));
-
-    int maxRawSize;
-    lzo_uint maxCompSize;
-
-    maxRawSize = (w * h * (cl->format.bitsPerPixel / 8));
-
-    if (cl->beforeEncBufSize < maxRawSize) {
-	cl->beforeEncBufSize = maxRawSize;
-	if (cl->beforeEncBuf == NULL)
-	    cl->beforeEncBuf = (char *)malloc(cl->beforeEncBufSize);
-	else
-	    cl->beforeEncBuf = (char *)realloc(cl->beforeEncBuf, cl->beforeEncBufSize);
-    }
-
-    /*
-     * lzo requires output buffer to be slightly larger than the input
-     * buffer, in the worst case.
-     */
-    maxCompSize = (maxRawSize + maxRawSize / 16 + 64 + 3);
-
-    if (cl->afterEncBufSize < (int)maxCompSize) {
-	cl->afterEncBufSize = maxCompSize;
-	if (cl->afterEncBuf == NULL)
-	    cl->afterEncBuf = (char *)malloc(cl->afterEncBufSize);
-	else
-	    cl->afterEncBuf = (char *)realloc(cl->afterEncBuf, cl->afterEncBufSize);
-    }
-
-    /* 
-     * Convert pixel data to client format.
-     */
-    (*cl->translateFn)(cl->translateLookupTable, &cl->screen->serverFormat,
-		       &cl->format, fbptr, cl->beforeEncBuf,
-		       cl->scaledScreen->paddedWidthInBytes, w, h);
-
-    if ( cl->compStreamInitedLZO == FALSE ) {
-        cl->compStreamInitedLZO = TRUE;
-        /* Work-memory needed for compression. Allocate memory in units
-         * of `lzo_align_t' (instead of `char') to make sure it is properly aligned.
-         */  
-        cl->lzoWrkMem = malloc(sizeof(lzo_align_t) * (((LZO1X_1_MEM_COMPRESS) + (sizeof(lzo_align_t) - 1)) / sizeof(lzo_align_t)));
-    }
-
-    /* Perform the compression here. */
-    deflateResult = lzo1x_1_compress((unsigned char *)cl->beforeEncBuf, (lzo_uint)(w * h * (cl->format.bitsPerPixel / 8)), (unsigned char *)cl->afterEncBuf, &maxCompSize, cl->lzoWrkMem);
-    /* maxCompSize now contains the compressed size */
-
-    /* Find the total size of the resulting compressed data. */
-    cl->afterEncBufLen = maxCompSize;
-
-    if ( deflateResult != LZO_E_OK ) {
-        rfbErr("lzo deflation error: %d\n", deflateResult);
-        return FALSE;
-    }
-
-    /* Update statics */
-    rfbStatRecordEncodingSent(cl, rfbEncodingUltra, sz_rfbFramebufferUpdateRectHeader + sz_rfbZlibHeader + cl->afterEncBufLen, maxRawSize);
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbZlibHeader
-	> UPDATE_BUF_SIZE)
-    {
-	if (!rfbSendUpdateBuf(cl))
-	    return FALSE;
-    }
-
-    rect.r.x = Swap16IfLE(x);
-    rect.r.y = Swap16IfLE(y);
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-    rect.encoding = Swap32IfLE(rfbEncodingUltra);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-	   sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    hdr.nBytes = Swap32IfLE(cl->afterEncBufLen);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbZlibHeader);
-    cl->ublen += sz_rfbZlibHeader;
-
-    /* We might want to try sending the data directly... */
-    for (i = 0; i < cl->afterEncBufLen;) {
-
-	int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;
-
-	if (i + bytesToCopy > cl->afterEncBufLen) {
-	    bytesToCopy = cl->afterEncBufLen - i;
-	}
-
-	memcpy(&cl->updateBuf[cl->ublen], &cl->afterEncBuf[i], bytesToCopy);
-
-	cl->ublen += bytesToCopy;
-	i += bytesToCopy;
-
-	if (cl->ublen == UPDATE_BUF_SIZE) {
-	    if (!rfbSendUpdateBuf(cl))
-		return FALSE;
-	}
-    }
-
-    return TRUE;
-
-}
-
-/*
- * rfbSendRectEncodingUltra - send a given rectangle using one or more
- *                           LZO encoding rectangles.
- */
-
-rfbBool
-rfbSendRectEncodingUltra(rfbClientPtr cl,
-                        int x,
-                        int y,
-                        int w,
-                        int h)
-{
-    int  maxLines;
-    int  linesRemaining;
-    rfbRectangle partialRect;
-
-    partialRect.x = x;
-    partialRect.y = y;
-    partialRect.w = w;
-    partialRect.h = h;
-
-    /* Determine maximum pixel/scan lines allowed per rectangle. */
-    maxLines = ( ULTRA_MAX_SIZE(w) / w );
-
-    /* Initialize number of scan lines left to do. */
-    linesRemaining = h;
-
-    /* Loop until all work is done. */
-    while ( linesRemaining > 0 ) {
-
-        int linesToComp;
-
-        if ( maxLines < linesRemaining )
-            linesToComp = maxLines;
-        else
-            linesToComp = linesRemaining;
-
-        partialRect.h = linesToComp;
-
-        /* Encode (compress) and send the next rectangle. */
-        if ( ! rfbSendOneRectEncodingUltra( cl,
-                                           partialRect.x,
-                                           partialRect.y,
-                                           partialRect.w,
-                                           partialRect.h )) {
-
-            return FALSE;
-        }
-
-        /* Technically, flushing the buffer here is not extrememly
-         * efficient.  However, this improves the overall throughput
-         * of the system over very slow networks.  By flushing
-         * the buffer with every maximum size lzo rectangle, we
-         * improve the pipelining usage of the server CPU, network,
-         * and viewer CPU components.  Insuring that these components
-         * are working in parallel actually improves the performance
-         * seen by the user.
-         * Since, lzo is most useful for slow networks, this flush
-         * is appropriate for the desired behavior of the lzo encoding.
-         */
-        if (( cl->ublen > 0 ) &&
-            ( linesToComp == maxLines )) {
-            if (!rfbSendUpdateBuf(cl)) {
-
-                return FALSE;
-            }
-        }
-
-        /* Update remaining and incremental rectangle location. */
-        linesRemaining -= linesToComp;
-        partialRect.y += linesToComp;
-
-    }
-
-    return TRUE;
-
-}
diff --git a/libvncserver/vncauth.c b/libvncserver/vncauth.c
deleted file mode 100644
index ca45f0f..0000000
--- a/libvncserver/vncauth.c
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * vncauth.c - Functions for VNC password management and authentication.
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#define _POSIX_SOURCE
-#define _XOPEN_SOURCE 600
-#endif
-#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include "rfb/rfbproto.h"
-#include "d3des.h"
-
-#include <string.h>
-#include <math.h>
-
-#ifdef LIBVNCSERVER_HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-
-#include <time.h>
-
-#ifdef WIN32
-#define srandom srand
-#define random rand
-#else
-#include <sys/time.h>
-#endif
-
-
-/* libvncclient does not need this */
-#ifndef rfbEncryptBytes
-
-/*
- * We use a fixed key to store passwords, since we assume that our local
- * file system is secure but nonetheless don't want to store passwords
- * as plaintext.
- */
-
-static unsigned char fixedkey[8] = {23,82,107,6,35,78,88,7};
-
-
-/*
- * Encrypt a password and store it in a file.  Returns 0 if successful,
- * 1 if the file could not be written.
- */
-
-int
-rfbEncryptAndStorePasswd(char *passwd, char *fname)
-{
-    FILE *fp;
-    unsigned int i;
-    unsigned char encryptedPasswd[8];
-
-    if ((fp = fopen(fname,"w")) == NULL) return 1;
-
-	/* windows security sux */
-#ifndef WIN32
-    fchmod(fileno(fp), S_IRUSR|S_IWUSR);
-#endif
-
-    /* pad password with nulls */
-
-    for (i = 0; i < 8; i++) {
-	if (i < strlen(passwd)) {
-	    encryptedPasswd[i] = passwd[i];
-	} else {
-	    encryptedPasswd[i] = 0;
-	}
-    }
-
-    /* Do encryption in-place - this way we overwrite our copy of the plaintext
-       password */
-
-    rfbDesKey(fixedkey, EN0);
-    rfbDes(encryptedPasswd, encryptedPasswd);
-
-    for (i = 0; i < 8; i++) {
-	putc(encryptedPasswd[i], fp);
-    }
-
-    fclose(fp);
-    return 0;
-}
-
-
-/*
- * Decrypt a password from a file.  Returns a pointer to a newly allocated
- * string containing the password or a null pointer if the password could
- * not be retrieved for some reason.
- */
-
-char *
-rfbDecryptPasswdFromFile(char *fname)
-{
-    FILE *fp;
-    int i, ch;
-    unsigned char *passwd = (unsigned char *)malloc(9);
-
-    if ((fp = fopen(fname,"r")) == NULL) {
-	free(passwd);
-	return NULL;
-    }
-
-    for (i = 0; i < 8; i++) {
-	ch = getc(fp);
-	if (ch == EOF) {
-	    fclose(fp);
-	    free(passwd);
-	    return NULL;
-	}
-	passwd[i] = ch;
-    }
-
-    fclose(fp);
-
-    rfbDesKey(fixedkey, DE1);
-    rfbDes(passwd, passwd);
-
-    passwd[8] = 0;
-
-    return (char *)passwd;
-}
-
-
-/*
- * Generate CHALLENGESIZE random bytes for use in challenge-response
- * authentication.
- */
-
-void
-rfbRandomBytes(unsigned char *bytes)
-{
-    int i;
-    static rfbBool s_srandom_called = FALSE;
-
-    if (!s_srandom_called) {
-	srandom((unsigned int)time(NULL) ^ (unsigned int)getpid());
-	s_srandom_called = TRUE;
-    }
-
-    for (i = 0; i < CHALLENGESIZE; i++) {
-	bytes[i] = (unsigned char)(random() & 255);
-    }
-}
-
-#endif
-
-/*
- * Encrypt CHALLENGESIZE bytes in memory using a password.
- */
-
-void
-rfbEncryptBytes(unsigned char *bytes, char *passwd)
-{
-    unsigned char key[8];
-    unsigned int i;
-
-    /* key is simply password padded with nulls */
-
-    for (i = 0; i < 8; i++) {
-	if (i < strlen(passwd)) {
-	    key[i] = passwd[i];
-	} else {
-	    key[i] = 0;
-	}
-    }
-
-    rfbDesKey(key, EN0);
-
-    for (i = 0; i < CHALLENGESIZE; i += 8) {
-	rfbDes(bytes+i, bytes+i);
-    }
-}
-
-void
-rfbEncryptBytes2(unsigned char *where, const int length, unsigned char *key) {
-  int i, j;
-  rfbDesKey(key, EN0);
-  for (i = 0; i< 8; i++)
-    where[i] ^= key[i];
-  rfbDes(where, where);
-  for (i = 8; i < length; i += 8) {
-    for (j = 0; j < 8; j++)
-      where[i + j] ^= where[i + j - 8];
-      rfbDes(where + i, where + i);
-  }
-}
diff --git a/libvncserver/zlib.c b/libvncserver/zlib.c
deleted file mode 100644
index 7075dc3..0000000
--- a/libvncserver/zlib.c
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * zlib.c
- *
- * Routines to implement zlib based encoding (deflate).
- */
-
-/*
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- *
- * For the latest source code, please check:
- *
- * http://www.developVNC.org/
- *
- * or send email to feedback@developvnc.org.
- */
-
-#include "rfb/rfb.h"
-
-/*
- * zlibBeforeBuf contains pixel data in the client's format.
- * zlibAfterBuf contains the zlib (deflated) encoding version.
- * If the zlib compressed/encoded version is
- * larger than the raw data or if it exceeds zlibAfterBufSize then
- * raw encoding is used instead.
- */
-
-/*
- * Out of lazyiness, we use thread local storage for zlib as we did for
- * tight.  N.B. ZRLE does it the traditional way with per-client storage
- * (and so at least ZRLE will work threaded on older systems.)
- */
-#if LIBVNCSERVER_HAVE_LIBPTHREAD && LIBVNCSERVER_HAVE_TLS && !defined(TLS) && defined(__linux__)
-#define TLS __thread
-#endif
-#ifndef TLS
-#define TLS
-#endif
-
-static TLS int zlibBeforeBufSize = 0;
-static TLS char *zlibBeforeBuf = NULL;
-
-static TLS int zlibAfterBufSize = 0;
-static TLS char *zlibAfterBuf = NULL;
-static TLS int zlibAfterBufLen = 0;
-
-void rfbZlibCleanup(rfbScreenInfoPtr screen)
-{
-  if (zlibBeforeBufSize) {
-    free(zlibBeforeBuf);
-    zlibBeforeBufSize=0;
-  }
-  if (zlibAfterBufSize) {
-    zlibAfterBufSize=0;
-    free(zlibAfterBuf);
-  }
-}
-
-
-/*
- * rfbSendOneRectEncodingZlib - send a given rectangle using one Zlib
- *                              rectangle encoding.
- */
-
-static rfbBool
-rfbSendOneRectEncodingZlib(rfbClientPtr cl,
-                           int x,
-                           int y,
-                           int w,
-                           int h)
-{
-    rfbFramebufferUpdateRectHeader rect;
-    rfbZlibHeader hdr;
-    int deflateResult;
-    int previousOut;
-    int i;
-    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)
-    	   + (x * (cl->scaledScreen->bitsPerPixel / 8)));
-
-    int maxRawSize;
-    int maxCompSize;
-
-    maxRawSize = (cl->scaledScreen->width * cl->scaledScreen->height
-                  * (cl->format.bitsPerPixel / 8));
-
-    if (zlibBeforeBufSize < maxRawSize) {
-	zlibBeforeBufSize = maxRawSize;
-	if (zlibBeforeBuf == NULL)
-	    zlibBeforeBuf = (char *)malloc(zlibBeforeBufSize);
-	else
-	    zlibBeforeBuf = (char *)realloc(zlibBeforeBuf, zlibBeforeBufSize);
-    }
-
-    /* zlib compression is not useful for very small data sets.
-     * So, we just send these raw without any compression.
-     */
-    if (( w * h * (cl->scaledScreen->bitsPerPixel / 8)) <
-          VNC_ENCODE_ZLIB_MIN_COMP_SIZE ) {
-
-        int result;
-
-        /* The translation function (used also by the in raw encoding)
-         * requires 4/2/1 byte alignment in the output buffer (which is
-         * updateBuf for the raw encoding) based on the bitsPerPixel of
-         * the viewer/client.  This prevents SIGBUS errors on some
-         * architectures like SPARC, PARISC...
-         */
-        if (( cl->format.bitsPerPixel > 8 ) &&
-            ( cl->ublen % ( cl->format.bitsPerPixel / 8 )) != 0 ) {
-            if (!rfbSendUpdateBuf(cl))
-                return FALSE;
-        }
-
-        result = rfbSendRectEncodingRaw(cl, x, y, w, h);
-
-        return result;
-
-    }
-
-    /*
-     * zlib requires output buffer to be slightly larger than the input
-     * buffer, in the worst case.
-     */
-    maxCompSize = maxRawSize + (( maxRawSize + 99 ) / 100 ) + 12;
-
-    if (zlibAfterBufSize < maxCompSize) {
-	zlibAfterBufSize = maxCompSize;
-	if (zlibAfterBuf == NULL)
-	    zlibAfterBuf = (char *)malloc(zlibAfterBufSize);
-	else
-	    zlibAfterBuf = (char *)realloc(zlibAfterBuf, zlibAfterBufSize);
-    }
-
-
-    /* 
-     * Convert pixel data to client format.
-     */
-    (*cl->translateFn)(cl->translateLookupTable, &cl->screen->serverFormat,
-		       &cl->format, fbptr, zlibBeforeBuf,
-		       cl->scaledScreen->paddedWidthInBytes, w, h);
-
-    cl->compStream.next_in = ( Bytef * )zlibBeforeBuf;
-    cl->compStream.avail_in = w * h * (cl->format.bitsPerPixel / 8);
-    cl->compStream.next_out = ( Bytef * )zlibAfterBuf;
-    cl->compStream.avail_out = maxCompSize;
-    cl->compStream.data_type = Z_BINARY;
-
-    /* Initialize the deflation state. */
-    if ( cl->compStreamInited == FALSE ) {
-
-        cl->compStream.total_in = 0;
-        cl->compStream.total_out = 0;
-        cl->compStream.zalloc = Z_NULL;
-        cl->compStream.zfree = Z_NULL;
-        cl->compStream.opaque = Z_NULL;
-
-        deflateInit2( &(cl->compStream),
-                        cl->zlibCompressLevel,
-                        Z_DEFLATED,
-                        MAX_WBITS,
-                        MAX_MEM_LEVEL,
-                        Z_DEFAULT_STRATEGY );
-        /* deflateInit( &(cl->compStream), Z_BEST_COMPRESSION ); */
-        /* deflateInit( &(cl->compStream), Z_BEST_SPEED ); */
-        cl->compStreamInited = TRUE;
-
-    }
-
-    previousOut = cl->compStream.total_out;
-
-    /* Perform the compression here. */
-    deflateResult = deflate( &(cl->compStream), Z_SYNC_FLUSH );
-
-    /* Find the total size of the resulting compressed data. */
-    zlibAfterBufLen = cl->compStream.total_out - previousOut;
-
-    if ( deflateResult != Z_OK ) {
-        rfbErr("zlib deflation error: %s\n", cl->compStream.msg);
-        return FALSE;
-    }
-
-    /* Note that it is not possible to switch zlib parameters based on
-     * the results of the compression pass.  The reason is
-     * that we rely on the compressor and decompressor states being
-     * in sync.  Compressing and then discarding the results would
-     * cause lose of synchronization.
-     */
-
-    /* Update statics */
-    rfbStatRecordEncodingSent(cl, rfbEncodingZlib, sz_rfbFramebufferUpdateRectHeader + sz_rfbZlibHeader + zlibAfterBufLen,
-        + w * (cl->format.bitsPerPixel / 8) * h);
-
-    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbZlibHeader
-	> UPDATE_BUF_SIZE)
-    {
-	if (!rfbSendUpdateBuf(cl))
-	    return FALSE;
-    }
-
-    rect.r.x = Swap16IfLE(x);
-    rect.r.y = Swap16IfLE(y);
-    rect.r.w = Swap16IfLE(w);
-    rect.r.h = Swap16IfLE(h);
-    rect.encoding = Swap32IfLE(rfbEncodingZlib);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,
-	   sz_rfbFramebufferUpdateRectHeader);
-    cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-    hdr.nBytes = Swap32IfLE(zlibAfterBufLen);
-
-    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbZlibHeader);
-    cl->ublen += sz_rfbZlibHeader;
-
-    for (i = 0; i < zlibAfterBufLen;) {
-
-	int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;
-
-	if (i + bytesToCopy > zlibAfterBufLen) {
-	    bytesToCopy = zlibAfterBufLen - i;
-	}
-
-	memcpy(&cl->updateBuf[cl->ublen], &zlibAfterBuf[i], bytesToCopy);
-
-	cl->ublen += bytesToCopy;
-	i += bytesToCopy;
-
-	if (cl->ublen == UPDATE_BUF_SIZE) {
-	    if (!rfbSendUpdateBuf(cl))
-		return FALSE;
-	}
-    }
-
-    return TRUE;
-
-}
-
-
-/*
- * rfbSendRectEncodingZlib - send a given rectangle using one or more
- *                           Zlib encoding rectangles.
- */
-
-rfbBool
-rfbSendRectEncodingZlib(rfbClientPtr cl,
-                        int x,
-                        int y,
-                        int w,
-                        int h)
-{
-    int  maxLines;
-    int  linesRemaining;
-    rfbRectangle partialRect;
-
-    partialRect.x = x;
-    partialRect.y = y;
-    partialRect.w = w;
-    partialRect.h = h;
-
-    /* Determine maximum pixel/scan lines allowed per rectangle. */
-    maxLines = ( ZLIB_MAX_SIZE(w) / w );
-
-    /* Initialize number of scan lines left to do. */
-    linesRemaining = h;
-
-    /* Loop until all work is done. */
-    while ( linesRemaining > 0 ) {
-
-        int linesToComp;
-
-        if ( maxLines < linesRemaining )
-            linesToComp = maxLines;
-        else
-            linesToComp = linesRemaining;
-
-        partialRect.h = linesToComp;
-
-        /* Encode (compress) and send the next rectangle. */
-        if ( ! rfbSendOneRectEncodingZlib( cl,
-                                           partialRect.x,
-                                           partialRect.y,
-                                           partialRect.w,
-                                           partialRect.h )) {
-
-            return FALSE;
-        }
-
-        /* Technically, flushing the buffer here is not extrememly
-         * efficient.  However, this improves the overall throughput
-         * of the system over very slow networks.  By flushing
-         * the buffer with every maximum size zlib rectangle, we
-         * improve the pipelining usage of the server CPU, network,
-         * and viewer CPU components.  Insuring that these components
-         * are working in parallel actually improves the performance
-         * seen by the user.
-         * Since, zlib is most useful for slow networks, this flush
-         * is appropriate for the desired behavior of the zlib encoding.
-         */
-        if (( cl->ublen > 0 ) &&
-            ( linesToComp == maxLines )) {
-            if (!rfbSendUpdateBuf(cl)) {
-
-                return FALSE;
-            }
-        }
-
-        /* Update remaining and incremental rectangle location. */
-        linesRemaining -= linesToComp;
-        partialRect.y += linesToComp;
-
-    }
-
-    return TRUE;
-
-}
-
diff --git a/libvncserver/zrle.c b/libvncserver/zrle.c
deleted file mode 100644
index 80f629c..0000000
--- a/libvncserver/zrle.c
+++ /dev/null
@@ -1,257 +0,0 @@
-/*
- * Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.
- * Copyright (C) 2003 Sun Microsystems, Inc.
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- * USA.
- */
-
-/*
- * zrle.c
- *
- * Routines to implement Zlib Run-length Encoding (ZRLE).
- */
-
-#include "rfb/rfb.h"
-#include "private.h"
-#include "zrleoutstream.h"
-
-
-#define GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf)                                \
-{  char *fbptr = (cl->scaledScreen->frameBuffer                                   \
-		 + (cl->scaledScreen->paddedWidthInBytes * ty)                   \
-                 + (tx * (cl->scaledScreen->bitsPerPixel / 8)));                 \
-                                                                           \
-  (*cl->translateFn)(cl->translateLookupTable, &cl->screen->serverFormat,\
-                     &cl->format, fbptr, (char*)buf,                       \
-                     cl->scaledScreen->paddedWidthInBytes, tw, th); }
-
-#define EXTRA_ARGS , rfbClientPtr cl
-
-#define ENDIAN_LITTLE 0
-#define ENDIAN_BIG 1
-#define ENDIAN_NO 2
-#define BPP 8
-#define ZYWRLE_ENDIAN ENDIAN_NO
-#include <zrleencodetemplate.c>
-#undef BPP
-#define BPP 15
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_LITTLE
-#include <zrleencodetemplate.c>
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_BIG
-#include <zrleencodetemplate.c>
-#undef BPP
-#define BPP 16
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_LITTLE
-#include <zrleencodetemplate.c>
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_BIG
-#include <zrleencodetemplate.c>
-#undef BPP
-#define BPP 32
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_LITTLE
-#include <zrleencodetemplate.c>
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_BIG
-#include <zrleencodetemplate.c>
-#define CPIXEL 24A
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_LITTLE
-#include <zrleencodetemplate.c>
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_BIG
-#include <zrleencodetemplate.c>
-#undef CPIXEL
-#define CPIXEL 24B
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_LITTLE
-#include <zrleencodetemplate.c>
-#undef ZYWRLE_ENDIAN
-#define ZYWRLE_ENDIAN ENDIAN_BIG
-#include <zrleencodetemplate.c>
-#undef CPIXEL
-#undef BPP
-
-
-/*
- * zrleBeforeBuf contains pixel data in the client's format.  It must be at
- * least one pixel bigger than the largest tile of pixel data, since the
- * ZRLE encoding algorithm writes to the position one past the end of the pixel
- * data.
- */
-
-
-/*
- * rfbSendRectEncodingZRLE - send a given rectangle using ZRLE encoding.
- */
-
-rfbBool rfbSendRectEncodingZRLE(rfbClientPtr cl, int x, int y, int w, int h)
-{
-  zrleOutStream* zos;
-  rfbFramebufferUpdateRectHeader rect;
-  rfbZRLEHeader hdr;
-  int i;
-  char *zrleBeforeBuf;
-
-  if (cl->zrleBeforeBuf == NULL) {
-	cl->zrleBeforeBuf = (char *) malloc(rfbZRLETileWidth * rfbZRLETileHeight * 4 + 4);
-  }
-  zrleBeforeBuf = cl->zrleBeforeBuf;
-
-  if (cl->preferredEncoding == rfbEncodingZYWRLE) {
-	  if (cl->tightQualityLevel < 0) {
-		  cl->zywrleLevel = 1;
-	  } else if (cl->tightQualityLevel < 3) {
-		  cl->zywrleLevel = 3;
-	  } else if (cl->tightQualityLevel < 6) {
-		  cl->zywrleLevel = 2;
-	  } else {
-		  cl->zywrleLevel = 1;
-	  }
-  } else
-	  cl->zywrleLevel = 0;
-
-  if (!cl->zrleData)
-    cl->zrleData = zrleOutStreamNew();
-  zos = cl->zrleData;
-  zos->in.ptr = zos->in.start;
-  zos->out.ptr = zos->out.start;
-
-  switch (cl->format.bitsPerPixel) {
-
-  case 8:
-    zrleEncode8NE(x, y, w, h, zos, zrleBeforeBuf, cl);
-    break;
-
-  case 16:
-	if (cl->format.greenMax > 0x1F) {
-		if (cl->format.bigEndian)
-		  zrleEncode16BE(x, y, w, h, zos, zrleBeforeBuf, cl);
-		else
-		  zrleEncode16LE(x, y, w, h, zos, zrleBeforeBuf, cl);
-	} else {
-		if (cl->format.bigEndian)
-		  zrleEncode15BE(x, y, w, h, zos, zrleBeforeBuf, cl);
-		else
-		  zrleEncode15LE(x, y, w, h, zos, zrleBeforeBuf, cl);
-	}
-    break;
-
-  case 32: {
-    rfbBool fitsInLS3Bytes
-      = ((cl->format.redMax   << cl->format.redShift)   < (1<<24) &&
-         (cl->format.greenMax << cl->format.greenShift) < (1<<24) &&
-         (cl->format.blueMax  << cl->format.blueShift)  < (1<<24));
-
-    rfbBool fitsInMS3Bytes = (cl->format.redShift   > 7  &&
-                           cl->format.greenShift > 7  &&
-                           cl->format.blueShift  > 7);
-
-    if ((fitsInLS3Bytes && !cl->format.bigEndian) ||
-        (fitsInMS3Bytes && cl->format.bigEndian)) {
-	if (cl->format.bigEndian)
-		zrleEncode24ABE(x, y, w, h, zos, zrleBeforeBuf, cl);
-	else
-		zrleEncode24ALE(x, y, w, h, zos, zrleBeforeBuf, cl);
-    }
-    else if ((fitsInLS3Bytes && cl->format.bigEndian) ||
-             (fitsInMS3Bytes && !cl->format.bigEndian)) {
-	if (cl->format.bigEndian)
-		zrleEncode24BBE(x, y, w, h, zos, zrleBeforeBuf, cl);
-	else
-		zrleEncode24BLE(x, y, w, h, zos, zrleBeforeBuf, cl);
-    }
-    else {
-	if (cl->format.bigEndian)
-		zrleEncode32BE(x, y, w, h, zos, zrleBeforeBuf, cl);
-	else
-		zrleEncode32LE(x, y, w, h, zos, zrleBeforeBuf, cl);
-    }
-  }
-    break;
-  }
-
-  rfbStatRecordEncodingSent(cl, rfbEncodingZRLE, sz_rfbFramebufferUpdateRectHeader + sz_rfbZRLEHeader + ZRLE_BUFFER_LENGTH(&zos->out),
-      + w * (cl->format.bitsPerPixel / 8) * h);
-
-  if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbZRLEHeader
-      > UPDATE_BUF_SIZE)
-    {
-      if (!rfbSendUpdateBuf(cl))
-        return FALSE;
-    }
-
-  rect.r.x = Swap16IfLE(x);
-  rect.r.y = Swap16IfLE(y);
-  rect.r.w = Swap16IfLE(w);
-  rect.r.h = Swap16IfLE(h);
-  rect.encoding = Swap32IfLE(cl->preferredEncoding);
-
-  memcpy(cl->updateBuf+cl->ublen, (char *)&rect,
-         sz_rfbFramebufferUpdateRectHeader);
-  cl->ublen += sz_rfbFramebufferUpdateRectHeader;
-
-  hdr.length = Swap32IfLE(ZRLE_BUFFER_LENGTH(&zos->out));
-
-  memcpy(cl->updateBuf+cl->ublen, (char *)&hdr, sz_rfbZRLEHeader);
-  cl->ublen += sz_rfbZRLEHeader;
-
-  /* copy into updateBuf and send from there.  Maybe should send directly? */
-
-  for (i = 0; i < ZRLE_BUFFER_LENGTH(&zos->out);) {
-
-    int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;
-
-    if (i + bytesToCopy > ZRLE_BUFFER_LENGTH(&zos->out)) {
-      bytesToCopy = ZRLE_BUFFER_LENGTH(&zos->out) - i;
-    }
-
-    memcpy(cl->updateBuf+cl->ublen, (uint8_t*)zos->out.start + i, bytesToCopy);
-
-    cl->ublen += bytesToCopy;
-    i += bytesToCopy;
-
-    if (cl->ublen == UPDATE_BUF_SIZE) {
-      if (!rfbSendUpdateBuf(cl))
-        return FALSE;
-    }
-  }
-
-  return TRUE;
-}
-
-
-void rfbFreeZrleData(rfbClientPtr cl)
-{
-	if (cl->zrleData) {
-		zrleOutStreamFree(cl->zrleData);
-	}
-	cl->zrleData = NULL;
-
-	if (cl->zrleBeforeBuf) {
-		free(cl->zrleBeforeBuf);
-	}
-	cl->zrleBeforeBuf = NULL;
-
-	if (cl->paletteHelper) {
-		free(cl->paletteHelper);
-	}
-	cl->paletteHelper = NULL;
-}
-
diff --git a/libvncserver/zrleencodetemplate.c b/libvncserver/zrleencodetemplate.c
deleted file mode 100644
index b6de755..0000000
--- a/libvncserver/zrleencodetemplate.c
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.
- * Copyright (C) 2003 Sun Microsystems, Inc.
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- * USA.
- */
-
-/*
- * Before including this file, you must define a number of CPP macros.
- *
- * BPP should be 8, 16 or 32 depending on the bits per pixel.
- * GET_IMAGE_INTO_BUF should be some code which gets a rectangle of pixel data
- * into the given buffer.  EXTRA_ARGS can be defined to pass any other
- * arguments needed by GET_IMAGE_INTO_BUF.
- *
- * Note that the buf argument to ZRLE_ENCODE needs to be at least one pixel
- * bigger than the largest tile of pixel data, since the ZRLE encoding
- * algorithm writes to the position one past the end of the pixel data.
- */
-
-#include "zrleoutstream.h"
-#include "zrlepalettehelper.h"
-#include <assert.h>
-
-/* __RFB_CONCAT2 concatenates its two arguments.  __RFB_CONCAT2E does the same
-   but also expands its arguments if they are macros */
-
-#ifndef __RFB_CONCAT2E
-#define __RFB_CONCAT2(a,b) a##b
-#define __RFB_CONCAT2E(a,b) __RFB_CONCAT2(a,b)
-#endif
-
-#ifndef __RFB_CONCAT3E
-#define __RFB_CONCAT3(a,b,c) a##b##c
-#define __RFB_CONCAT3E(a,b,c) __RFB_CONCAT3(a,b,c)
-#endif
-
-#undef END_FIX
-#if ZYWRLE_ENDIAN == ENDIAN_LITTLE
-#  define END_FIX LE
-#elif ZYWRLE_ENDIAN == ENDIAN_BIG
-#  define END_FIX BE
-#else
-#  define END_FIX NE
-#endif
-
-#ifdef CPIXEL
-#define PIXEL_T __RFB_CONCAT2E(zrle_U,BPP)
-#define zrleOutStreamWRITE_PIXEL __RFB_CONCAT2E(zrleOutStreamWriteOpaque,CPIXEL)
-#define ZRLE_ENCODE __RFB_CONCAT3E(zrleEncode,CPIXEL,END_FIX)
-#define ZRLE_ENCODE_TILE __RFB_CONCAT3E(zrleEncodeTile,CPIXEL,END_FIX)
-#define BPPOUT 24
-#elif BPP==15
-#define PIXEL_T __RFB_CONCAT2E(zrle_U,16)
-#define zrleOutStreamWRITE_PIXEL __RFB_CONCAT2E(zrleOutStreamWriteOpaque,16)
-#define ZRLE_ENCODE __RFB_CONCAT3E(zrleEncode,BPP,END_FIX)
-#define ZRLE_ENCODE_TILE __RFB_CONCAT3E(zrleEncodeTile,BPP,END_FIX)
-#define BPPOUT 16
-#else
-#define PIXEL_T __RFB_CONCAT2E(zrle_U,BPP)
-#define zrleOutStreamWRITE_PIXEL __RFB_CONCAT2E(zrleOutStreamWriteOpaque,BPP)
-#define ZRLE_ENCODE __RFB_CONCAT3E(zrleEncode,BPP,END_FIX)
-#define ZRLE_ENCODE_TILE __RFB_CONCAT3E(zrleEncodeTile,BPP,END_FIX)
-#define BPPOUT BPP
-#endif
-
-#ifndef ZRLE_ONCE
-#define ZRLE_ONCE
-
-static const int bitsPerPackedPixel[] = {
-  0, 1, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
-};
-
-#endif /* ZRLE_ONCE */
-
-void ZRLE_ENCODE_TILE (PIXEL_T* data, int w, int h, zrleOutStream* os,
-		int zywrle_level, int *zywrleBuf, void *paletteHelper);
-
-#if BPP!=8
-#define ZYWRLE_ENCODE
-#include "zywrletemplate.c"
-#endif
-
-static void ZRLE_ENCODE (int x, int y, int w, int h,
-		  zrleOutStream* os, void* buf
-                  EXTRA_ARGS
-                  )
-{
-  int ty;
-  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
-    int tx, th = rfbZRLETileHeight;
-    if (th > y+h-ty) th = y+h-ty;
-    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
-      int tw = rfbZRLETileWidth;
-      if (tw > x+w-tx) tw = x+w-tx;
-
-      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);
-
-      if (cl->paletteHelper == NULL) {
-          cl->paletteHelper = (void *) calloc(sizeof(zrlePaletteHelper), 1);
-      }
-
-      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
-		      cl->zywrleLevel, cl->zywrleBuf, cl->paletteHelper);
-    }
-  }
-  zrleOutStreamFlush(os);
-}
-
-
-void ZRLE_ENCODE_TILE(PIXEL_T* data, int w, int h, zrleOutStream* os,
-	int zywrle_level, int *zywrleBuf,  void *paletteHelper)
-{
-  /* First find the palette and the number of runs */
-
-  zrlePaletteHelper *ph;
-
-  int runs = 0;
-  int singlePixels = 0;
-
-  rfbBool useRle;
-  rfbBool usePalette;
-
-  int estimatedBytes;
-  int plainRleBytes;
-  int i;
-
-  PIXEL_T* ptr = data;
-  PIXEL_T* end = ptr + h * w;
-  *end = ~*(end-1); /* one past the end is different so the while loop ends */
-
-  ph = (zrlePaletteHelper *) paletteHelper;
-  zrlePaletteHelperInit(ph);
-
-  while (ptr < end) {
-    PIXEL_T pix = *ptr;
-    if (*++ptr != pix) {
-      singlePixels++;
-    } else {
-      while (*++ptr == pix) ;
-      runs++;
-    }
-    zrlePaletteHelperInsert(ph, pix);
-  }
-
-  /* Solid tile is a special case */
-
-  if (ph->size == 1) {
-    zrleOutStreamWriteU8(os, 1);
-    zrleOutStreamWRITE_PIXEL(os, ph->palette[0]);
-    return;
-  }
-
-  /* Try to work out whether to use RLE and/or a palette.  We do this by
-     estimating the number of bytes which will be generated and picking the
-     method which results in the fewest bytes.  Of course this may not result
-     in the fewest bytes after compression... */
-
-  useRle = FALSE;
-  usePalette = FALSE;
-
-  estimatedBytes = w * h * (BPPOUT/8); /* start assuming raw */
-
-#if BPP!=8
-  if (zywrle_level > 0 && !(zywrle_level & 0x80))
-	  estimatedBytes >>= zywrle_level;
-#endif
-
-  plainRleBytes = ((BPPOUT/8)+1) * (runs + singlePixels);
-
-  if (plainRleBytes < estimatedBytes) {
-    useRle = TRUE;
-    estimatedBytes = plainRleBytes;
-  }
-
-  if (ph->size < 128) {
-    int paletteRleBytes = (BPPOUT/8) * ph->size + 2 * runs + singlePixels;
-
-    if (paletteRleBytes < estimatedBytes) {
-      useRle = TRUE;
-      usePalette = TRUE;
-      estimatedBytes = paletteRleBytes;
-    }
-
-    if (ph->size < 17) {
-      int packedBytes = ((BPPOUT/8) * ph->size +
-                         w * h * bitsPerPackedPixel[ph->size-1] / 8);
-
-      if (packedBytes < estimatedBytes) {
-        useRle = FALSE;
-        usePalette = TRUE;
-        estimatedBytes = packedBytes;
-      }
-    }
-  }
-
-  if (!usePalette) ph->size = 0;
-
-  zrleOutStreamWriteU8(os, (useRle ? 128 : 0) | ph->size);
-
-  for (i = 0; i < ph->size; i++) {
-    zrleOutStreamWRITE_PIXEL(os, ph->palette[i]);
-  }
-
-  if (useRle) {
-
-    PIXEL_T* ptr = data;
-    PIXEL_T* end = ptr + w * h;
-    PIXEL_T* runStart;
-    PIXEL_T pix;
-    while (ptr < end) {
-      int len;
-      runStart = ptr;
-      pix = *ptr++;
-      while (*ptr == pix && ptr < end)
-        ptr++;
-      len = ptr - runStart;
-      if (len <= 2 && usePalette) {
-        int index = zrlePaletteHelperLookup(ph, pix);
-        if (len == 2)
-          zrleOutStreamWriteU8(os, index);
-        zrleOutStreamWriteU8(os, index);
-        continue;
-      }
-      if (usePalette) {
-        int index = zrlePaletteHelperLookup(ph, pix);
-        zrleOutStreamWriteU8(os, index | 128);
-      } else {
-        zrleOutStreamWRITE_PIXEL(os, pix);
-      }
-      len -= 1;
-      while (len >= 255) {
-        zrleOutStreamWriteU8(os, 255);
-        len -= 255;
-      }
-      zrleOutStreamWriteU8(os, len);
-    }
-
-  } else {
-
-    /* no RLE */
-
-    if (usePalette) {
-      int bppp;
-      PIXEL_T* ptr = data;
-
-      /* packed pixels */
-
-      assert (ph->size < 17);
-
-      bppp = bitsPerPackedPixel[ph->size-1];
-
-      for (i = 0; i < h; i++) {
-        zrle_U8 nbits = 0;
-        zrle_U8 byte = 0;
-
-        PIXEL_T* eol = ptr + w;
-
-        while (ptr < eol) {
-          PIXEL_T pix = *ptr++;
-          zrle_U8 index = zrlePaletteHelperLookup(ph, pix);
-          byte = (byte << bppp) | index;
-          nbits += bppp;
-          if (nbits >= 8) {
-            zrleOutStreamWriteU8(os, byte);
-            nbits = 0;
-          }
-        }
-        if (nbits > 0) {
-          byte <<= 8 - nbits;
-          zrleOutStreamWriteU8(os, byte);
-        }
-      }
-    } else {
-
-      /* raw */
-
-#if BPP!=8
-      if (zywrle_level > 0 && !(zywrle_level & 0x80)) {
-        ZYWRLE_ANALYZE(data, data, w, h, w, zywrle_level, zywrleBuf);
-	ZRLE_ENCODE_TILE(data, w, h, os, zywrle_level | 0x80, zywrleBuf, paletteHelper);
-      }
-      else
-#endif
-      {
-#ifdef CPIXEL
-        PIXEL_T *ptr;
-        for (ptr = data; ptr < data+w*h; ptr++)
-          zrleOutStreamWRITE_PIXEL(os, *ptr);
-#else
-        zrleOutStreamWriteBytes(os, (zrle_U8 *)data, w*h*(BPP/8));
-#endif
-      }
-    }
-  }
-}
-
-#undef PIXEL_T
-#undef zrleOutStreamWRITE_PIXEL
-#undef ZRLE_ENCODE
-#undef ZRLE_ENCODE_TILE
-#undef ZYWRLE_ENCODE_TILE
-#undef BPPOUT
diff --git a/libvncserver/zrleoutstream.c b/libvncserver/zrleoutstream.c
deleted file mode 100644
index 4efe609..0000000
--- a/libvncserver/zrleoutstream.c
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.
- * Copyright (C) 2003 Sun Microsystems, Inc.
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- * USA.
- */
-
-#include "zrleoutstream.h"
-#include <stdlib.h>
-
-#define ZRLE_IN_BUFFER_SIZE  16384
-#define ZRLE_OUT_BUFFER_SIZE 1024
-#undef  ZRLE_DEBUG
-
-static rfbBool zrleBufferAlloc(zrleBuffer *buffer, int size)
-{
-  buffer->ptr = buffer->start = malloc(size);
-  if (buffer->start == NULL) {
-    buffer->end = NULL;
-    return FALSE;
-  }
-
-  buffer->end = buffer->start + size;
-
-  return TRUE;
-}
-
-static void zrleBufferFree(zrleBuffer *buffer)
-{
-  if (buffer->start)
-    free(buffer->start);
-  buffer->start = buffer->ptr = buffer->end = NULL;
-}
-
-static rfbBool zrleBufferGrow(zrleBuffer *buffer, int size)
-{
-  int offset;
-
-  size  += buffer->end - buffer->start;
-  offset = ZRLE_BUFFER_LENGTH (buffer);
-
-  buffer->start = realloc(buffer->start, size);
-  if (!buffer->start) {
-    return FALSE;
-  }
-
-  buffer->end = buffer->start + size;
-  buffer->ptr = buffer->start + offset;
-
-  return TRUE;
-}
-
-zrleOutStream *zrleOutStreamNew(void)
-{
-  zrleOutStream *os;
-
-  os = malloc(sizeof(zrleOutStream));
-  if (os == NULL)
-    return NULL;
-
-  if (!zrleBufferAlloc(&os->in, ZRLE_IN_BUFFER_SIZE)) {
-    free(os);
-    return NULL;
-  }
-
-  if (!zrleBufferAlloc(&os->out, ZRLE_OUT_BUFFER_SIZE)) {
-    zrleBufferFree(&os->in);
-    free(os);
-    return NULL;
-  }
-
-  os->zs.zalloc = Z_NULL;
-  os->zs.zfree  = Z_NULL;
-  os->zs.opaque = Z_NULL;
-  if (deflateInit(&os->zs, Z_DEFAULT_COMPRESSION) != Z_OK) {
-    zrleBufferFree(&os->in);
-    free(os);
-    return NULL;
-  }
-
-  return os;
-}
-
-void zrleOutStreamFree (zrleOutStream *os)
-{
-  deflateEnd(&os->zs);
-  zrleBufferFree(&os->in);
-  zrleBufferFree(&os->out);
-  free(os);
-}
-
-rfbBool zrleOutStreamFlush(zrleOutStream *os)
-{
-  os->zs.next_in = os->in.start;
-  os->zs.avail_in = ZRLE_BUFFER_LENGTH (&os->in);
-  
-#ifdef ZRLE_DEBUG
-  rfbLog("zrleOutStreamFlush: avail_in %d\n", os->zs.avail_in);
-#endif
-
-  while (os->zs.avail_in != 0) {
-    do {
-      int ret;
-
-      if (os->out.ptr >= os->out.end &&
-	  !zrleBufferGrow(&os->out, os->out.end - os->out.start)) {
-	rfbLog("zrleOutStreamFlush: failed to grow output buffer\n");
-	return FALSE;
-      }
-
-      os->zs.next_out = os->out.ptr;
-      os->zs.avail_out = os->out.end - os->out.ptr;
-
-#ifdef ZRLE_DEBUG
-      rfbLog("zrleOutStreamFlush: calling deflate, avail_in %d, avail_out %d\n",
-	     os->zs.avail_in, os->zs.avail_out);
-#endif 
-
-      if ((ret = deflate(&os->zs, Z_SYNC_FLUSH)) != Z_OK) {
-	rfbLog("zrleOutStreamFlush: deflate failed with error code %d\n", ret);
-	return FALSE;
-      }
-
-#ifdef ZRLE_DEBUG
-      rfbLog("zrleOutStreamFlush: after deflate: %d bytes\n",
-	     os->zs.next_out - os->out.ptr);
-#endif
-
-      os->out.ptr = os->zs.next_out;
-    } while (os->zs.avail_out == 0);
-  }
-
-  os->in.ptr = os->in.start;
- 
-  return TRUE;
-}
-
-static int zrleOutStreamOverrun(zrleOutStream *os,
-				int            size)
-{
-#ifdef ZRLE_DEBUG
-  rfbLog("zrleOutStreamOverrun\n");
-#endif
-
-  while (os->in.end - os->in.ptr < size && os->in.ptr > os->in.start) {
-    os->zs.next_in = os->in.start;
-    os->zs.avail_in = ZRLE_BUFFER_LENGTH (&os->in);
-
-    do {
-      int ret;
-
-      if (os->out.ptr >= os->out.end &&
-	  !zrleBufferGrow(&os->out, os->out.end - os->out.start)) {
-	rfbLog("zrleOutStreamOverrun: failed to grow output buffer\n");
-	return FALSE;
-      }
-
-      os->zs.next_out = os->out.ptr;
-      os->zs.avail_out = os->out.end - os->out.ptr;
-
-#ifdef ZRLE_DEBUG
-      rfbLog("zrleOutStreamOverrun: calling deflate, avail_in %d, avail_out %d\n",
-	     os->zs.avail_in, os->zs.avail_out);
-#endif
-
-      if ((ret = deflate(&os->zs, 0)) != Z_OK) {
-	rfbLog("zrleOutStreamOverrun: deflate failed with error code %d\n", ret);
-	return 0;
-      }
-
-#ifdef ZRLE_DEBUG
-      rfbLog("zrleOutStreamOverrun: after deflate: %d bytes\n",
-	     os->zs.next_out - os->out.ptr);
-#endif
-
-      os->out.ptr = os->zs.next_out;
-    } while (os->zs.avail_out == 0);
-
-    /* output buffer not full */
-
-    if (os->zs.avail_in == 0) {
-      os->in.ptr = os->in.start;
-    } else {
-      /* but didn't consume all the data?  try shifting what's left to the
-       * start of the buffer.
-       */
-      rfbLog("zrleOutStreamOverrun: out buf not full, but in data not consumed\n");
-      memmove(os->in.start, os->zs.next_in, os->in.ptr - os->zs.next_in);
-      os->in.ptr -= os->zs.next_in - os->in.start;
-    }
-  }
-
-  if (size > os->in.end - os->in.ptr)
-    size = os->in.end - os->in.ptr;
-
-  return size;
-}
-
-static int zrleOutStreamCheck(zrleOutStream *os, int size)
-{
-  if (os->in.ptr + size > os->in.end) {
-    return zrleOutStreamOverrun(os, size);
-  }
-  return size;
-}
-
-void zrleOutStreamWriteBytes(zrleOutStream *os,
-			     const zrle_U8 *data,
-			     int            length)
-{
-  const zrle_U8* dataEnd = data + length;
-  while (data < dataEnd) {
-    int n = zrleOutStreamCheck(os, dataEnd - data);
-    memcpy(os->in.ptr, data, n);
-    os->in.ptr += n;
-    data += n;
-  }
-}
-
-void zrleOutStreamWriteU8(zrleOutStream *os, zrle_U8 u)
-{
-  zrleOutStreamCheck(os, 1);
-  *os->in.ptr++ = u;
-}
-
-void zrleOutStreamWriteOpaque8(zrleOutStream *os, zrle_U8 u)
-{
-  zrleOutStreamCheck(os, 1);
-  *os->in.ptr++ = u;
-}
-
-void zrleOutStreamWriteOpaque16 (zrleOutStream *os, zrle_U16 u)
-{
-  zrleOutStreamCheck(os, 2);
-  *os->in.ptr++ = ((zrle_U8*)&u)[0];
-  *os->in.ptr++ = ((zrle_U8*)&u)[1];
-}
-
-void zrleOutStreamWriteOpaque32 (zrleOutStream *os, zrle_U32 u)
-{
-  zrleOutStreamCheck(os, 4);
-  *os->in.ptr++ = ((zrle_U8*)&u)[0];
-  *os->in.ptr++ = ((zrle_U8*)&u)[1];
-  *os->in.ptr++ = ((zrle_U8*)&u)[2];
-  *os->in.ptr++ = ((zrle_U8*)&u)[3];
-}
-
-void zrleOutStreamWriteOpaque24A(zrleOutStream *os, zrle_U32 u)
-{
-  zrleOutStreamCheck(os, 3);
-  *os->in.ptr++ = ((zrle_U8*)&u)[0];
-  *os->in.ptr++ = ((zrle_U8*)&u)[1];
-  *os->in.ptr++ = ((zrle_U8*)&u)[2];
-}
-
-void zrleOutStreamWriteOpaque24B(zrleOutStream *os, zrle_U32 u)
-{
-  zrleOutStreamCheck(os, 3);
-  *os->in.ptr++ = ((zrle_U8*)&u)[1];
-  *os->in.ptr++ = ((zrle_U8*)&u)[2];
-  *os->in.ptr++ = ((zrle_U8*)&u)[3];
-}
diff --git a/libvncserver/zrleoutstream.h b/libvncserver/zrleoutstream.h
deleted file mode 100644
index 9e4fe51..0000000
--- a/libvncserver/zrleoutstream.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.
- * Copyright (C) 2003 Sun Microsystems, Inc.
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- * USA.
- */
-
-#ifndef __ZRLE_OUT_STREAM_H__
-#define __ZRLE_OUT_STREAM_H__
-
-#include <zlib.h>
-#include "zrletypes.h"
-#include "rfb/rfb.h"
-
-typedef struct {
-  zrle_U8 *start;
-  zrle_U8 *ptr;
-  zrle_U8 *end;
-} zrleBuffer;
-
-typedef struct {
-  zrleBuffer in;
-  zrleBuffer out;
-
-  z_stream   zs;
-} zrleOutStream;
-
-#define ZRLE_BUFFER_LENGTH(b) ((b)->ptr - (b)->start)
-
-zrleOutStream *zrleOutStreamNew           (void);
-void           zrleOutStreamFree          (zrleOutStream *os);
-rfbBool        zrleOutStreamFlush         (zrleOutStream *os);
-void           zrleOutStreamWriteBytes    (zrleOutStream *os,
-					   const zrle_U8 *data,
-					   int            length);
-void           zrleOutStreamWriteU8       (zrleOutStream *os,
-					   zrle_U8        u);
-void           zrleOutStreamWriteOpaque8  (zrleOutStream *os,
-					   zrle_U8        u);
-void           zrleOutStreamWriteOpaque16 (zrleOutStream *os,
-					   zrle_U16       u);
-void           zrleOutStreamWriteOpaque32 (zrleOutStream *os,
-					   zrle_U32       u);
-void           zrleOutStreamWriteOpaque24A(zrleOutStream *os,
-					   zrle_U32       u);
-void           zrleOutStreamWriteOpaque24B(zrleOutStream *os,
-					   zrle_U32       u);
-
-#endif /* __ZRLE_OUT_STREAM_H__ */
diff --git a/libvncserver/zrlepalettehelper.c b/libvncserver/zrlepalettehelper.c
deleted file mode 100644
index d758a26..0000000
--- a/libvncserver/zrlepalettehelper.c
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.
- * Copyright (C) 2003 Sun Microsystems, Inc.
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- * USA.
- */
-
-#include "zrlepalettehelper.h"
-#include <assert.h>
-#include <string.h>
-
-#define ZRLE_HASH(pix) (((pix) ^ ((pix) >> 17)) & 4095)
-
-void zrlePaletteHelperInit(zrlePaletteHelper *helper)
-{
-  memset(helper->palette, 0, sizeof(helper->palette));
-  memset(helper->index, 255, sizeof(helper->index));
-  memset(helper->key, 0, sizeof(helper->key));
-  helper->size = 0;
-}
-
-void zrlePaletteHelperInsert(zrlePaletteHelper *helper, zrle_U32 pix)
-{
-  if (helper->size < ZRLE_PALETTE_MAX_SIZE) {
-    int i = ZRLE_HASH(pix);
-
-    while (helper->index[i] != 255 && helper->key[i] != pix)
-      i++;
-    if (helper->index[i] != 255) return;
-
-    helper->index[i] = helper->size;
-    helper->key[i] = pix;
-    helper->palette[helper->size] = pix;
-  }
-  helper->size++;
-}
-
-int zrlePaletteHelperLookup(zrlePaletteHelper *helper, zrle_U32 pix)
-{
-  int i = ZRLE_HASH(pix);
-
-  assert(helper->size <= ZRLE_PALETTE_MAX_SIZE);
-  
-  while (helper->index[i] != 255 && helper->key[i] != pix)
-    i++;
-  if (helper->index[i] != 255) return helper->index[i];
-
-  return -1;
-}
diff --git a/libvncserver/zrlepalettehelper.h b/libvncserver/zrlepalettehelper.h
deleted file mode 100644
index e1213d1..0000000
--- a/libvncserver/zrlepalettehelper.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.
- * Copyright (C) 2003 Sun Microsystems, Inc.
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- * USA.
- */
-
-/*
- * The PaletteHelper class helps us build up the palette from pixel data by
- * storing a reverse index using a simple hash-table
- */
-
-#ifndef __ZRLE_PALETTE_HELPER_H__
-#define __ZRLE_PALETTE_HELPER_H__
-
-#include "zrletypes.h"
-
-#define ZRLE_PALETTE_MAX_SIZE 127
-
-typedef struct {
-  zrle_U32  palette[ZRLE_PALETTE_MAX_SIZE];
-  zrle_U8   index[ZRLE_PALETTE_MAX_SIZE + 4096];
-  zrle_U32  key[ZRLE_PALETTE_MAX_SIZE + 4096];
-  int       size;
-} zrlePaletteHelper;
-
-void zrlePaletteHelperInit  (zrlePaletteHelper *helper);
-void zrlePaletteHelperInsert(zrlePaletteHelper *helper,
-			     zrle_U32           pix);
-int  zrlePaletteHelperLookup(zrlePaletteHelper *helper,
-			     zrle_U32           pix);
-
-#endif /* __ZRLE_PALETTE_HELPER_H__ */
diff --git a/libvncserver/zrletypes.h b/libvncserver/zrletypes.h
deleted file mode 100644
index 0df42c9..0000000
--- a/libvncserver/zrletypes.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2002 RealVNC Ltd.  All Rights Reserved.
- *
- * This is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this software; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- * USA.
- */
-
-#ifndef __ZRLE_TYPES_H__
-#define __ZRLE_TYPES_H__
-
-typedef unsigned char  zrle_U8;
-typedef unsigned short zrle_U16;
-typedef unsigned int   zrle_U32;
-typedef signed char    zrle_S8;
-typedef signed short   zrle_S16;
-typedef signed int     zrle_S32;
-
-#endif /* __ZRLE_TYPES_H__ */
diff --git a/libvncserver/zywrletemplate.c b/libvncserver/zywrletemplate.c
deleted file mode 100644
index 904de40..0000000
--- a/libvncserver/zywrletemplate.c
+++ /dev/null
@@ -1,828 +0,0 @@
-
-/********************************************************************
- *                                                                  *
- * THIS FILE IS PART OF THE 'ZYWRLE' VNC CODEC SOURCE CODE.         *
- *                                                                  *
- * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
- * GOVERNED BY A FOLLOWING BSD-STYLE SOURCE LICENSE.                *
- * PLEASE READ THESE TERMS BEFORE DISTRIBUTING.                     *
- *                                                                  *
- * THE 'ZYWRLE' VNC CODEC SOURCE CODE IS (C) COPYRIGHT 2006         *
- * BY Hitachi Systems & Services, Ltd.                              *
- * (Noriaki Yamazaki, Research & Developement Center)               *                                                                 *
- *                                                                  *
- ********************************************************************
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-- Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-
-- Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-
-- Neither the name of the Hitachi Systems & Services, Ltd. nor
-the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written
-permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ********************************************************************/
-
-/* Change Log:
-     V0.02 : 2008/02/04 : Fix mis encode/decode when width != scanline
-	                     (Thanks Johannes Schindelin, author of LibVNC
-						  Server/Client)
-     V0.01 : 2007/02/06 : Initial release
-*/
-
-/* #define ZYWRLE_ENCODE */
-/* #define ZYWRLE_DECODE */
-#define ZYWRLE_QUANTIZE
-
-/*
-[References]
- PLHarr:
-   Senecal, J. G., P. Lindstrom, M. A. Duchaineau, and K. I. Joy, "An Improved N-Bit to N-Bit Reversible Haar-Like Transform," Pacific Graphics 2004, October 2004, pp. 371-380.
- EZW:
-   Shapiro, JM: Embedded Image Coding Using Zerotrees of Wavelet Coefficients, IEEE Trans. Signal. Process., Vol.41, pp.3445-3462 (1993).
-*/
-
-
-/* Template Macro stuffs. */
-#undef ZYWRLE_ANALYZE
-#undef ZYWRLE_SYNTHESIZE
-#define ZYWRLE_ANALYZE __RFB_CONCAT3E(zywrleAnalyze,BPP,END_FIX)
-#define ZYWRLE_SYNTHESIZE __RFB_CONCAT3E(zywrleSynthesize,BPP,END_FIX)
-
-#define ZYWRLE_RGBYUV __RFB_CONCAT3E(zywrleRGBYUV,BPP,END_FIX)
-#define ZYWRLE_YUVRGB __RFB_CONCAT3E(zywrleYUVRGB,BPP,END_FIX)
-#define ZYWRLE_YMASK __RFB_CONCAT2E(ZYWRLE_YMASK,BPP)
-#define ZYWRLE_UVMASK __RFB_CONCAT2E(ZYWRLE_UVMASK,BPP)
-#define ZYWRLE_LOAD_PIXEL __RFB_CONCAT2E(ZYWRLE_LOAD_PIXEL,BPP)
-#define ZYWRLE_SAVE_PIXEL __RFB_CONCAT2E(ZYWRLE_SAVE_PIXEL,BPP)
-
-/* Packing/Unpacking pixel stuffs.
-   Endian conversion stuffs. */
-#undef S_0
-#undef S_1
-#undef L_0
-#undef L_1
-#undef L_2
-#if ZYWRLE_ENDIAN == ENDIAN_BIG
-#  define S_0	1
-#  define S_1	0
-#  define L_0	3
-#  define L_1	2
-#  define L_2	1
-#else
-#  define S_0	0
-#  define S_1	1
-#  define L_0	0
-#  define L_1	1
-#  define L_2	2
-#endif
-
-/*   Load/Save pixel stuffs. */
-#define ZYWRLE_YMASK15  0xFFFFFFF8
-#define ZYWRLE_UVMASK15 0xFFFFFFF8
-#define ZYWRLE_LOAD_PIXEL15(pSrc,R,G,B) { \
-	R =  (((unsigned char*)pSrc)[S_1]<< 1)& 0xF8;	\
-	G = ((((unsigned char*)pSrc)[S_1]<< 6)|(((unsigned char*)pSrc)[S_0]>> 2))& 0xF8;	\
-	B =  (((unsigned char*)pSrc)[S_0]<< 3)& 0xF8;	\
-}
-#define ZYWRLE_SAVE_PIXEL15(pDst,R,G,B) { \
-	R &= 0xF8;	\
-	G &= 0xF8;	\
-	B &= 0xF8;	\
-	((unsigned char*)pDst)[S_1] = (unsigned char)( (R>>1)|(G>>6)       );	\
-	((unsigned char*)pDst)[S_0] = (unsigned char)(((B>>3)|(G<<2))& 0xFF);	\
-}
-#define ZYWRLE_YMASK16  0xFFFFFFFC
-#define ZYWRLE_UVMASK16 0xFFFFFFF8
-#define ZYWRLE_LOAD_PIXEL16(pSrc,R,G,B) { \
-	R =   ((unsigned char*)pSrc)[S_1]     & 0xF8;	\
-	G = ((((unsigned char*)pSrc)[S_1]<< 5)|(((unsigned char*)pSrc)[S_0]>> 3))& 0xFC;	\
-	B =  (((unsigned char*)pSrc)[S_0]<< 3)& 0xF8;	\
-}
-#define ZYWRLE_SAVE_PIXEL16(pDst,R,G,B) { \
-	R &= 0xF8;	\
-	G &= 0xFC;	\
-	B &= 0xF8;	\
-	((unsigned char*)pDst)[S_1] = (unsigned char)(  R    |(G>>5)       );	\
-	((unsigned char*)pDst)[S_0] = (unsigned char)(((B>>3)|(G<<3))& 0xFF);	\
-}
-#define ZYWRLE_YMASK32  0xFFFFFFFF
-#define ZYWRLE_UVMASK32 0xFFFFFFFF
-#define ZYWRLE_LOAD_PIXEL32(pSrc,R,G,B) { \
-	R = ((unsigned char*)pSrc)[L_2];	\
-	G = ((unsigned char*)pSrc)[L_1];	\
-	B = ((unsigned char*)pSrc)[L_0];	\
-}
-#define ZYWRLE_SAVE_PIXEL32(pDst,R,G,B) { \
-	((unsigned char*)pDst)[L_2] = (unsigned char)R;	\
-	((unsigned char*)pDst)[L_1] = (unsigned char)G;	\
-	((unsigned char*)pDst)[L_0] = (unsigned char)B;	\
-}
-
-#ifndef ZYWRLE_ONCE
-#define ZYWRLE_ONCE
-
-#ifdef WIN32
-#define InlineX __inline
-#else
-# ifndef __STRICT_ANSI__
-#  define InlineX inline
-# else
-#  define InlineX
-# endif
-#endif
-
-#ifdef ZYWRLE_ENCODE
-/* Tables for Coefficients filtering. */
-#  ifndef ZYWRLE_QUANTIZE
-/* Type A:lower bit omitting of EZW style. */
-const static unsigned int zywrleParam[3][3]={
-	{0x0000F000,0x00000000,0x00000000},
-	{0x0000C000,0x00F0F0F0,0x00000000},
-	{0x0000C000,0x00C0C0C0,0x00F0F0F0},
-/*	{0x0000FF00,0x00000000,0x00000000},
-	{0x0000FF00,0x00FFFFFF,0x00000000},
-	{0x0000FF00,0x00FFFFFF,0x00FFFFFF}, */
-};
-#  else
-/* Type B:Non liner quantization filter. */
-static const signed char zywrleConv[4][256]={
-{	/* bi=5, bo=5 r=0.0:PSNR=24.849 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-},
-{	/* bi=5, bo=5 r=2.0:PSNR=74.031 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	48, 48, 48, 56, 56, 56, 56, 56,
-	56, 56, 56, 56, 64, 64, 64, 64,
-	64, 64, 64, 64, 72, 72, 72, 72,
-	72, 72, 72, 72, 80, 80, 80, 80,
-	80, 80, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 96, 96,
-	96, 96, 96, 104, 104, 104, 104, 104,
-	104, 104, 104, 104, 104, 112, 112, 112,
-	112, 112, 112, 112, 112, 112, 120, 120,
-	120, 120, 120, 120, 120, 120, 120, 120,
-	0, -120, -120, -120, -120, -120, -120, -120,
-	-120, -120, -120, -112, -112, -112, -112, -112,
-	-112, -112, -112, -112, -104, -104, -104, -104,
-	-104, -104, -104, -104, -104, -104, -96, -96,
-	-96, -96, -96, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -80,
-	-80, -80, -80, -80, -80, -72, -72, -72,
-	-72, -72, -72, -72, -72, -64, -64, -64,
-	-64, -64, -64, -64, -64, -56, -56, -56,
-	-56, -56, -56, -56, -56, -56, -48, -48,
-	-48, -48, -48, -48, -48, -48, -48, -48,
-	-48, -32, -32, -32, -32, -32, -32, -32,
-	-32, -32, -32, -32, -32, -32, -32, -32,
-	-32, -32, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-},
-{	/* bi=5, bo=4 r=2.0:PSNR=64.441 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64,
-	80, 80, 80, 80, 80, 80, 80, 80,
-	80, 80, 80, 80, 80, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	104, 104, 104, 104, 104, 104, 104, 104,
-	104, 104, 104, 112, 112, 112, 112, 112,
-	112, 112, 112, 112, 120, 120, 120, 120,
-	120, 120, 120, 120, 120, 120, 120, 120,
-	0, -120, -120, -120, -120, -120, -120, -120,
-	-120, -120, -120, -120, -120, -112, -112, -112,
-	-112, -112, -112, -112, -112, -112, -104, -104,
-	-104, -104, -104, -104, -104, -104, -104, -104,
-	-104, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -80, -80, -80, -80,
-	-80, -80, -80, -80, -80, -80, -80, -80,
-	-80, -64, -64, -64, -64, -64, -64, -64,
-	-64, -64, -64, -64, -64, -64, -64, -64,
-	-64, -48, -48, -48, -48, -48, -48, -48,
-	-48, -48, -48, -48, -48, -48, -48, -48,
-	-48, -48, -48, -48, -48, -48, -48, -48,
-	-48, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-},
-{	/* bi=5, bo=2 r=2.0:PSNR=43.175 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	0, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-}
-};
-const static signed char* zywrleParam[3][3][3]={
-	{{zywrleConv[0],zywrleConv[2],zywrleConv[0]},{zywrleConv[0],zywrleConv[0],zywrleConv[0]},{zywrleConv[0],zywrleConv[0],zywrleConv[0]}},
-	{{zywrleConv[0],zywrleConv[3],zywrleConv[0]},{zywrleConv[1],zywrleConv[1],zywrleConv[1]},{zywrleConv[0],zywrleConv[0],zywrleConv[0]}},
-	{{zywrleConv[0],zywrleConv[3],zywrleConv[0]},{zywrleConv[2],zywrleConv[2],zywrleConv[2]},{zywrleConv[1],zywrleConv[1],zywrleConv[1]}},
-};
-#  endif
-#endif
-
-static InlineX void Harr(signed char* pX0, signed char* pX1)
-{
-	/* Piecewise-Linear Harr(PLHarr) */
-	int X0 = (int)*pX0, X1 = (int)*pX1;
-	int orgX0 = X0, orgX1 = X1;
-	if ((X0 ^ X1) & 0x80) {
-		/* differ sign */
-		X1 += X0;
-		if (((X1^orgX1)&0x80)==0) {
-			/* |X1| > |X0| */
-			X0 -= X1;	/* H = -B */
-		}
-	} else {
-		/* same sign */
-		X0 -= X1;
-		if (((X0 ^ orgX0) & 0x80) == 0) {
-			/* |X0| > |X1| */
-			X1 += X0;	/* L = A */
-		}
-	}
-	*pX0 = (signed char)X1;
-	*pX1 = (signed char)X0;
-}
-/*
- 1D-Wavelet transform.
-
- In coefficients array, the famous 'pyramid' decomposition is well used.
-
- 1D Model:
-   |L0L0L0L0|L0L0L0L0|H0H0H0H0|H0H0H0H0| : level 0
-   |L1L1L1L1|H1H1H1H1|H0H0H0H0|H0H0H0H0| : level 1
-
- But this method needs line buffer because H/L is different position from X0/X1.
- So, I used 'interleave' decomposition instead of it.
-
- 1D Model:
-   |L0H0L0H0|L0H0L0H0|L0H0L0H0|L0H0L0H0| : level 0
-   |L1H0H1H0|L1H0H1H0|L1H0H1H0|L1H0H1H0| : level 1
-
- In this method, H/L and X0/X1 is always same position.
- This lead us to more speed and less memory.
- Of cause, the result of both method is quite same
- because it's only difference that coefficient position.
-*/
-static InlineX void WaveletLevel(int* data, int size, int l, int SkipPixel)
-{
-	int s, ofs;
-	signed char* pX0;
-	signed char* end;
-
-	pX0 = (signed char*)data;
-	s = (8<<l)*SkipPixel;
-	end = pX0+(size>>(l+1))*s;
-	s -= 2;
-	ofs = (4<<l)*SkipPixel;
-	while (pX0 < end) {
-		Harr(pX0, pX0+ofs);
-		pX0++;
-		Harr(pX0, pX0+ofs);
-		pX0++;
-		Harr(pX0, pX0+ofs);
-		pX0 += s;
-	}
-}
-#define InvWaveletLevel(d,s,l,pix) WaveletLevel(d,s,l,pix)
-
-#ifdef ZYWRLE_ENCODE
-#  ifndef ZYWRLE_QUANTIZE
-/* Type A:lower bit omitting of EZW style. */
-static InlineX void FilterWaveletSquare(int* pBuf, int width, int height, int level, int l)
-{
-	int r, s;
-	int x, y;
-	int* pH;
-	const unsigned int* pM;
-
-	pM = &(zywrleParam[level-1][l]);
-	s = 2<<l;
-	for (r = 1; r < 4; r++) {
-		pH   = pBuf;
-		if (r & 0x01)
-			pH +=  s>>1;
-		if (r & 0x02)
-			pH += (s>>1)*width;
-		for (y = 0; y < height / s; y++) {
-			for (x = 0; x < width / s; x++) {
-				/*
-				 these are same following code.
-				     pH[x] = pH[x] / (~pM[x]+1) * (~pM[x]+1);
-				     ( round pH[x] with pM[x] bit )
-				 '&' operator isn't 'round' but is 'floor'.
-				 So, we must offset when pH[x] is negative.
-				*/
-				if (((signed char*)pH)[0] & 0x80)
-					((signed char*)pH)[0] += ~((signed char*)pM)[0];
-				if (((signed char*)pH)[1] & 0x80)
-					((signed char*)pH)[1] += ~((signed char*)pM)[1];
-				if (((signed char*)pH)[2] & 0x80)
-					((signed char*)pH)[2] += ~((signed char*)pM)[2];
-				*pH &= *pM;
-				pH += s;
-			}
-			pH += (s-1)*width;
-		}
-	}
-}
-#  else
-/*
- Type B:Non liner quantization filter.
-
- Coefficients have Gaussian curve and smaller value which is
- large part of coefficients isn't more important than larger value.
- So, I use filter of Non liner quantize/dequantize table.
- In general, Non liner quantize formula is explained as following.
-
-    y=f(x)   = sign(x)*round( ((abs(x)/(2^7))^ r   )* 2^(bo-1) )*2^(8-bo)
-    x=f-1(y) = sign(y)*round( ((abs(y)/(2^7))^(1/r))* 2^(bi-1) )*2^(8-bi)
- ( r:power coefficient  bi:effective MSB in input  bo:effective MSB in output )
-
-   r < 1.0 : Smaller value is more important than larger value.
-   r > 1.0 : Larger value is more important than smaller value.
-   r = 1.0 : Liner quantization which is same with EZW style.
-
- r = 0.75 is famous non liner quantization used in MP3 audio codec.
- In contrast to audio data, larger value is important in wavelet coefficients.
- So, I select r = 2.0 table( quantize is x^2, dequantize sqrt(x) ).
-
- As compared with EZW style liner quantization, this filter tended to be
- more sharp edge and be more compression rate but be more blocking noise and be less quality.
- Especially, the surface of graphic objects has distinguishable noise in middle quality mode.
-
- We need only quantized-dequantized(filtered) value rather than quantized value itself
- because all values are packed or palette-lized in later ZRLE section.
- This lead us not to need to modify client decoder when we change
- the filtering procedure in future.
- Client only decodes coefficients given by encoder.
-*/
-static InlineX void FilterWaveletSquare(int* pBuf, int width, int height, int level, int l)
-{
-	int r, s;
-	int x, y;
-	int* pH;
-	const signed char** pM;
-
-	pM = zywrleParam[level-1][l];
-	s = 2<<l;
-	for (r = 1; r < 4; r++) {
-		pH   = pBuf;
-		if (r & 0x01)
-			pH +=  s>>1;
-		if (r & 0x02)
-			pH += (s>>1)*width;
-		for (y = 0; y < height / s; y++) {
-			for (x = 0; x < width / s; x++) {
-				((signed char*)pH)[0] = pM[0][((unsigned char*)pH)[0]];
-				((signed char*)pH)[1] = pM[1][((unsigned char*)pH)[1]];
-				((signed char*)pH)[2] = pM[2][((unsigned char*)pH)[2]];
-				pH += s;
-			}
-			pH += (s-1)*width;
-		}
-	}
-}
-#  endif
-
-static InlineX void Wavelet(int* pBuf, int width, int height, int level)
-{
-	int l, s;
-	int* pTop;
-	int* pEnd;
-
-	for (l = 0; l < level; l++) {
-		pTop = pBuf;
-		pEnd = pBuf+height*width;
-		s = width<<l;
-		while (pTop < pEnd) {
-			WaveletLevel(pTop, width, l, 1);
-			pTop += s;
-		}
-		pTop = pBuf;
-		pEnd = pBuf+width;
-		s = 1<<l;
-		while (pTop < pEnd) {
-			WaveletLevel(pTop, height,l, width);
-			pTop += s;
-		}
-		FilterWaveletSquare(pBuf, width, height, level, l);
-	}
-}
-#endif
-#ifdef ZYWRLE_DECODE
-static InlineX void InvWavelet(int* pBuf, int width, int height, int level)
-{
-	int l, s;
-	int* pTop;
-	int* pEnd;
-
-	for (l = level - 1; l >= 0; l--) {
-		pTop = pBuf;
-		pEnd = pBuf+width;
-		s = 1<<l;
-		while (pTop < pEnd) {
-			InvWaveletLevel(pTop, height,l, width);
-			pTop += s;
-		}
-		pTop = pBuf;
-		pEnd = pBuf+height*width;
-		s = width<<l;
-		while (pTop < pEnd) {
-			InvWaveletLevel(pTop, width, l, 1);
-			pTop += s;
-		}
-	}
-}
-#endif
-
-/* Load/Save coefficients stuffs.
- Coefficients manages as 24 bits little-endian pixel. */
-#define ZYWRLE_LOAD_COEFF(pSrc,R,G,B) { \
-	R = ((signed char*)pSrc)[2];	\
-	G = ((signed char*)pSrc)[1];	\
-	B = ((signed char*)pSrc)[0];	\
-}
-#define ZYWRLE_SAVE_COEFF(pDst,R,G,B) { \
-	((signed char*)pDst)[2] = (signed char)R;	\
-	((signed char*)pDst)[1] = (signed char)G;	\
-	((signed char*)pDst)[0] = (signed char)B;	\
-}
-
-/*
- RGB <=> YUV conversion stuffs.
- YUV coversion is explained as following formula in strict meaning:
-   Y =  0.299R + 0.587G + 0.114B (   0<=Y<=255)
-   U = -0.169R - 0.331G + 0.500B (-128<=U<=127)
-   V =  0.500R - 0.419G - 0.081B (-128<=V<=127)
-
- I use simple conversion RCT(reversible color transform) which is described
- in JPEG-2000 specification.
-   Y = (R + 2G + B)/4 (   0<=Y<=255)
-   U = B-G (-256<=U<=255)
-   V = R-G (-256<=V<=255)
-*/
-#define ROUND(x) (((x)<0)?0:(((x)>255)?255:(x)))
-	/* RCT is N-bit RGB to N-bit Y and N+1-bit UV.
-	 For make Same N-bit, UV is lossy.
-	 More exact PLHarr, we reduce to odd range(-127<=x<=127). */
-#define ZYWRLE_RGBYUV1(R,G,B,Y,U,V,ymask,uvmask) { \
-	Y = (R+(G<<1)+B)>>2;	\
-	U =  B-G;	\
-	V =  R-G;	\
-	Y -= 128;	\
-	U >>= 1;	\
-	V >>= 1;	\
-	Y &= ymask;	\
-	U &= uvmask;	\
-	V &= uvmask;	\
-	if (Y == -128)	\
-		Y += (0xFFFFFFFF-ymask+1);	\
-	if (U == -128)	\
-		U += (0xFFFFFFFF-uvmask+1);	\
-	if (V == -128)	\
-		V += (0xFFFFFFFF-uvmask+1);	\
-}
-#define ZYWRLE_YUVRGB1(R,G,B,Y,U,V) { \
-	Y += 128;	\
-	U <<= 1;	\
-	V <<= 1;	\
-	G = Y-((U+V)>>2);	\
-	B = U+G;	\
-	R = V+G;	\
-	G = ROUND(G);	\
-	B = ROUND(B);	\
-	R = ROUND(R);	\
-}
-
-/*
- coefficient packing/unpacking stuffs.
- Wavelet transform makes 4 sub coefficient image from 1 original image.
-
- model with pyramid decomposition:
-   +------+------+
-   |      |      |
-   |  L   |  Hx  |
-   |      |      |
-   +------+------+
-   |      |      |
-   |  H   |  Hxy |
-   |      |      |
-   +------+------+
-
- So, we must transfer each sub images individually in strict meaning.
- But at least ZRLE meaning, following one decompositon image is same as
- avobe individual sub image. I use this format.
- (Strictly saying, transfer order is reverse(Hxy->Hy->Hx->L)
-  for simplified procedure for any wavelet level.)
-
-   +------+------+
-   |      L      |
-   +------+------+
-   |      Hx     |
-   +------+------+
-   |      Hy     |
-   +------+------+
-   |      Hxy    |
-   +------+------+
-*/
-#define INC_PTR(data) \
-	data++;	\
-	if( data-pData >= (w+uw) ){	\
-		data += scanline-(w+uw);	\
-		pData = data;	\
-	}
-
-#define ZYWRLE_TRANSFER_COEFF(pBuf,data,r,w,h,scanline,level,TRANS)	\
-	pH = pBuf;	\
-	s = 2<<level;	\
-	if (r & 0x01)	\
-		pH +=  s>>1;	\
-	if (r & 0x02)	\
-		pH += (s>>1)*w;	\
-	pEnd = pH+h*w;	\
-	while (pH < pEnd) {	\
-		pLine = pH+w;	\
-		while (pH < pLine) {	\
-			TRANS	\
-			INC_PTR(data)	\
-			pH += s;	\
-		}	\
-		pH += (s-1)*w;	\
-	}
-
-#define ZYWRLE_PACK_COEFF(pBuf,data,r,width,height,scanline,level)	\
-	ZYWRLE_TRANSFER_COEFF(pBuf,data,r,width,height,scanline,level,ZYWRLE_LOAD_COEFF(pH,R,G,B);ZYWRLE_SAVE_PIXEL(data,R,G,B);)
-
-#define ZYWRLE_UNPACK_COEFF(pBuf,data,r,width,height,scanline,level)	\
-	ZYWRLE_TRANSFER_COEFF(pBuf,data,r,width,height,scanline,level,ZYWRLE_LOAD_PIXEL(data,R,G,B);ZYWRLE_SAVE_COEFF(pH,R,G,B);)
-
-#define ZYWRLE_SAVE_UNALIGN(data,TRANS)	\
-	pTop = pBuf+w*h;	\
-	pEnd = pBuf + (w+uw)*(h+uh);	\
-	while (pTop < pEnd) {	\
-		TRANS	\
-		INC_PTR(data)	\
-		pTop++;	\
-	}
-
-#define ZYWRLE_LOAD_UNALIGN(data,TRANS)	\
-	pTop = pBuf+w*h;	\
-	if (uw) {	\
-		pData=         data + w;	\
-		pEnd = (int*)(pData+ h*scanline);	\
-		while (pData < (PIXEL_T*)pEnd) {	\
-			pLine = (int*)(pData + uw);	\
-			while (pData < (PIXEL_T*)pLine) {	\
-				TRANS	\
-				pData++;	\
-				pTop++;	\
-			}	\
-			pData += scanline-uw;	\
-		}	\
-	}	\
-	if (uh) {	\
-		pData=         data +  h*scanline;	\
-		pEnd = (int*)(pData+ uh*scanline);	\
-		while (pData < (PIXEL_T*)pEnd) {	\
-			pLine = (int*)(pData + w);	\
-			while (pData < (PIXEL_T*)pLine) {	\
-				TRANS	\
-				pData++;	\
-				pTop++;	\
-			}	\
-			pData += scanline-w;	\
-		}	\
-	}	\
-	if (uw && uh) {	\
-		pData=         data + w+ h*scanline;	\
-		pEnd = (int*)(pData+   uh*scanline);	\
-		while (pData < (PIXEL_T*)pEnd) {	\
-			pLine = (int*)(pData + uw);	\
-			while (pData < (PIXEL_T*)pLine) {	\
-				TRANS	\
-				pData++;	\
-				pTop++;	\
-			}	\
-			pData += scanline-uw;	\
-		}	\
-	}
-
-static InlineX void zywrleCalcSize(int* pW, int* pH, int level)
-{
-	*pW &= ~((1<<level)-1);
-	*pH &= ~((1<<level)-1);
-}
-
-#endif /* ZYWRLE_ONCE */
-
-#ifndef CPIXEL
-#ifdef ZYWRLE_ENCODE
-static InlineX void ZYWRLE_RGBYUV(int* pBuf, PIXEL_T* data, int width, int height, int scanline)
-{
-	int R, G, B;
-	int Y, U, V;
-	int* pLine;
-	int* pEnd;
-	pEnd = pBuf+height*width;
-	while (pBuf < pEnd) {
-		pLine = pBuf+width;
-		while (pBuf < pLine) {
-			ZYWRLE_LOAD_PIXEL(data,R,G,B);
-			ZYWRLE_RGBYUV1(R,G,B,Y,U,V,ZYWRLE_YMASK,ZYWRLE_UVMASK);
-			ZYWRLE_SAVE_COEFF(pBuf,V,Y,U);
-			pBuf++;
-			data++;
-		}
-		data += scanline-width;
-	}
-}
-#endif
-#ifdef ZYWRLE_DECODE
-static InlineX void ZYWRLE_YUVRGB(int* pBuf, PIXEL_T* data, int width, int height, int scanline) {
-	int R, G, B;
-	int Y, U, V;
-	int* pLine;
-	int* pEnd;
-	pEnd = pBuf+height*width;
-	while (pBuf < pEnd) {
-		pLine = pBuf+width;
-		while (pBuf < pLine) {
-			ZYWRLE_LOAD_COEFF(pBuf,V,Y,U);
-			ZYWRLE_YUVRGB1(R,G,B,Y,U,V);
-			ZYWRLE_SAVE_PIXEL(data,R,G,B);
-			pBuf++;
-			data++;
-		}
-		data += scanline-width;
-	}
-}
-#endif
-
-#ifdef ZYWRLE_ENCODE
-PIXEL_T* ZYWRLE_ANALYZE(PIXEL_T* dst, PIXEL_T* src, int w, int h, int scanline, int level, int* pBuf) {
-	int l;
-	int uw = w;
-	int uh = h;
-	int* pTop;
-	int* pEnd;
-	int* pLine;
-	PIXEL_T* pData;
-	int R, G, B;
-	int s;
-	int* pH;
-
-	zywrleCalcSize(&w, &h, level);
-	if (w == 0 || h == 0)
-		return NULL;
-	uw -= w;
-	uh -= h;
-
-	pData = dst;
-	ZYWRLE_LOAD_UNALIGN(src,*(PIXEL_T*)pTop=*pData;)
-	ZYWRLE_RGBYUV(pBuf, src, w, h, scanline);
-	Wavelet(pBuf, w, h, level);
-	for (l = 0; l < level; l++) {
-		ZYWRLE_PACK_COEFF(pBuf, dst, 3, w, h, scanline, l);
-		ZYWRLE_PACK_COEFF(pBuf, dst, 2, w, h, scanline, l);
-		ZYWRLE_PACK_COEFF(pBuf, dst, 1, w, h, scanline, l);
-		if (l == level - 1) {
-			ZYWRLE_PACK_COEFF(pBuf, dst, 0, w, h, scanline, l);
-		}
-	}
-	ZYWRLE_SAVE_UNALIGN(dst,*dst=*(PIXEL_T*)pTop;)
-	return dst;
-}
-#endif
-#ifdef ZYWRLE_DECODE
-PIXEL_T* ZYWRLE_SYNTHESIZE(PIXEL_T* dst, PIXEL_T* src, int w, int h, int scanline, int level, int* pBuf)
-{
-	int l;
-	int uw = w;
-	int uh = h;
-	int* pTop;
-	int* pEnd;
-	int* pLine;
-	PIXEL_T* pData;
-	int R, G, B;
-	int s;
-	int* pH;
-
-	zywrleCalcSize(&w, &h, level);
-	if (w == 0 || h == 0)
-		return NULL;
-	uw -= w;
-	uh -= h;
-
-	pData = src;
-	for (l = 0; l < level; l++) {
-		ZYWRLE_UNPACK_COEFF(pBuf, src, 3, w, h, scanline, l);
-		ZYWRLE_UNPACK_COEFF(pBuf, src, 2, w, h, scanline, l);
-		ZYWRLE_UNPACK_COEFF(pBuf, src, 1, w, h, scanline, l);
-		if (l == level - 1) {
-			ZYWRLE_UNPACK_COEFF(pBuf, src, 0, w, h, scanline, l);
-		}
-	}
-	ZYWRLE_SAVE_UNALIGN(src,*(PIXEL_T*)pTop=*src;)
-	InvWavelet(pBuf, w, h, level);
-	ZYWRLE_YUVRGB(pBuf, dst, w, h, scanline);
-	ZYWRLE_LOAD_UNALIGN(dst,*pData=*(PIXEL_T*)pTop;)
-	return src;
-}
-#endif
-#endif  /* CPIXEL */
-
-#undef ZYWRLE_RGBYUV
-#undef ZYWRLE_YUVRGB
-#undef ZYWRLE_LOAD_PIXEL
-#undef ZYWRLE_SAVE_PIXEL
-- 
2.0.4

